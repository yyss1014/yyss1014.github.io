<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SQL语句 | WASD研究院</title>
<link rel="shortcut icon" href="https://yyss1014.github.io/favicon.ico?v=1751633121752">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://yyss1014.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="SQL语句 | WASD研究院 - Atom Feed" href="https://yyss1014.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
DDL

表操作

创建表格
数据类型
表操作




DML

增加
更新
删除


DQL

基础查询
条件查询
分组聚合查询
排序查询
分页查询




DDL
表操作
创建表格
create table user(
    id ..." />
    <meta name="keywords" content="JavaWeb" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://yyss1014.github.io">
  <img class="avatar" src="https://yyss1014.github.io/images/avatar.png?v=1751633121752" alt="">
  </a>
  <h1 class="site-title">
    WASD研究院
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/archives" class="menu">
          目录
        </a>
      
    
      
        <a href="/" class="menu">
          文章
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              SQL语句
            </h2>
            <div class="post-info">
              <span>
                2025-05-28
              </span>
              <span>
                13 min read
              </span>
              
                <a href="https://yyss1014.github.io/tag/2ON39h6GJZ/" class="post-tag">
                  # JavaWeb
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p><ul class="markdownIt-TOC">
<li><a href="#ddl"><strong>DDL</strong></a>
<ul>
<li><a href="#%E8%A1%A8%E6%93%8D%E4%BD%9C"><strong>表操作</strong></a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%A0%BC"><strong>创建表格</strong></a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><strong>数据类型</strong></a></li>
<li><a href="#%E8%A1%A8%E6%93%8D%E4%BD%9C-2"><strong>表操作</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#dml"><strong>DML</strong></a>
<ul>
<li><a href="#%E5%A2%9E%E5%8A%A0"><strong>增加</strong></a></li>
<li><a href="#%E6%9B%B4%E6%96%B0"><strong>更新</strong></a></li>
<li><a href="#%E5%88%A0%E9%99%A4"><strong>删除</strong></a></li>
</ul>
</li>
<li><a href="#dql"><strong>DQL</strong></a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2"><strong>基础查询</strong></a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><strong>条件查询</strong></a></li>
<li><a href="#%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2"><strong>分组聚合查询</strong></a></li>
<li><a href="#%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2"><strong>排序查询</strong></a></li>
<li><a href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><strong>分页查询</strong></a></li>
</ul>
</li>
</ul>
</p>
<h1 id="ddl"><strong>DDL</strong></h1>
<h2 id="表操作"><strong>表操作</strong></h2>
<h3 id="创建表格"><strong>创建表格</strong></h3>
<pre><code class="language-sql">create table user(
    id int comment 'ID，唯一标识',
    username varchar(50) comment '用户名',# 字符最长50
    name varchar(10) comment '姓名',
    age int comment '年龄',
    gender char(1) comment '性别'
)comment '用户信息表';
</code></pre>
<p>所谓约束就是作用在表中字段上的规则，用于限制存储在表中的数据，来保证数据库当中数据的正确性、有效性和完整性。在MySQL数据库当中，提供了以下5种约束：</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>非空约束</td>
<td>限制该字段值不能为null</td>
<td>not null</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证字段的所有数据都是唯一、不重复的</td>
<td>unique</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>primary key</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段值，则采用默认值</td>
<td>default</td>
</tr>
<tr>
<td>外键约束</td>
<td>让两张表的数据建立连接，保证数据的一致性和完整性</td>
<td>foreign key</td>
</tr>
</tbody>
</table>
<p>主键自增：auto_increment</p>
<ul>
<li>每次插入新的行记录时，数据库自动生成id字段(主键)下的值</li>
<li>具有auto_increment的数据列是一个正数序列开始增长(从1开始自增)，可以指定主键，下次增加会从指定的主键增长</li>
</ul>
<pre><code class="language-sql">create table user(
    id int primary key  auto_increment comment 'ID，唯一标识',-- 主键约束
    username varchar(50) not null unique comment '用户名', -- 非空且唯一
    name varchar(10) not null comment '姓名',-- 非空
    age int comment '年龄',
    gender char(1) default '男' comment '性别'-- 默认
)comment '用户信息表';
</code></pre>
<h3 id="数据类型"><strong>数据类型</strong></h3>
<p>MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。<br>
数值类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>有符号(SIGNED)范围</th>
<th>无符号(UNSIGNED)范围</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1byte</td>
<td>(-128，127)</td>
<td>(0，255)</td>
<td>小整数值</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2bytes</td>
<td>(-32768，32767)</td>
<td>(0，65535)</td>
<td>大整数值</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3bytes</td>
<td>(-8388608，8388607)</td>
<td>(0，16777215)</td>
<td>大整数值</td>
</tr>
<tr>
<td>INT/INTEGER</td>
<td>4bytes</td>
<td>(-2147483648，2147483647)</td>
<td>(0，4294967295)</td>
<td>大整数值</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8bytes</td>
<td>(-2<sup>63，2</sup>63-1)</td>
<td>(0，2^64-1)</td>
<td>极大整数值</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4bytes</td>
<td>(-3.402823466 E+38，3.402823466351 E+38)</td>
<td>0 和 (1.175494351 E-38，3.402823466 E+38)</td>
<td>单精度浮点数值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8bytes</td>
<td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td>
<td>0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308)</td>
<td>双精度浮点数值</td>
</tr>
<tr>
<td>DECIMAL</td>
<td></td>
<td>依赖于M(精度)和D(标度)的值</td>
<td>依赖于M(精度)和D(标度)的值</td>
<td>小数值(精确定点数)</td>
</tr>
</tbody>
</table>
<p>在满足业务需求的情况下，尽可能选择占用磁盘空间小的数据类型。</p>
<pre><code class="language-sql">-- 年龄字段 ---不会出现负数, 而且人的年龄不会太大
   age tinyint unsigned
-- 分数 ---总分100分, 4代表整个数字长度，最多出现一位小数
   score double(4,1)
</code></pre>
<p>字符串类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR</td>
<td>0-255bytes</td>
<td>定长字符串(需要指定长度)，固定占用字符空间，性能略高</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-65535 bytes</td>
<td>变长字符串(需要指定最大长度)，动态判断字符空间，节约磁盘空间</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0-255 bytes</td>
<td>不超过255个字符的二进制数据</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0-65 535 bytes</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65 535 bytes</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0-16 777 215 bytes</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0-16 777 215 bytes</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>0-4 294 967 295 bytes</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0-4 294 967 295 bytes</td>
<td>极大文本数据</td>
</tr>
</tbody>
</table>
<p>日期时间类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小(byte)</th>
<th>范围</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01 至 9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59 至 838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901 至 2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<pre><code class="language-sql">-- 基础字段：id:主键；create_time 创建时间；update_time 修改时间；
create table emp
(
    id int unsigned primary key auto_increment comment 'ID，主键',
    username varchar(20) not null unique comment '用户名',
    password varchar(32) default '123456' comment '密码',
    name varchar(10) not null comment '姓名',
    gender tinyint unsigned not null comment '性别，1：男，2：女',
    phone char(11) not null unique comment '手机号',
    job tinyint unsigned comment '职位',
    salary int unsigned comment '薪资',
    entry_date date comment '入职日期',
    image varchar(255) comment '图像路径',
    create_time datetime comment '创建时间',
    update_time datetime comment '修改时间'
)comment '员工表';
</code></pre>
<h3 id="表操作-2"><strong>表操作</strong></h3>
<pre><code class="language-sql">-- 查询当前数据库所有表
show tables ;

-- 查询表结构
desc emp;

-- 查询建表语句
show create table emp;

-- 字段：添加字段
alter table emp add qq varchar(13) comment 'qq号码';

-- 修改字段类型
alter table emp modify qq varchar(15) comment 'qq号码';

-- 修改字段名
alter table emp change qq qq_number varchar(15) comment 'qq号码';

-- 删除字段
alter table emp drop column qq_number;

-- 修改表名
alter table emp rename to employee;

-- 删除表
drop table employee;
</code></pre>
<h1 id="dml"><strong>DML</strong></h1>
<p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。</p>
<h2 id="增加"><strong>增加</strong></h2>
<pre><code class="language-sql">-- DML : 数据操作语言
-- DML : 插入数据 - insert
-- 1. 为 emp 表的 username, password, name, gender, phone 字段插入值
insert into emp(username, password, name, gender, phone) values ('songjiang','12345678','宋江',1,'13300001111');

-- 2. 为 emp 表的 所有字段插入值
-- 方式一：
insert into emp(id, username, password, name, gender, phone, job, salary, entry_date, image, create_time, update_time)
values (null,'linchong','12345678','林冲',1,'13300001112',1,6000,'2020-01-01','1.jpg',now(),now());
-- 方式二：
insert into emp values (null,'likui','12345678','李逵',1,'13300001113',1,6000,'2020-01-01','1.jpg',now(),now());
-- 3. 批量为 emp 表的 username, password, name, gender, phone  字段插入数据
insert into emp(username, password, name, gender, phone) values
            ('ruanxiaoer','12345678','阮小二',1,'13300001114'),
            ('ruanxiaowu','12345678','阮小五',1,'13300001115');
</code></pre>
<h2 id="更新"><strong>更新</strong></h2>
<pre><code class="language-sql">-- DML : 更新数据 - update
-- 1. 将 emp 表的ID为1员工 用户名更新为 'zhangsan', 姓名name字段更新为 '张三'
update emp set username='zhangsan',name='张三' where id=1;

-- 2. 将 emp 表的所有员工的入职日期更新为 '2010-01-01'
update emp set entry_date='2010-01-01';
</code></pre>
<h2 id="删除"><strong>删除</strong></h2>
<ul>
<li>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。</li>
<li>DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。</li>
</ul>
<pre><code class="language-sql">-- DML : 删除数据 - delete
-- 1. 删除 emp 表中 ID为1的员工
delete from emp where id=1;

-- 2. 删除 emp 表中的所有员工
delete from emp;
</code></pre>
<h1 id="dql"><strong>DQL</strong></h1>
<p>DQL英文全称是Data Query Language(数据查询语言)，用来查询数据库表中的记录。<br>
查询关键字：SELECT</p>
<h2 id="基础查询"><strong>基础查询</strong></h2>
<pre><code class="language-sql">--  =================== DQL: 基本查询 ======================
-- 1. 查询指定字段 name,entry_date 并返回
select name,entry_date from emp;

-- 2. 查询返回所有字段
-- 方式一：推荐
select id, username, password, name, gender, phone, job, salary, entry_date, image, create_time, update_time from emp;
-- 方式二：不推荐
select * from emp;

-- 3. 查询所有员工的 name,entry_date, 并起别名(姓名、入职日期)
-- 起了别名展示出来的就是别名，可以不加引号，但别名中间有空格需要加引号
select name as 姓名,entry_date as 入职日期 from emp;
select name 姓名,entry_date 入职日期 from emp;

-- 4. 查询已有的员工关联了哪几种职位(不要重复)- distinct
select distinct job from emp;
</code></pre>
<h2 id="条件查询"><strong>条件查询</strong></h2>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;&gt; 或 !=</td>
<td>不等于</td>
</tr>
<tr>
<td>between ... and ...</td>
<td>在某个范围之内(含最小、最大值)</td>
</tr>
<tr>
<td>in(...)</td>
<td>在in之后的列表中的值，多选一</td>
</tr>
<tr>
<td>like 占位符</td>
<td>模糊匹配(_匹配单个字符, %匹配任意个字符)</td>
</tr>
<tr>
<td>is null</td>
<td>是null</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>and 或 &amp;&amp;</td>
<td>并且 (多个条件同时成立)</td>
</tr>
<tr>
<td>or 或||</td>
<td>或者 (多个条件任意一个成立)</td>
</tr>
<tr>
<td>not 或 !</td>
<td>非 , 不是</td>
</tr>
</tbody>
</table>
<pre><code class="language-sql">--  =================== DQL: 条件查询 ======================
-- 1. 查询 姓名 为 柴进 的员工
select * from emp where name='柴进';

-- 2. 查询 薪资小于等于5000 的员工信息
select * from emp where salary&lt;=5000;

-- 3. 查询 没有分配职位 的员工信息
select * from emp where job is null ;

-- 4. 查询 有职位 的员工信息
select * from emp where job is not null ;

-- 5. 查询 密码不等于 '123456' 的员工信息
select * from emp where password!='123456';

-- 6. 查询 入职日期 在 '2000-01-01' (包含) 到 '2010-01-01'(包含) 之间的员工信息
-- between 最小值 and 最大值
select * from emp where entry_date between '2000-01-01' and '2010-01-01';

-- 7. 查询 入职时间 在 '2000-01-01' (包含) 到 '2010-01-01'(包含) 之间 且 性别为女 的员工信息
select * from emp where (entry_date between '2000-01-01' and '2010-01-01') and gender=2;

-- 8. 查询 职位是 2 (讲师), 3 (学工主管), 4 (教研主管) 的员工信息
select * from emp where job in (2,3,4);

-- 9. 查询 姓名 为两个字的员工信息
select * from emp where name like '__';

-- 10. 查询 姓李 的员工信息
select * from emp where name like '李%';

-- 11. 查询 姓名中包含二 的员工信息
select * from emp where name like '%二%';
</code></pre>
<h2 id="分组聚合查询"><strong>分组聚合查询</strong></h2>
<p>聚合函数查询就是纵向查询，它是对一列的值进行计算，然后返回一个结果值。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>统计数量</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
</tbody>
</table>
<pre><code class="language-sql">--  =================== DQL: 分组查询 ======================
-- 聚合函数（所有聚合函数不参与null值的统计)

-- 1. 统计该企业员工数量
-- count(字段)
select count(id) from emp;
-- count(*)：推荐
select count(*) from emp;
-- count(常量)
-- 有数据的行标记一个1，最后统计1的总数
select count(1) from emp;
-- 2. 统计该企业员工的平均薪资
select avg(salary) from emp;

-- 3. 统计该企业员工的最低薪资
select min(salary) from emp;

-- 4. 统计该企业员工的最高薪资
select max(salary) from emp;

-- 5. 统计该企业每月要给员工发放的薪资总额(薪资之和)
select sum(salary) from emp;
</code></pre>
<p>where和haven的区别：</p>
<ul>
<li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li>
<li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li>
</ul>
<pre><code class="language-sql">-- 分组
-- 注意：分组之后select后的字段列表不能随便写，能写的一般是分组字段+聚合函数
-- 1. 根据性别分组 , 统计男性和女性员工的数量
select gender,count(*) from emp group by gender;

-- 2. 先查询入职时间在 '2015-01-01' (包含) 以前的员工 , 并对结果根据职位分组 , 获取员工数量大于等于2的职位
select job,count(*) from emp where entry_date&lt;='2015-01-01' group by job having count(*)&gt;=2;
</code></pre>
<h2 id="排序查询"><strong>排序查询</strong></h2>
<p>排序方式：</p>
<ul>
<li>ASC ：升序（默认值）</li>
<li>DESC：降序</li>
</ul>
<pre><code class="language-sql">--  =================== 排序查询 ======================
-- 1. 根据入职时间, 对员工进行升序排序（默认升序，asc可以不写）
select * from emp order by entry_date asc;

-- 2. 根据入职时间, 对员工进行降序排序
select * from emp order by entry_date desc;

-- 3. 根据 入职时间 对公司的员工进行 升序排序 ， 入职时间相同 , 再按照 更新时间 进行降序排序
select * from emp order by entry_date ,update_time desc;
</code></pre>
<h2 id="分页查询"><strong>分页查询</strong></h2>
<ol>
<li>起始索引从0开始。           计算公式 ：起始索引 = （查询页码 - 1）* 每页显示记录数</li>
<li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT</li>
<li>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit  条数</li>
</ol>
<pre><code class="language-sql">select  字段列表  from  表名  limit  起始索引, 查询记录数 ;
</code></pre>
<pre><code class="language-sql">--  =================== 分页查询 ======================
-- 1. 从起始索引0开始查询员工数据, 每页展示5条记录
select * from emp limit 0,5;
select * from emp limit 5;

-- 2. 查询 第1页 员工数据, 每页展示5条记录
select * from emp limit 0,5;

-- 3. 查询 第2页 员工数据, 每页展示5条记录
select * from emp limit 5,5;

-- 4. 查询 第3页 员工数据, 每页展示5条记录
select * from emp limit 10,5;
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#ddl"><strong>DDL</strong></a>
<ul>
<li><a href="#%E8%A1%A8%E6%93%8D%E4%BD%9C"><strong>表操作</strong></a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%A0%BC"><strong>创建表格</strong></a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><strong>数据类型</strong></a></li>
<li><a href="#%E8%A1%A8%E6%93%8D%E4%BD%9C-2"><strong>表操作</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#dml"><strong>DML</strong></a>
<ul>
<li><a href="#%E5%A2%9E%E5%8A%A0"><strong>增加</strong></a></li>
<li><a href="#%E6%9B%B4%E6%96%B0"><strong>更新</strong></a></li>
<li><a href="#%E5%88%A0%E9%99%A4"><strong>删除</strong></a></li>
</ul>
</li>
<li><a href="#dql"><strong>DQL</strong></a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2"><strong>基础查询</strong></a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><strong>条件查询</strong></a></li>
<li><a href="#%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2"><strong>分组聚合查询</strong></a></li>
<li><a href="#%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2"><strong>排序查询</strong></a></li>
<li><a href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><strong>分页查询</strong></a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://yyss1014.github.io/post/springboot/">
              <h3 class="post-title">
                SpringBoot
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://yyss1014.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
