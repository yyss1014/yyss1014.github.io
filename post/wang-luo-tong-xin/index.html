<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>网络通信 | WASD研究院</title>
<link rel="shortcut icon" href="https://yyss1014.github.io/favicon.ico?v=1751633121752">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://yyss1014.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="网络通信 | WASD研究院 - Atom Feed" href="https://yyss1014.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
网络通信三要素

IP

InetAddress


端口号
协议

通信协议
传输层的两个通讯协议




UDP通信

快速入门
多发多收


TCP

客户端开发
服务端的开发
多发多收
支持与多个客户端同时通信
综合案例

群聊
..." />
    <meta name="keywords" content="JavaSE" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://yyss1014.github.io">
  <img class="avatar" src="https://yyss1014.github.io/images/avatar.png?v=1751633121752" alt="">
  </a>
  <h1 class="site-title">
    WASD研究院
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/archives" class="menu">
          目录
        </a>
      
    
      
        <a href="/" class="menu">
          文章
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              网络通信
            </h2>
            <div class="post-info">
              <span>
                2025-04-18
              </span>
              <span>
                15 min read
              </span>
              
                <a href="https://yyss1014.github.io/tag/xcf3bLryi2/" class="post-tag">
                  # JavaSE
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p><ul class="markdownIt-TOC">
<li><a href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%89%E8%A6%81%E7%B4%A0"><strong>网络通信三要素</strong></a>
<ul>
<li><a href="#ip"><strong>IP</strong></a>
<ul>
<li><a href="#inetaddress"><strong>InetAddress</strong></a></li>
</ul>
</li>
<li><a href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><strong>端口号</strong></a></li>
<li><a href="#%E5%8D%8F%E8%AE%AE"><strong>协议</strong></a>
<ul>
<li><a href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><strong>通信协议</strong></a></li>
<li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE"><strong>传输层的两个通讯协议</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#udp%E9%80%9A%E4%BF%A1"><strong>UDP通信</strong></a>
<ul>
<li><a href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><strong>快速入门</strong></a></li>
<li><a href="#%E5%A4%9A%E5%8F%91%E5%A4%9A%E6%94%B6"><strong>多发多收</strong></a></li>
</ul>
</li>
<li><a href="#tcp"><strong>TCP</strong></a>
<ul>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91"><strong>客户端开发</strong></a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%BC%80%E5%8F%91"><strong>服务端的开发</strong></a></li>
<li><a href="#%E5%A4%9A%E5%8F%91%E5%A4%9A%E6%94%B6-2"><strong>多发多收</strong></a></li>
<li><a href="#%E6%94%AF%E6%8C%81%E4%B8%8E%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%8C%E6%97%B6%E9%80%9A%E4%BF%A1"><strong>支持与多个客户端同时通信</strong></a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><strong>综合案例</strong></a>
<ul>
<li><a href="#%E7%BE%A4%E8%81%8A"><strong>群聊</strong></a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88%E7%9A%84bs%E6%9E%B6%E6%9E%84"><strong>实现一个简易版的BS架构</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="网络通信三要素"><strong>网络通信三要素</strong></h1>
<h2 id="ip"><strong>IP</strong></h2>
<p>全称“互联网协议地址”，是分配给上网设备的唯一标志。</p>
<ul>
<li>IP地址有两种形式：IPv4、IPv6<br>
IPv4：4字节32位<br>
IPv6：共128位，分为8段表示，每段每四位编码成一个十六进制位表示，数之间用冒号分开。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250418160352.png" alt="" loading="lazy"></li>
<li>公网IP，内网IP<br>
公网IP：可以连接互联网的IP地址；内网IP：也叫局域网IP，只能组织机构内部使用。<br>
192.168.开头的就是常见的局域网地址，范围即为192.168.0.0--192.168.255.255，专门为组织机构内部使用。</li>
<li>特殊IP地址<br>
127.0.0.1、localhost：代表本机IP，只会寻找当前所在的主机。</li>
<li>IP常用命令<br>
ipconfig：查看本机IP地址。<br>
ping IP地址：检查网络是否连通。</li>
</ul>
<h3 id="inetaddress"><strong>InetAddress</strong></h3>
<p>代表IP地址。</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        //获取本机IP地址的对象
        InetAddress ip1=InetAddress.getLocalHost();
        System.out.println(ip1.getHostAddress());
        System.out.println(ip1.getHostName());

        //获取指定IP或者域名IP地址对象
        InetAddress ip2=InetAddress.getByName(&quot;www.baidu.com&quot;);
        System.out.println(ip2.getHostAddress());
        System.out.println(ip2.getHostName());

        //ping www.baidu.com
        System.out.println(ip2.isReachable(6000));
    }
}
</code></pre>
<h2 id="端口号"><strong>端口号</strong></h2>
<p>标记正在计算机设备上运行的应用程序的，被规定为一个16位的二进制，范围是0~65535。</p>
<ul>
<li>周知端口：0~1023，被预先定义的知名应用占用（如HTTP占用80，FTP占用21）</li>
<li>注册端口：1024~49151，分配给用户进程或某些应用程序。</li>
<li>动态端口：49152到65535，之所以称为动态端口，是因为它一般不固定分配某种进程，而是动态分配。<br>
注意：我们自己开发的程序一般选择使用注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。</li>
</ul>
<h2 id="协议"><strong>协议</strong></h2>
<h3 id="通信协议"><strong>通信协议</strong></h3>
<p>网络上通信的设备，事先规定的连接规则，以及传输数据的规则被称为网络通信协议。</p>
<ul>
<li>OSI网络参考模型：全球网络互联标准。</li>
<li>TCP/IP网络模型：事实上的国际标准。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250419161710.png" alt="" loading="lazy"></li>
</ul>
<h3 id="传输层的两个通讯协议"><strong>传输层的两个通讯协议</strong></h3>
<p>UDP：用户数据报协议；TCP：传输控制协议。<br>
UDP协议</p>
<ul>
<li>特点：无连接、不可靠通信。</li>
<li>不事先建立连接，数据按照包发，一包数据包含：自己的IP、程序端口，目的地IP、程序端口和数据（限制在64KB内）等。</li>
<li>发送方不管对方是否在线，数据中间丢失也不管，如果接收方收到数据也不返回确认，故是不可靠的。</li>
</ul>
<p>TCP协议</p>
<ul>
<li>特点：面向连接、可靠通信。</li>
<li>TCP的最终目的：要保证在不可靠的信道上实现可靠的传输。</li>
<li>TCP主要有三个步骤实现可靠传输：三次握手建立连接，传输数据进行确认，四次挥手断开连接。</li>
</ul>
<p><strong>三次握手建立可靠连接</strong><br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250419172153.png" alt="" loading="lazy"><br>
<strong>四次挥手断开连接</strong><br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250419172852.png" alt="" loading="lazy"></p>
<h1 id="udp通信"><strong>UDP通信</strong></h1>
<h2 id="快速入门"><strong>快速入门</strong></h2>
<pre><code class="language-java">public class Server {
    public static void main(String[] args) throws Exception {
        //创建一个服务器对象（接收数据的人）注册端口
        DatagramSocket socket=new DatagramSocket(6666);
        //创建一个数据包对象，用于接收数据的
        byte[] buffer=new byte[1024*64];//64KB.
        DatagramPacket packet=new DatagramPacket(buffer,buffer.length);
        //开始正式使用数据包来接收客户端发来的数据
        socket.receive(packet);
        //从字节数组中，把刚收到的数据直接打印出来
        //接收多少就倒出多少
        //获取本次数据包接收了多少数据
        int len=packet.getLength();
        String rs=new String(buffer,0,len);
        System.out.println(rs);

        System.out.println(packet.getAddress().getHostAddress());
        System.out.println(packet.getPort());
        socket.close();
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) throws Exception {
        //创建客户端对象（发数据的人）
        DatagramSocket socket=new DatagramSocket();//客户端端口
        //创建数据包对象封装要发出去的数据
        //public DatagramPacket(byte buf[], int offset, int length,
        //                          InetAddress address, int port)
        //参数一：封装要发出去的数据
        //参数二：发出去的数据大小
        //参数三：服务器的IP地址
        //参数四：服务端程序的端口
        byte[] bytes=&quot;我是快乐的客户端，我爱你abc&quot;.getBytes();
        DatagramPacket packet=new DatagramPacket(bytes,bytes.length
                , InetAddress.getLocalHost(),6666);
        //开始发送这个数据包的数据出去了
        socket.send(packet);
        System.out.println(&quot;客户端数据发送完毕&quot;);
        socket.close();//释放资源
    }
}
</code></pre>
<p>先启动服务端（接收数据），再启动客户端（发送数据）。</p>
<h2 id="多发多收"><strong>多发多收</strong></h2>
<pre><code class="language-java">public class Server {
    public static void main(String[] args) throws Exception {
        //创建一个服务器对象（接收数据的人）注册端口
        DatagramSocket socket=new DatagramSocket(6666);
        //创建一个数据包对象，用于接收数据的
        byte[] buffer=new byte[1024*64];//64KB.
        DatagramPacket packet=new DatagramPacket(buffer,buffer.length);
        //开始正式使用数据包来接收客户端发来的数据
        while (true) {
            socket.receive(packet);
            //从字节数组中，把刚收到的数据直接打印出来
            //接收多少就倒出多少
            //获取本次数据包接收了多少数据
            int len=packet.getLength();
            String rs=new String(buffer,0,len);
            System.out.println(rs);

            System.out.println(packet.getAddress().getHostAddress());
            System.out.println(packet.getPort());
            System.out.println(&quot;------------&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) throws Exception {
        //创建客户端对象（发数据的人）
        DatagramSocket socket=new DatagramSocket();
        //创建数据包对象封装要发出去的数据
        //public DatagramPacket(byte buf[], int offset, int length,
        //                          InetAddress address, int port)
        //参数一：封装要发出去的数据
        //参数二：发出去的数据大小
        //参数三：服务器的IP地址
        //参数四：服务端程序的端口
        Scanner sc=new Scanner(System.in);
        while (true) {
            System.out.println(&quot;请说：&quot;);
            String msg=sc.nextLine();
            //一旦发现用户输出的exit，退出客户端
            if(&quot;bye&quot;.equals(msg)){
                System.out.println(&quot;欢迎下次光临！&quot;);
                socket.close();
                break;
            }
            byte[] bytes=msg.getBytes();
            DatagramPacket packet=new DatagramPacket(bytes,bytes.length
                    , InetAddress.getLocalHost(),6666);
            //开始发送这个数据包的数据出去了
            socket.send(packet);
        }
    }
}
</code></pre>
<h1 id="tcp"><strong>TCP</strong></h1>
<h2 id="客户端开发"><strong>客户端开发</strong></h2>
<p>通过java.net包下的Socket类实现的。</p>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) throws Exception {
        //创建Socket对象，同时请求与服务端程序的连接
        Socket socket=new Socket(&quot;127.0.0.1&quot;, 8888);
        //从socket通信管道中得到一个字节输出流，用来发数据给服务端程序
        OutputStream os=socket.getOutputStream();
        //把低级的字节输出流包装成数据输出流
        DataOutputStream dos=new DataOutputStream(os);
        //开始写数据出去了
        dos.writeUTF(&quot;hello&quot;);
        dos.close();

        socket.close();//释放连接资源
    }
}
</code></pre>
<h2 id="服务端的开发"><strong>服务端的开发</strong></h2>
<p>服务端是通过java.net包下的ServerSocket类来实现的。</p>
<pre><code class="language-java">public class Server {
    public static void main(String[] args) throws Exception {
        System.out.println(&quot;Server starting...&quot;);
        //创建ServerSocket的对象，同时为服务端注册窗口
        ServerSocket severSocket = new ServerSocket(8888);
        //使用severSocket对象，调用一个accept方法，等待客户端的连接请求
        Socket socket = severSocket.accept();
        //从socket通道中得到一个字节输入流
        InputStream is = socket.getInputStream();
        //把原始的字节输入流包装成数据输入流
        DataInputStream dis = new DataInputStream(is);
        //使用数据输入流读取客户端发送过来的消息
        String rs = dis.readUTF();
        System.out.println(rs);
        //其实我们可以获取客户端的IP地址
        System.out.println(socket.getRemoteSocketAddress());

        dis.close();
        socket.close();

    }
}
</code></pre>
<h2 id="多发多收-2"><strong>多发多收</strong></h2>
<pre><code class="language-java">public class Server {
    public static void main(String[] args) throws Exception {
        System.out.println(&quot;Server starting...&quot;);
        //创建ServerSocket的对象，同时为服务端注册窗口
        ServerSocket severSocket = new ServerSocket(8888);
        //使用severSocket对象，调用一个accept方法，等待客户端的连接请求
        Socket socket = severSocket.accept();
        //从socket通道中得到一个字节输入流
        InputStream is = socket.getInputStream();
        //把原始的字节输入流包装成数据输入流
        DataInputStream dis = new DataInputStream(is);
        while (true) {
            try {
                //使用数据输入流读取客户端发送过来的消息
                String rs = dis.readUTF();
                System.out.println(rs);
            } catch (IOException e) {
                System.out.println(socket.getRemoteSocketAddress()+&quot;离线了！&quot;);
                //返回的是客户端的源IP和源端口
                dis.close();
                socket.close();
                break;
            }
        }

    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) throws Exception {
        //创建Socket对象，同时请求与服务端程序的连接
        Socket socket=new Socket(&quot;127.0.0.1&quot;, 8888);
        //从socket通信管道中得到一个字节输出流，用来发数据给服务端程序
        OutputStream os=socket.getOutputStream();
        //把低级的字节输出流包装成数据输出流
        DataOutputStream dos=new DataOutputStream(os);
        Scanner sc=new Scanner(System.in);
        //开始写数据出去了
        while (true) {
            System.out.println(&quot;请说：&quot;);
            String msg=sc.nextLine();

            //一旦用户输出了exit，就退出客户端程序
            if(&quot;bye&quot;.equals(msg)){
                System.out.println(&quot;欢迎你下次光临&quot;);
                dos.close();
                socket.close();
                break;
            }
            dos.writeUTF(msg);
            dos.flush();
        }
    }
}
</code></pre>
<h2 id="支持与多个客户端同时通信"><strong>支持与多个客户端同时通信</strong></h2>
<p>多线程实现：</p>
<pre><code class="language-java">public class Server {
    public static void main(String[] args) throws Exception {
        System.out.println(&quot;Server starting...&quot;);
        //创建ServerSocket的对象，同时为服务端注册窗口
        ServerSocket severSocket = new ServerSocket(8888);
        while (true) {
            //使用severSocket对象，调用一个accept方法，等待客户端的连接请求
            Socket socket = severSocket.accept();

            System.out.println(&quot;有人上线了：&quot; + socket.getRemoteSocketAddress());

            //把这个客户端对应的socket通信管道，交给一个独立的线程负责处理
            new ServerReaderThread(socket).start();
        }

    }
}
</code></pre>
<pre><code class="language-java">public class ServerReaderThread extends Thread {
    private Socket socket;
    public ServerReaderThread(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            InputStream is = socket.getInputStream();
            DataInputStream dis = new DataInputStream(is);
            while (true) {
                try {
                    String rs = dis.readUTF();
                    System.out.println(rs);
                } catch (IOException e) {
                    System.out.println(&quot;有人下线了：&quot;+socket.getRemoteSocketAddress());
                    dis.close();
                    socket.close();
                    break;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
</code></pre>
<h2 id="综合案例"><strong>综合案例</strong></h2>
<h3 id="群聊"><strong>群聊</strong></h3>
<pre><code class="language-java">public class Server {
    public static List&lt;Socket&gt; onlineSockets = new ArrayList&lt;Socket&gt;();
    public static void main(String[] args) throws Exception {
        System.out.println(&quot;Server starting...&quot;);
        //创建ServerSocket的对象，同时为服务端注册窗口
        ServerSocket severSocket = new ServerSocket(8888);
        while (true) {
            //使用severSocket对象，调用一个accept方法，等待客户端的连接请求
            Socket socket = severSocket.accept();
            onlineSockets.add(socket);
            System.out.println(&quot;有人上线了：&quot; + socket.getRemoteSocketAddress());

            //把这个客户端对应的socket通信管道，交给一个独立的线程负责处理
            new ServerReaderThread(socket).start();
        }

    }
}
</code></pre>
<pre><code class="language-java">public class ServerReaderThread extends Thread {
    private Socket socket;
    public ServerReaderThread(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            InputStream is = socket.getInputStream();
            DataInputStream dis = new DataInputStream(is);
            while (true) {
                try {
                    String msg = dis.readUTF();
                    System.out.println(msg);
                    //把消息分发给全部客户端
                    sendMsgToAll(msg);
                } catch (IOException e) {
                    System.out.println(&quot;有人下线了：&quot;+socket.getRemoteSocketAddress());
                    Server.onlineSockets.remove(socket);
                    dis.close();
                    socket.close();
                    break;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    private void sendMsgToAll(String msg) throws IOException {
        //发送给全部在线的管道接收
        for (Socket onlineSocket : Server.onlineSockets) {
            OutputStream os = onlineSocket.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeUTF(msg);
            dos.flush();

        }
    }
}
</code></pre>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) throws Exception {
        //创建Socket对象，同时请求与服务端程序的连接
        Socket socket=new Socket(&quot;127.0.0.1&quot;, 8888);

        //创建一个独立的线程，负责随机从socket中接收服务端发来的消息
        new ClientReaderThread( socket).start();

        //从socket通信管道中得到一个字节输出流，用来发数据给服务端程序
        OutputStream os=socket.getOutputStream();
        //把低级的字节输出流包装成数据输出流
        DataOutputStream dos=new DataOutputStream(os);
        Scanner sc=new Scanner(System.in);
        //开始写数据出去了
        while (true) {
            System.out.println(&quot;请说：&quot;);
            String msg=sc.nextLine();

            //一旦用户输出了exit，就退出客户端程序
            if(&quot;bye&quot;.equals(msg)){
                System.out.println(&quot;欢迎你下次光临&quot;);
                dos.close();
                socket.close();
                break;
            }
            dos.writeUTF(msg);
            dos.flush();
        }
    }
}
</code></pre>
<pre><code class="language-java">public class ClientReaderThread extends Thread {
    private Socket socket;
    public ClientReaderThread(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            InputStream is = socket.getInputStream();
            DataInputStream dis = new DataInputStream(is);
            while (true) {
                try {
                    String msg = dis.readUTF();
                    System.out.println(msg);
                } catch (IOException e) {
                    System.out.println(&quot;您下线了：&quot;+socket.getRemoteSocketAddress());//服务端口
                    dis.close();
                    socket.close();
                    break;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
</code></pre>
<h3 id="实现一个简易版的bs架构"><strong>实现一个简易版的BS架构</strong></h3>
<p>服务器必须给浏览器响应http协议规定的格式，否则浏览器不识别返回的数据。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250423165412.png" alt="" loading="lazy"></p>
<pre><code class="language-java">public class Server {
    public static void main(String[] args) throws Exception {
        System.out.println(&quot;Server starting...&quot;);
        //创建ServerSocket的对象，同时为服务端注册窗口
        ServerSocket severSocket = new ServerSocket(8080);
        while (true) {
            //使用severSocket对象，调用一个accept方法，等待客户端的连接请求
            Socket socket = severSocket.accept();
            System.out.println(&quot;有人上线了：&quot; + socket.getRemoteSocketAddress());

            //把这个客户端对应的socket通信管道，交给一个独立的线程负责处理
            new ServerReaderThread(socket).start();
        }

    }
}
</code></pre>
<pre><code class="language-java">public class ServerReaderThread extends Thread {
    private Socket socket;
    public ServerReaderThread(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        //立即响应一个网页内容：”hello“给浏览器展示
        try {
            OutputStream os=socket.getOutputStream();
            PrintStream ps=new PrintStream(os);
            ps.println(&quot;HTTP/1.1 200 OK&quot;);
            ps.println(&quot;Content-Type: text/html; charset=UTF-8&quot;);
            ps.println();//必须换行
            ps.println(&quot;&lt;div style='color:red;font-size:120px;text-align:center'&gt;Hello World&lt;/div&gt;&quot;);
            ps.close();


            socket.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
</code></pre>
<p>使用线程池进行优化：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250423170155.png" alt="" loading="lazy"></p>
<pre><code class="language-java">public class Server {
    public static void main(String[] args) throws Exception {
        System.out.println(&quot;Server starting...&quot;);
        //创建ServerSocket的对象，同时为服务端注册窗口
        ServerSocket severSocket = new ServerSocket(8080);

        //创建一个线程池，负责处理通信管道的任务
        ThreadPoolExecutor pool=new ThreadPoolExecutor(16*2,16*2,0, TimeUnit.SECONDS
                ,new ArrayBlockingQueue&lt;&gt;(8), Executors.defaultThreadFactory()
                ,new ThreadPoolExecutor.AbortPolicy());//新任务来了没法处理抛异常

        while (true) {
            //使用severSocket对象，调用一个accept方法，等待客户端的连接请求
            Socket socket = severSocket.accept();
            System.out.println(&quot;有人上线了：&quot; + socket.getRemoteSocketAddress());

            //把这个客户端对应的socket通信管道，交给一个独立的线程负责处理
            pool.execute(new ServerReaderThread(socket));
        }

    }
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%89%E8%A6%81%E7%B4%A0"><strong>网络通信三要素</strong></a>
<ul>
<li><a href="#ip"><strong>IP</strong></a>
<ul>
<li><a href="#inetaddress"><strong>InetAddress</strong></a></li>
</ul>
</li>
<li><a href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><strong>端口号</strong></a></li>
<li><a href="#%E5%8D%8F%E8%AE%AE"><strong>协议</strong></a>
<ul>
<li><a href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><strong>通信协议</strong></a></li>
<li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE"><strong>传输层的两个通讯协议</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#udp%E9%80%9A%E4%BF%A1"><strong>UDP通信</strong></a>
<ul>
<li><a href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><strong>快速入门</strong></a></li>
<li><a href="#%E5%A4%9A%E5%8F%91%E5%A4%9A%E6%94%B6"><strong>多发多收</strong></a></li>
</ul>
</li>
<li><a href="#tcp"><strong>TCP</strong></a>
<ul>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91"><strong>客户端开发</strong></a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%BC%80%E5%8F%91"><strong>服务端的开发</strong></a></li>
<li><a href="#%E5%A4%9A%E5%8F%91%E5%A4%9A%E6%94%B6-2"><strong>多发多收</strong></a></li>
<li><a href="#%E6%94%AF%E6%8C%81%E4%B8%8E%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%8C%E6%97%B6%E9%80%9A%E4%BF%A1"><strong>支持与多个客户端同时通信</strong></a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><strong>综合案例</strong></a>
<ul>
<li><a href="#%E7%BE%A4%E8%81%8A"><strong>群聊</strong></a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88%E7%9A%84bs%E6%9E%B6%E6%9E%84"><strong>实现一个简易版的BS架构</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://yyss1014.github.io/post/duo-xian-cheng/">
              <h3 class="post-title">
                多线程
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://yyss1014.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
