<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Maven | WASD研究院</title>
<link rel="shortcut icon" href="https://yyss1014.github.io/favicon.ico?v=1751633121752">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://yyss1014.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Maven | WASD研究院 - Atom Feed" href="https://yyss1014.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
概述

Maven模型
Maven仓库


Idea集成Maven项目

创建Maven项目

全局设置
创建项目


Maven坐标
导入Maven项目


依赖管理

排除依赖
生命周期


单元测试

单元测试
断言
常见注解
依赖..." />
    <meta name="keywords" content="JavaWeb" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://yyss1014.github.io">
  <img class="avatar" src="https://yyss1014.github.io/images/avatar.png?v=1751633121752" alt="">
  </a>
  <h1 class="site-title">
    WASD研究院
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/archives" class="menu">
          目录
        </a>
      
    
      
        <a href="/" class="menu">
          文章
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Maven
            </h2>
            <div class="post-info">
              <span>
                2025-05-18
              </span>
              <span>
                12 min read
              </span>
              
                <a href="https://yyss1014.github.io/tag/2ON39h6GJZ/" class="post-tag">
                  # JavaWeb
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p><ul class="markdownIt-TOC">
<li><a href="#%E6%A6%82%E8%BF%B0"><strong>概述</strong></a>
<ul>
<li><a href="#maven%E6%A8%A1%E5%9E%8B"><strong>Maven模型</strong></a></li>
<li><a href="#maven%E4%BB%93%E5%BA%93"><strong>Maven仓库</strong></a></li>
</ul>
</li>
<li><a href="#idea%E9%9B%86%E6%88%90maven%E9%A1%B9%E7%9B%AE"><strong>Idea集成Maven项目</strong></a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE"><strong>创建Maven项目</strong></a>
<ul>
<li><a href="#%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE"><strong>全局设置</strong></a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><strong>创建项目</strong></a></li>
</ul>
</li>
<li><a href="#maven%E5%9D%90%E6%A0%87"><strong>Maven坐标</strong></a></li>
<li><a href="#%E5%AF%BC%E5%85%A5maven%E9%A1%B9%E7%9B%AE"><strong>导入Maven项目</strong></a></li>
</ul>
</li>
<li><a href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><strong>依赖管理</strong></a>
<ul>
<li><a href="#%E6%8E%92%E9%99%A4%E4%BE%9D%E8%B5%96"><strong>排除依赖</strong></a></li>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><strong>生命周期</strong></a></li>
</ul>
</li>
<li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><strong>单元测试</strong></a>
<ul>
<li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-2"><strong>单元测试</strong></a></li>
<li><a href="#%E6%96%AD%E8%A8%80"><strong>断言</strong></a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><strong>常见注解</strong></a></li>
<li><a href="#%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4"><strong>依赖范围</strong></a></li>
<li><a href="#maven%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><strong>Maven常见问题</strong></a></li>
</ul>
</li>
</ul>
<br>
Maven 是一款用于管理和构建Java项目的工具，是Apache旗下的一个开源项目 。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250518213911.png" alt="" loading="lazy"></p>
<h1 id="概述"><strong>概述</strong></h1>
<p>Apache Maven是一个项目管理和构建工具，它基于项目对象模型(Project Object Model , 简称: POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。<br>
<a href="https://maven.apache.org/">Maven官网</a><br>
Maven的作用：</p>
<ol>
<li>方便的依赖管理</li>
<li>统一的项目结构</li>
<li>标准的项目构建流程</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250519191305.png" alt="" loading="lazy"></figure>
<h2 id="maven模型"><strong>Maven模型</strong></h2>
<p><strong>构建生命周期/阶段(Build lifecycle &amp; phases)</strong>：当我们需要编译，Maven提供了一个编译插件供我们使用；当我们需要打包，Maven就提供了一个打包插件供我们使用等。<br>
<strong>项目对象模型 (Project Object Model)</strong>：将我们自己的项目抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250519191951.png" alt="" loading="lazy"><br>
坐标，就是资源(jar包)的唯一标识，通过坐标可以定位到所需资源(jar包)位置。<br>
坐标的组成部分：</p>
<ul>
<li>groupId: 组织名</li>
<li>arfitactId: 模块名</li>
<li>Version: 版本号</li>
</ul>
<p><strong>依赖管理模型(Dependency)</strong>：使用坐标来描述当前项目依赖哪些第三方jar包。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250519192153.png" alt="" loading="lazy"><br>
之前我们项目中需要jar包时，直接就把jar包复制到项目下的lib目录，而现在我们只需要在pom.xml中配置依赖的配置文件即可。 而这个依赖对应的jar包其实就在我们本地电脑上的maven仓库中。</p>
<h2 id="maven仓库"><strong>Maven仓库</strong></h2>
<p>仓库：用于存储资源，管理各种jar包<br>
仓库的本质就是一个目录(文件夹)，这个目录被用来存储开发中所有依赖(就是jar包)和插件</p>
<p>Maven仓库分为：</p>
<ul>
<li>本地仓库：自己计算机上的一个目录(用来存储jar包)</li>
<li>中央仓库：由Maven团队维护的全球唯一的。仓库地址：https://repo1.maven.org/maven2/</li>
<li>远程仓库(私服)：一般由公司团队搭建的私有仓库</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250519192453.png" alt="" loading="lazy"><br>
当项目中使用坐标引入对应依赖jar包后，</p>
<ul>
<li>首先会查找本地仓库中是否有对应的jar包
<ul>
<li>如果有，则在项目直接引用</li>
<li>如果没有，则去中央仓库中下载对应的jar包到本地仓库</li>
</ul>
</li>
<li>如果还可以搭建远程仓库(私服)，将来jar包的查找顺序则变为： 本地仓库 --&gt; 远程仓库--&gt; 中央仓库</li>
</ul>
<h1 id="idea集成maven项目"><strong>Idea集成Maven项目</strong></h1>
<h2 id="创建maven项目"><strong>创建Maven项目</strong></h2>
<h3 id="全局设置"><strong>全局设置</strong></h3>
<ol>
<li>进入IDEA的欢迎页面<br>
选择 IDEA中 File  =&gt;  close project =&gt; Customize =&gt; All settings</li>
<li>打开 All settings , 选择 Build,Execution,Deployment  =&gt;  Build Tools  =&gt;  Maven<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250519200316.png" alt="" loading="lazy"></li>
<li>配置工程的编译版本为17<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250519200410.png" alt="" loading="lazy"><br>
这里所设置的maven的环境信息，并未指定任何一个project，此时设置的信息就属于全局配置信息。 以后，我们再创建project，默认就是使用我们全局配置的信息。</li>
</ol>
<h3 id="创建项目"><strong>创建项目</strong></h3>
<ol>
<li>创建一个空项目，命名为 web-project01<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250519200559.png" alt="" loading="lazy"></li>
<li>创建好项目之后，进入项目中，要设置JDK的版本号。选择小齿轮，选择 Project Structure<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250519200650.png" alt="" loading="lazy"></li>
<li>创建模块，选择Java语言，选择Maven。 填写模块的基本信息<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250519200719.png" alt="" loading="lazy"></li>
<li>在maven项目中，创建HelloWorld类，并运行<br>
Maven项目的目录结构:</li>
</ol>
<pre><code>maven-project01
        |---  src  (源代码目录和测试代码目录)
               |---  main (源代码目录)
                        |--- java (源代码java文件目录，在这里创建类)
                        |--- resources (源代码配置文件目录)
              |---  test (测试代码目录)
                        |--- java (测试代码java目录)
                        |--- resources (测试代码配置文件目录)
        |--- target (编译、打包生成文件存放目录)
</code></pre>
<h2 id="maven坐标"><strong>Maven坐标</strong></h2>
<p>Maven中的坐标是资源的唯一标识 , 通过该坐标可以唯一定位资源位置，使用坐标来定义项目或引入项目中需要的依赖。</p>
<p>Maven坐标主要组成：</p>
<ul>
<li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li>
<li>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</li>
<li>version：定义当前项目版本号
<ul>
<li>SNAPSHOT: 功能不稳定、尚处于开发中的版本，即快照版本</li>
<li>RELEASE: 功能趋于稳定、当前更新停止，可以用于发行的版本</li>
</ul>
</li>
</ul>
<h2 id="导入maven项目"><strong>导入Maven项目</strong></h2>
<p>首先把要导入的模块放在对应目录下。<br>
方式一：File -&gt; Project Structure -&gt; Modules -&gt; Import Module -&gt; 选择maven项目的pom.xml。<br>
方式二：Maven面板 -&gt; +（Add Maven Projects） -&gt; 选择maven项目的pom.xml。</p>
<h1 id="依赖管理"><strong>依赖管理</strong></h1>
<p>依赖：指当前项目运行所需要的jar包。一个项目中可以引入多个依赖。例如：在当前工程中，我们需要用到logback来记录日志，此时就可以在maven工程的pom.xml文件中，引入logback的依赖。</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;!-- 依赖 : spring-context --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;6.1.4&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>点击刷新按钮，引入最新加入的坐标。</p>
<ol>
<li>如果引入的依赖，在本地仓库中不存在，将会连接远程仓库 / 中央仓库，然后下载依赖（这个过程会比较耗时，耐心等待）</li>
<li>如果不知道依赖的坐标信息，可以到mvn的中央仓库（https://mvnrepository.com/）中搜索</li>
</ol>
<h2 id="排除依赖"><strong>排除依赖</strong></h2>
<p>指主动断开依赖的资源，被排除的资源无需指定版本。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;6.1.4&lt;/version&gt;

    &lt;!--排除依赖, 主动断开依赖的资源--&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
            &lt;artifactId&gt;micrometer-observation&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="生命周期"><strong>生命周期</strong></h2>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250521172825.png" alt="" loading="lazy"></figure>
<ul>
<li>clean：移除上一次构建生成的文件</li>
<li>compile：编译项目源代码</li>
<li>test：使用合适的单元测试框架运行测试(junit)</li>
<li>package：将编译后的文件打包，如：jar、war等</li>
<li>install：安装项目到本地仓库</li>
</ul>
<p>每套生命周期包含一些阶段（phase），同一套生命周期中阶段是有顺序的，后面的阶段依赖于前面的阶段。IDEA工具为了方便程序员使用maven生命周期，在右侧的maven工具栏中，已给出快速访问通道。<br>
也可以在命令行中执行生命周期，打开maven项目对应的磁盘目录：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250521173420.png" alt="" loading="lazy"></p>
<h1 id="单元测试"><strong>单元测试</strong></h1>
<p>测试：是一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。<br>
阶段划分：单元测试、集成测试、系统测试、验收测试。<br>
1). 单元测试</p>
<ul>
<li>介绍：对软件的基本组成单位进行测试，最小测试单位。</li>
<li>目的：检验软件基本组成单位的正确性。</li>
<li>测试人员：开发人员</li>
</ul>
<p>2). 集成测试</p>
<ul>
<li>介绍：将已分别通过测试的单元，按设计要求组合成系统或子系统，再进行的测试。</li>
<li>目的：检查单元之间的协作是否正确。</li>
<li>测试人员：开发人员</li>
</ul>
<p>3). 系统测试</p>
<ul>
<li>介绍：对已经集成好的软件系统进行彻底的测试。</li>
<li>目的：验证软件系统的正确性、性能是否满足指定的要求。</li>
<li>测试人员：测试人员</li>
</ul>
<p>4). 验收测试</p>
<ul>
<li>介绍：交付测试，是针对用户需求、业务流程进行的正式的测试。</li>
<li>目的：验证软件系统是否满足验收标准。</li>
<li>测试人员：客户/需求方</li>
</ul>
<p>测试方法：白盒测试、黑盒测试 及 灰盒测试。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250521194750.png" alt="" loading="lazy"><br>
1). 白盒测试<br>
清楚软件内部结构、代码逻辑。<br>
用于验证代码、逻辑正确性。</p>
<p>2). 黑盒测试<br>
不清楚软件内部结构、代码逻辑。<br>
用于验证软件的功能、兼容性、验收测试等方面。</p>
<p>3). 灰盒测试<br>
结合了白盒测试和黑盒测试的特点，既关注软件的内部结构又考虑外部表现（功能）。</p>
<h2 id="单元测试-2"><strong>单元测试</strong></h2>
<p>单元测试：就是针对最小的功能单元(方法)，编写测试代码对其正确性进行测试。<br>
JUnit：最流行的Java测试框架之一，提供了一些功能，方便程序进行单元测试（第三方公司提供）。</p>
<ol>
<li>测试代码与源代码分开，便于维护。</li>
<li>可根据需要进行自动化测试。</li>
<li>可自动分析测试结果，产出测试报告。</li>
</ol>
<ul>
<li>测试类的命名规范为：XxxxTest(生命周期中test阶段只有命名规范的类会执行)</li>
<li>测试方法的命名规定为：public void xxx(){...}</li>
</ul>
<h2 id="断言"><strong>断言</strong></h2>
<p>JUnit提供了一些辅助方法，用来帮我们确定被测试的方法是否按照预期的效果正常工作，这种方式称为断言。</p>
<pre><code class="language-java">public class UserServiceTest {
    @Test
    public void testGetAge() {
        UserService userService = new UserService();
        Integer age=userService.getAge(&quot;100000200010011011&quot;);
        System.out.println(age);
    }
    @Test
    public void testGetGender() {
        UserService userService = new UserService();
        String gender=userService.getGender(&quot;100000200010011011&quot;);
        Assertions.assertEquals(&quot;男&quot;,gender,&quot;性别获取错误&quot;);
    }

    @Test
    public void testGetGenderwithAssert() {
        UserService userService = new UserService();
        Assertions.assertThrows(IllegalArgumentException.class,()-&gt;{
            userService.getGender(null);
        });
    }
}
</code></pre>
<h2 id="常见注解"><strong>常见注解</strong></h2>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Test</td>
<td>测试类中的方法用它修饰才能成为测试方法，才能启动执行</td>
<td>单元测试</td>
</tr>
<tr>
<td>@BeforeEach</td>
<td>用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次。</td>
<td>初始化资源(准备工作)</td>
</tr>
<tr>
<td>@AfterEach</td>
<td>用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次。</td>
<td>释放资源(清理工作)</td>
</tr>
<tr>
<td>@BeforeAll</td>
<td>用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次。</td>
<td>初始化资源(准备工作)</td>
</tr>
<tr>
<td>@AfterAll</td>
<td>用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次。</td>
<td>释放资源(清理工作)</td>
</tr>
<tr>
<td>@ParameterizedTest</td>
<td>参数化测试的注解 (可以让单个测试运行多次，每次运行时仅参数不同)</td>
<td>用了该注解，就不需要@Test注解了</td>
</tr>
<tr>
<td>@ValueSource</td>
<td>参数化测试的参数来源，赋予测试方法参数</td>
<td>与参数化测试注解配合使用</td>
</tr>
<tr>
<td>@DisplayName</td>
<td>指定测试类、测试方法显示的名称</td>
<td>（默认为类名、方法名）</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">@DisplayName(&quot;用户信息测试类&quot;)
public class UserServiceTest {
    @DisplayName(&quot;测试用户性别&quot;)
    @ParameterizedTest
    @ValueSource(strings = {&quot;100000200010011011&quot;,&quot;100000200010011031&quot;,&quot;100000200010011051&quot;})
    public void testGetGender2(String idCard) {
        UserService userService = new UserService();
        String gender=userService.getGender(idCard);
        Assertions.assertEquals(&quot;男&quot;,gender,&quot;性别获取错误&quot;);
    }
}
</code></pre>
<p>企业开发规范：编写测试方法时，要尽可能的覆盖业务方法中所有可能的情况（尤其是边界值）。</p>
<h2 id="依赖范围"><strong>依赖范围</strong></h2>
<p>依赖的jar包，默认情况下，可以在任何地方使用。在maven中，如果希望限制依赖的使用范围，可以通过 <scope>…</scope> 设置其作用范围。</p>
<table>
<thead>
<tr>
<th>scope值</th>
<th>主程序</th>
<th>测试程序</th>
<th>打包（运行）</th>
<th>范例</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile（默认）</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>log4j</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>junit</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>jdbc驱动</td>
</tr>
</tbody>
</table>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
            &lt;version&gt;5.9.1&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="maven常见问题"><strong>Maven常见问题</strong></h2>
<p>问题现象：Maven项目中添加的依赖，未正确下载，造成右侧Maven面板中的依赖报红，再次reload重新加载也不会再下载。<br>
产生原因：由于网络原因，依赖没有下载完整导致的，在maven仓库中生成了xxx.lastUpdated文件，该文件不删除，不会再重新下载。<br>
解决方案：</p>
<ol>
<li>根据maven依赖的坐标，找到仓库中对应的 xxx.lastUpdated 文件，删除，删除之后重新加载项目即可。</li>
<li>cmd窗口通过命令 (del /s *.lastUpdated) 批量递归删除指定目录下的 xxx.lastUpdated 文件，删除之后重新加载项目即可。</li>
<li>重新加载依赖，依赖下载了之后，maven面板可能还会报红，此时可以关闭IDEA，重新打开IDEA加载此项目即可。</li>
</ol>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E6%A6%82%E8%BF%B0"><strong>概述</strong></a>
<ul>
<li><a href="#maven%E6%A8%A1%E5%9E%8B"><strong>Maven模型</strong></a></li>
<li><a href="#maven%E4%BB%93%E5%BA%93"><strong>Maven仓库</strong></a></li>
</ul>
</li>
<li><a href="#idea%E9%9B%86%E6%88%90maven%E9%A1%B9%E7%9B%AE"><strong>Idea集成Maven项目</strong></a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE"><strong>创建Maven项目</strong></a>
<ul>
<li><a href="#%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE"><strong>全局设置</strong></a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><strong>创建项目</strong></a></li>
</ul>
</li>
<li><a href="#maven%E5%9D%90%E6%A0%87"><strong>Maven坐标</strong></a></li>
<li><a href="#%E5%AF%BC%E5%85%A5maven%E9%A1%B9%E7%9B%AE"><strong>导入Maven项目</strong></a></li>
</ul>
</li>
<li><a href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><strong>依赖管理</strong></a>
<ul>
<li><a href="#%E6%8E%92%E9%99%A4%E4%BE%9D%E8%B5%96"><strong>排除依赖</strong></a></li>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><strong>生命周期</strong></a></li>
</ul>
</li>
<li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><strong>单元测试</strong></a>
<ul>
<li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-2"><strong>单元测试</strong></a></li>
<li><a href="#%E6%96%AD%E8%A8%80"><strong>断言</strong></a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><strong>常见注解</strong></a></li>
<li><a href="#%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4"><strong>依赖范围</strong></a></li>
<li><a href="#maven%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><strong>Maven常见问题</strong></a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://yyss1014.github.io/post/vue/">
              <h3 class="post-title">
                Vue+Ajax
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://yyss1014.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
