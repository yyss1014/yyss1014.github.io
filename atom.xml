<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yyss1014.github.io</id>
    <title>WASD研究院</title>
    <updated>2025-07-04T12:45:23.887Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yyss1014.github.io"/>
    <link rel="self" href="https://yyss1014.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://yyss1014.github.io/images/avatar.png</logo>
    <icon>https://yyss1014.github.io/favicon.ico</icon>
    <rights>All rights reserved 2025, WASD研究院</rights>
    <entry>
        <title type="html"><![CDATA[Maven高级]]></title>
        <id>https://yyss1014.github.io/post/maven-gao-ji/</id>
        <link href="https://yyss1014.github.io/post/maven-gao-ji/">
        </link>
        <updated>2025-07-04T06:39:09.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%88%86%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91"><strong>分模块设计与开发</strong></a>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D"><strong>介绍</strong></a></li>
<li><a href="#%E6%90%9C%E7%B4%A2"><strong>搜索</strong></a></li>
<li><a href="#%E5%AE%9E%E8%B7%B5"><strong>实践</strong></a>
<ul>
<li><a href="#%E5%88%86%E6%9E%90"><strong>分析</strong></a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0"><strong>实现</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%81%9A%E5%90%88"><strong>继承与聚合</strong></a>
<ul>
<li><a href="#%E7%BB%A7%E6%89%BF"><strong>继承</strong></a>
<ul>
<li><a href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><strong>继承关系</strong></a></li>
<li><a href="#%E7%89%88%E6%9C%AC%E9%94%81%E5%AE%9A"><strong>版本锁定</strong></a></li>
</ul>
</li>
<li><a href="#%E8%81%9A%E5%90%88"><strong>聚合</strong></a></li>
<li><a href="#%E5%AF%B9%E6%AF%94"><strong>对比</strong></a></li>
</ul>
</li>
<li><a href="#%E7%A7%81%E6%9C%8D"><strong>私服</strong></a>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D-2"><strong>介绍</strong></a></li>
<li><a href="#%E8%B5%84%E6%BA%90%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD"><strong>资源上传和下载</strong></a></li>
</ul>
</li>
</ul>
</p>
<h1 id="分模块设计与开发"><strong>分模块设计与开发</strong></h1>
<h2 id="介绍"><strong>介绍</strong></h2>
<p>所谓分模块设计，顾名思义指的就是我们在设计一个 Java 项目的时候，将一个 Java 项目拆分成多个模块进行开发。</p>
<p>1). 未分模块设计的问题<br>
如果项目不分模块，也就意味着所有的业务代码是不是都写在这一个 Java 项目当中。随着这个项目的业务扩张，项目当中的业务功能可能会越来越多。<br>
2). 分模块设计<br>
分模块设计我们在进行项目设计阶段，就可以将一个大的项目拆分成若干个模块，每一个模块都是独立的。</p>
<h2 id="搜索"><strong>搜索</strong></h2>
<ol>
<li>策略一：按照功能模块拆分，比如：公共组件、商品模块、搜索模块、购物车模块、订单模块等。</li>
<li>策略二：按层拆分，比如：公共组件、实体类、控制层、业务层、数据访问层。</li>
<li>策略三：按照功能模块 + 层拆分。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704144416.png" alt="" loading="lazy"></figure>
<h2 id="实践"><strong>实践</strong></h2>
<h3 id="分析"><strong>分析</strong></h3>
<p>我们可以看到在这个项目当中，除了我们所开发的部门管理以及员工管理、登录认证等相关业务功能以外，我们是不是也定义了一些实体类，也就是pojo包下存放的一些类，像分页结果的封装类PageBean、 统一响应结果Result，我们还定义了一些通用的工具类，像Jwts、阿里云OSS操作的工具类等等。</p>
<ul>
<li>将pojo包下的实体类，抽取到一个maven模块中 tlias-pojo</li>
<li>将utils包下的工具类，抽取到一个maven模块中 tlias-utils</li>
<li>其他的业务代码，放在tlias-web-management这个模块中，在该模块中需要用到实体类pojo、工具类utils，直接引入对应的依赖即可。</li>
</ul>
<h3 id="实现"><strong>实现</strong></h3>
<ol>
<li>创建maven模块 tlias-pojo，存放实体类<br>
A. 创建一个正常的Maven模块，模块名 tlias-pojo<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704150525.png" alt="" loading="lazy"><br>
B. 然后在tlias-pojo中创建一个包 com.itheima.pojo (和原来案例项目中的pojo包名一致)<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704151347.png" alt="" loading="lazy"><br>
C. 将原来案例项目 tlias-web-management 中的pojo包下的实体类，复制到 tlias-pojo 模块中<br>
D. 在 tlias-pojo 模块的pom.xml文件中引入依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.38&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>E. 删除原有案例项目 tlias-web-management 的pojo包【直接删除不要犹豫，我们已经将该模块拆分出去了】，然后在pom.xml中引入 tlias-pojo的依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;com.ys&lt;/groupId&gt;
            &lt;artifactId&gt;tlias-pojo&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>然后在 tlias-pojo生命周期中双击install导入到本地仓库。<br>
2. 创建Maven模块 tlias-utils，存放相关工具类<br>
A. 创建一个正常的Maven模块，模块名 tlias-utils，形式同上。<br>
B. 然后在 tlias-utils 中创建一个包 com.itheima.utils (和原来案例项目中的utils包名一致)<br>
C. 将原来案例项目 tlias-web-management 中的util包下的实体类，复制到 tlias-utils 模块中<br>
D. 在 tlias-utils 模块的 pom.xml 文件中引入依赖。</p>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;!--阿里云OSS--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
            &lt;version&gt;3.17.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
            &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
            &lt;version&gt;2.3.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.activation&lt;/groupId&gt;
            &lt;artifactId&gt;activation&lt;/artifactId&gt;
            &lt;version&gt;1.1.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- no more than 2.3.3--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
            &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
            &lt;version&gt;2.3.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--阿里云OSS--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
            &lt;version&gt;3.17.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
            &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
            &lt;version&gt;2.3.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.activation&lt;/groupId&gt;
            &lt;artifactId&gt;activation&lt;/artifactId&gt;
            &lt;version&gt;1.1.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- no more than 2.3.3--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
            &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
            &lt;version&gt;2.3.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.38&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- JWT依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
            &lt;version&gt;0.9.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>E. 删除原有案例项目 tlias-web-management 的util包【直接删除不要犹豫，我们已经将该模块拆分出去了】，然后在pom.xml中引入 tlias-utils 的依赖。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.itheima&lt;/groupId&gt;
    &lt;artifactId&gt;tlias-utils&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h1 id="继承与聚合"><strong>继承与聚合</strong></h1>
<h2 id="继承"><strong>继承</strong></h2>
<p>我们可以再创建一个父工程 tlias-parent ，然后让上述的三个模块 tlias-pojo、tlias-utils、tlias-web-management 都来继承这个父工程 。 然后再将各个模块中都共有的依赖，都提取到父工程 tlias-parent中进行配置，只要子工程继承了父工程，依赖它也会继承下来，这样就无需在各个子工程中进行配置了。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704163729.png" alt="" loading="lazy"></p>
<ul>
<li>概念：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</li>
<li>作用：简化依赖配置、统一管理依赖</li>
<li>实现：</li>
</ul>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;...&lt;/groupId&gt;
    &lt;artifactId&gt;...&lt;/artifactId&gt;
    &lt;version&gt;...&lt;/version&gt;
    &lt;relativePath&gt;....&lt;/relativePath&gt;
&lt;/parent&gt;
</code></pre>
<h3 id="继承关系"><strong>继承关系</strong></h3>
<p>我们当前的项目 tlias-web-management，还稍微有一点特殊，因为是一个springboot项目，而所有的springboot项目都有一个统一的父工程，就是 spring-boot-starter-parent。 与java语言类似，Maven不支持多继承，一个maven项目只能继承一个父工程，如果继承了spring-boot-starter-parent，就没法继承我们自己定义的父工程 tlias-parent了。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704165154.png" alt="" loading="lazy"><br>
1). 创建maven模块 tlias-parent ，该工程为父工程，设置打包方式pom(默认jar)。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704165453.png" alt="" loading="lazy"></p>
<pre><code class="language-xml">    &lt;groupId&gt;com.ys&lt;/groupId&gt;
    &lt;artifactId&gt;tlias-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
</code></pre>
<p>父工程tlias-parent的 pom.xml 文件配置如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;!--父工程pom.xml的相对路径--&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.ys&lt;/groupId&gt;
    &lt;artifactId&gt;tlias-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<p>2). 在子工程（tlias-pojo、tlias-utils、tlias-web-management）的pom.xml文件中，配置继承关系。</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;com.itheima&lt;/groupId&gt;
    &lt;artifactId&gt;tlias-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;relativePath&gt;../tlias-parent/pom.xml&lt;/relativePath&gt;
&lt;/parent&gt;

&lt;artifactId&gt;tlias-utils&lt;/artifactId&gt;
&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
</code></pre>
<p>这里是以 tlias-utils 为例，指定了其父工程。其他的模块，都是相同的配置方式。</p>
<ul>
<li>在子工程中，配置了继承关系之后，坐标中的groupId是可以省略的，因为会自动继承父工程的 。</li>
<li>relativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库/远程仓库查找该工程）。</li>
<li>../ 代表的上一级目录</li>
</ul>
<p>3). 在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;!--父工程pom.xml的相对路径--&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.ys&lt;/groupId&gt;
    &lt;artifactId&gt;tlias-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.38&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="版本锁定"><strong>版本锁定</strong></h3>
<p>如果项目中各个模块中都公共的这部分依赖，我们可以直接定义在父工程中，从而简化子工程的配置。 然而在项目开发中，还有一部分依赖，并不是各个模块都共有的，可能只是其中的一小部分模块中使用到了这个依赖。</p>
<p>比如：在tlias-web-management、tlias-web-system、tlias-web-report这三个子工程中，都使用到了jwt的依赖。 但是 tlias-pojo、tlias-utils中并不需要这个依赖，那此时，这个依赖，我们不会直接配置在父工程 tlias-parent中，而是哪个模块需要，就在哪个模块中配置。</p>
<p>而由于是一个项目中的多个模块，那多个模块中，我们要使用的同一个依赖的版本要一致，这样便于项目依赖的统一管理。比如：这个jwt依赖，我们都使用的是 0.9.1 这个版本。<br>
那假如说，我们项目要升级，要使用到jwt最新版本 0.9.2 中的一个新功能，那此时需要将依赖的版本升级到0.9.2，那此时该怎么做呢 ？<br>
第一步：去找当前项目中所有的模块的pom.xml配置文件，看哪些模块用到了jwt的依赖。<br>
第二步：找到这个依赖之后，将其版本version，更换为 0.9.2。<br>
问题：如果项目拆分的模块比较多，每一次更换版本，我们都得找到这个项目中的每一个模块，一个一个的更改。 很容易就会出现，遗漏掉一个模块，忘记更换版本的情况。<br>
父工程：</p>
<pre><code class="language-xml">&lt;!--统一管理依赖的版本--&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!--阿里云OSS--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
                &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
                &lt;version&gt;3.17.4&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
                &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
                &lt;version&gt;2.3.1&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;javax.activation&lt;/groupId&gt;
                &lt;artifactId&gt;activation&lt;/artifactId&gt;
                &lt;version&gt;1.1.1&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- no more than 2.3.3--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
                &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
                &lt;version&gt;2.3.3&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- JWT依赖--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
                &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
                &lt;version&gt;0.9.1&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<p>子工程此时就无需指定版本号了。<br>
我们也可以通过自定义属性及属性引用的形式，在父工程中将依赖的版本号进行集中管理维护。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704173027.png" alt="" loading="lazy"><br>
具体语法为：<br>
1). 自定义属性</p>
<pre><code class="language-xml">&lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;!--自定义属性--&gt;
        &lt;lombok.version&gt;1.18.38&lt;/lombok.version&gt;
        &lt;spring.boot.starter.version&gt;3.4.6&lt;/spring.boot.starter.version&gt;
        &lt;aliyun.sdk.version&gt;3.17.4&lt;/aliyun.sdk.version&gt;
        &lt;jaxb.api.version&gt;2.3.1&lt;/jaxb.api.version&gt;
        &lt;activation.version&gt;1.1.1&lt;/activation.version&gt;
        &lt;jaxb.runtime&gt;2.3.3&lt;/jaxb.runtime&gt;
        &lt;jjwt.version&gt;0.9.1&lt;/jjwt.version&gt;
    &lt;/properties&gt;
</code></pre>
<p>2). 引用属性</p>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;${lombok.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;${spring.boot.starter.version}&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;!--统一管理依赖的版本--&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!--阿里云OSS--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
                &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
                &lt;version&gt;${aliyun.sdk.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
                &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
                &lt;version&gt;${jaxb.api.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;javax.activation&lt;/groupId&gt;
                &lt;artifactId&gt;activation&lt;/artifactId&gt;
                &lt;version&gt;${activation.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- no more than 2.3.3--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
                &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
                &lt;version&gt;${jaxb.runtime}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- JWT依赖--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
                &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
                &lt;version&gt;${jjwt.version}&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<p>接下来，我们就可以在父工程中，将所有的版本号，都集中管理维护起来。版本集中管理之后，我们要想修改依赖的版本，就只需要在父工程中自定义属性的位置，修改对应的属性值即可。</p>
<h2 id="聚合"><strong>聚合</strong></h2>
<p>tlias-web-management 模块的父工程是 tlias-parent，该模块又依赖了 tlias-pojo、tlias-utils 模块。 那此时，我们要想将 tlias-web-management 模块打包，是比较繁琐的。因为在进行项目打包时，maven会从本地仓库中来查找 tlias-parent 父工程，以及它所依赖的模块 tlias-pojo、tlias-utils，而本地仓库目前是没有这几个依赖的。<br>
所以，我们再打包tlias-web-management 模块前，需要将 tlias-parent、tlias-pojo、tlias-utils 分别执行install生命周期安装到maven的本地仓库，然后再针对于 tlias-web-management 模块执行package进行打包操作。</p>
<ul>
<li>聚合：将多个模块组织成一个整体，同时进行项目的构建。</li>
<li>聚合工程：一个不具有业务功能的“空”工程（有且仅有一个pom文件） 【PS：一般来说，继承关系中的父工程与聚合关系中的聚合工程是同一个】</li>
<li>作用：快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）</li>
</ul>
<p>在maven中，我们可以在聚合工程中通过 <moudules> 设置当前聚合工程所包含的子模块的名称。我们可以在 tlias-parent中，添加如下配置，来指定当前聚合工程，需要聚合的模块：</p>
<pre><code class="language-xml">&lt;modules&gt;
        &lt;module&gt;../tlias-pojo&lt;/module&gt;
        &lt;module&gt;../tlias-utils&lt;/module&gt;
        &lt;module&gt;../tlias-web-management&lt;/module&gt;
    &lt;/modules&gt;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704175607.png" alt="" loading="lazy"><br>
那 tlias-parent 中所聚合的其他模块全部都会执行 package 指令，这就是通过聚合实现项目的一键构建（一键清理clean、一键编译compile、一键测试test、一键打包package、一键安装install等）。</p>
<h2 id="对比"><strong>对比</strong></h2>
<ul>
<li>作用
<ul>
<li>聚合用于快速构建项目</li>
<li>继承用于简化依赖配置、统一管理依赖</li>
</ul>
</li>
<li>相同点：
<ul>
<li>聚合与继承的pom.xml文件打包方式均为pom，通常将两种关系制作到同一个pom文件中</li>
<li>聚合与继承均属于设计型模块，并无实际的模块内容</li>
</ul>
</li>
<li>不同点：
<ul>
<li>聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些</li>
<li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li>
</ul>
</li>
</ul>
<h1 id="私服"><strong>私服</strong></h1>
<h2 id="介绍-2"><strong>介绍</strong></h2>
<p>假设现在有两个团队，A 和 B。 A 开发了一个模块 tlias-utils，模块开发完毕之后，将模块打成jar包，并安装到了A的本地仓库。<br>
那此时，该公司的B团队开发项目时，要想使用 tlias-utils 中提供的工具类，该怎么办呢？ 对于maven项目来说，是不是在pom.xml文件中引入 tlias-utils的坐标就可以了呢？查找顺序为：<br>
1). 本地仓库：本地仓库中是没有这个依赖jar包的。<br>
2). 远程中央仓库：由于该模块时自己公司开发的，远程仓库中也没有这个依赖。<br>
那此时，maven的私服就出场了，私服其实就是架设在公司局域网内部的一台服务器，就是一种特殊的远程仓库。<br>
有了私服之后，各个团队就可以直接来连接私服了。 A 连接上私服之后，他就可以把jar包直接上传到私服当中。我公司自己内部搭建的服务器，我是不是有权限操作呀，把jar包上传到私服之后，我让 B 团队的所有开发人员也连接同一台私服。连接上这一台私服之后，他就会根据坐标的信息，直接从私服当中将对应的jar包下载到自己的本地仓库，这样就可以使用到依赖当中所提供的一些工具类了。这样我们就可以通过私服来完成资源的共享。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704193001.png" alt="" loading="lazy"></p>
<ul>
<li>私服：是一种特殊的远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题。</li>
<li>依赖查找顺序：
<ul>
<li>本地仓库</li>
<li>私服仓库</li>
<li>中央仓库</li>
</ul>
</li>
<li>注意事项：私服在企业项目开发中，一个项目/公司，只需要一台即可（无需我们自己搭建，会使用即可）。</li>
</ul>
<h2 id="资源上传和下载"><strong>资源上传和下载</strong></h2>
<p>资源上传与下载，我们需要做三步配置，执行一条指令。</p>
<ul>
<li>第一步配置：在maven的配置文件中配置访问私服的用户名、密码。</li>
<li>第二步配置：在maven的配置文件中配置连接私服的地址(url地址)。</li>
<li>第三步配置：在项目的pom.xml文件中配置上传资源的位置(url地址)。</li>
<li>配置好了上述三步之后，要上传资源到私服仓库，就执行执行maven生命周期：deploy。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704193158.png" alt="" loading="lazy"><br>
私服仓库说明：</li>
<li>RELEASE：存储自己开发的RELEASE发布版本的资源。</li>
<li>SNAPSHOT：存储自己开发的SNAPSHOT发布版本的资源。</li>
<li>Central：存储的是从中央仓库下载下来的依赖。</li>
</ul>
<p>私服是课程提供的资料，已经搭建好了。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704203110.png" alt="" loading="lazy"></p>
<ol>
<li>设置私服的访问用户名/密码（在自己maven安装目录下的conf/settings.xml中的servers中配置）</li>
</ol>
<pre><code class="language-xml">&lt;server&gt;
    &lt;id&gt;maven-releases&lt;/id&gt;
    &lt;username&gt;admin&lt;/username&gt;
    &lt;password&gt;admin&lt;/password&gt;
&lt;/server&gt;
    
&lt;server&gt;
    &lt;id&gt;maven-snapshots&lt;/id&gt;
    &lt;username&gt;admin&lt;/username&gt;
    &lt;password&gt;admin&lt;/password&gt;
&lt;/server&gt;
</code></pre>
<ol start="2">
<li>设置私服依赖下载的仓库组地址（在自己maven安装目录下的conf/settings.xml中的mirrors中配置）</li>
</ol>
<pre><code class="language-xml">&lt;mirror&gt;
    &lt;id&gt;maven-public&lt;/id&gt;
    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
    &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt;
&lt;/mirror&gt;
</code></pre>
<ol start="3">
<li>设置私服依赖下载的仓库组地址（在自己maven安装目录下的conf/settings.xml中的profiles中配置）</li>
</ol>
<pre><code class="language-xml">&lt;profile&gt;
    &lt;id&gt;allow-snapshots&lt;/id&gt;
    &lt;activation&gt;
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
    &lt;/activation&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;maven-public&lt;/id&gt;
            &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt;
            &lt;releases&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;/releases&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
&lt;/profile&gt;
</code></pre>
<ol start="4">
<li>IDEA的maven工程的pom文件中配置上传（发布）地址(直接在tlias-parent中配置发布地址)</li>
</ol>
<pre><code class="language-xml">&lt;distributionManagement&gt;
    &lt;!-- release版本的发布地址 --&gt;
    &lt;repository&gt;
        &lt;id&gt;maven-releases&lt;/id&gt;
        &lt;url&gt;http://localhost:8081/repository/maven-releases/&lt;/url&gt;
    &lt;/repository&gt;
    &lt;!-- snapshot版本的发布地址 --&gt;
    &lt;snapshotRepository&gt;
        &lt;id&gt;maven-snapshots&lt;/id&gt;
        &lt;url&gt;http://localhost:8081/repository/maven-snapshots/&lt;/url&gt;
    &lt;/snapshotRepository&gt;
&lt;/distributionManagement&gt;
</code></pre>
<p>配置完成之后，我们就可以在tlias-parent中执行deploy生命周期，将项目发布到私服仓库中。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704204310.png" alt="" loading="lazy"><br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704204500.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot原理]]></title>
        <id>https://yyss1014.github.io/post/springboot-yuan-li/</id>
        <link href="https://yyss1014.github.io/post/springboot-yuan-li/">
        </link>
        <updated>2025-07-03T08:55:17.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7"><strong>配置优先级</strong></a></li>
<li><a href="#bean%E7%AE%A1%E7%90%86"><strong>Bean管理</strong></a>
<ul>
<li><a href="#bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><strong>Bean的作用域</strong></a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%96%B9bean"><strong>第三方Bean</strong></a></li>
</ul>
</li>
<li><a href="#springboot%E5%8E%9F%E7%90%86"><strong>SpringBoot原理</strong></a>
<ul>
<li><a href="#%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96"><strong>起步依赖</strong></a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><strong>自动配置</strong></a>
<ul>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><strong>实现方案</strong></a></li>
<li><a href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><strong>原理分析</strong></a></li>
<li><a href="#conditional"><strong>@Conditional</strong></a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89starter"><strong>自定义starter</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="配置优先级"><strong>配置优先级</strong></h1>
<p>在我们前面的课程当中，我们已经讲解了SpringBoot项目当中支持的三类配置文件：</p>
<ul>
<li>application.properties</li>
<li>application.yml</li>
<li>application.yaml</li>
</ul>
<p>在SpringBoot项目当中，我们要想配置一个属性，可以通过这三种方式当中的任意一种来配置都可以，那么如果项目中同时存在这三种配置文件，且都配置了同一个属性，如：Tomcat端口号，到底哪一份配置文件生效呢？<br>
application.properties：</p>
<pre><code class="language-properties">server.port=8081
</code></pre>
<p>application.yml：</p>
<pre><code class="language-yml">server:
   port: 8082
</code></pre>
<p>application.yaml：</p>
<pre><code class="language-yaml">server:
   port: 8082
</code></pre>
<p>配置文件优先级排名（从高到低）：</p>
<ol>
<li>properties配置文件</li>
<li>yml配置文件</li>
<li>yaml配置文件</li>
</ol>
<p>虽然springboot支持多种格式配置文件，但是在项目开发时，推荐统一使用一种格式的配置。（yml是主流）<br>
在SpringBoot项目当中除了以上3种配置文件外，SpringBoot为了增强程序的扩展性，除了支持配置文件的配置方式以外，还支持另外两种常见的配置方式：</p>
<ol>
<li>Java系统属性配置 （格式： -Dkey=value）</li>
</ol>
<pre><code class="language-yml">-Dserver.port=9000
</code></pre>
<ol start="2">
<li>命令行参数 （格式：--key=value）</li>
</ol>
<pre><code class="language-yml">--server.port=10010
</code></pre>
<p>在debug处编辑配置，打开之后，选择 Modify options , 选择 Add VM options, Program arguments。命令行参数的优先级时最高的，同时配置的情况下，命令行参数的配置项生效。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703175107.png" alt="" loading="lazy"><br>
五种配置方式的优先级： 命令行参数 &gt;  系统属性参数 &gt; properties参数 &gt; yml参数 &gt; yaml参数<br>
思考：如果项目已经打包上线了，这个时候我们又如何来设置Java系统属性和命令行参数呢？</p>
<pre><code class="language-yml">java -Dserver.port=9000 -jar XXXXX.jar --server.port=10010
</code></pre>
<p>Springboot项目进行打包时，需要引入插件 spring-boot-maven-plugin (基于官网骨架创建项目，会自动添加该插件)</p>
<ol>
<li>执行maven打包指令package，把项目打成jar文件</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703175648.png" alt="" loading="lazy"><br>
2. 使用命令：java -jar 方式运行jar文件程序。</p>
<p>在target目录下运行cmd，输入java可以打开帮助文档，tab补全命令，control+c结束进程<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703175815.png" alt="" loading="lazy"><br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703180133.png" alt="" loading="lazy"></p>
<h1 id="bean管理"><strong>Bean管理</strong></h1>
<h2 id="bean的作用域"><strong>Bean的作用域</strong></h2>
<p>在前面我们提到的IOC容器当中，默认bean对象是单例的 (只有一个实例对象)。在Spring中支持五种作用域，后三种在web环境才生效：</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton</td>
<td>容器内同名称的bean只有一个实例（单例）（默认）</td>
</tr>
<tr>
<td>prototype</td>
<td>每次使用该bean时会创建新的实例（非单例）</td>
</tr>
<tr>
<td>request</td>
<td>每个请求范围内会创建新的实例（web环境中，了解）</td>
</tr>
<tr>
<td>session</td>
<td>每个会话范围内会创建新的实例（web环境中，了解）</td>
</tr>
<tr>
<td>application</td>
<td>每个应用范围内会创建新的实例（web环境中，了解）</td>
</tr>
</tbody>
</table>
<ul>
<li>可以借助Spring中的@Scope注解来进行配置作用域</li>
</ul>
<p>控制器：</p>
<pre><code class="language-java">@RestController
public class DeptController {

    public DeptController() {
        System.out.println(&quot;创建了deptController对象...&quot;);
    }

    @Autowired
    private DeptService deptService;
...
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">@SpringBootTest
class SpringbootWebTests {

    @Autowired
    private ApplicationContext applicationContext;//IOC容器对象

    @Test
    public void testScope(){
        for (int i = 0; i &lt; 1000; i++) {
            Object deptController=applicationContext.getBean(&quot;deptController&quot;);
            System.out.println(deptController);
        }
    }

}
</code></pre>
<p>执行测试方法：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703191438.png" alt="" loading="lazy"></p>
<ul>
<li>IOC容器中的bean默认使用的作用域：singleton (单例)</li>
<li>默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化(延迟到第一次使用时)</li>
</ul>
<pre><code class="language-java">@Scope(&quot;prototype&quot;)//多例
@RestController
public class DeptController {

    public DeptController() {
        System.out.println(&quot;创建了deptController对象...&quot;);
    }

    @Autowired
    private DeptService deptService;
...
</code></pre>
<ul>
<li>prototype的bean，每一次使用该bean的时候都会创建一个新的实例</li>
<li>实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性</li>
</ul>
<p>无状态的Bean单例保存（无状态不保存数据），节约资源，性能更高。有状态单例保存，为多线程每个线程记录数据。</p>
<h2 id="第三方bean"><strong>第三方Bean</strong></h2>
<p>之前我们所配置的bean，像controller、service，dao三层体系下编写的类，这些类都是我们在项目当中自己定义的类(自定义类)。当我们要声明这些bean，也非常简单，我们只需要在类上加上@Component以及它的这三个衍生注解（@Controller、@Service、@Repository），就可以来声明这个bean对象了。<br>
但是在我们项目开发当中，还有一种情况就是这个类它不是我们自己编写的，而是我们引入的第三方依赖当中提供的，那么此时我们是无法使用 @Component 及其衍生注解来声明bean的，此时就需要使用@Bean注解来声明bean 了。</p>
<ul>
<li>在启动类中直接声明这个Bean。比如：我们可以将我们之前使用的阿里云OSS操作的工具类，基于@Bean注解的方式来声明Bean。此时给这个类增加了一个构造器。</li>
</ul>
<pre><code class="language-java">public class AliyunOSSOperator {

    private AliyunOSSProperties aliyunOSSProperties;

    public AliyunOSSOperator(AliyunOSSProperties aliyunOSSProperties) {
        this.aliyunOSSProperties = aliyunOSSProperties;
    }

    public String upload(byte[] content, String originalFilename) throws Exception {
        String endpoint = aliyunOSSProperties.getEndpoint();
        String bucketName = aliyunOSSProperties.getBucketName();
        String region = aliyunOSSProperties.getRegion();
...
</code></pre>
<p>通过@Bean注解的name 或 value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名。如果第三方bean需要依赖其他bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。</p>
<pre><code class="language-java">@SpringBootApplication
public class SpringbootWebConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootWebConfigApplication.class, args);
    }

    @Bean
    public AliyunOSSOperator aliyunOSSOperator(AliyunOSSProperties aliyunOSSProperties) {//参数上省略了Autowired自动装配注解
        return new AliyunOSSOperator(aliyunOSSProperties);
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">@SpringBootTest
class SpringbootWebTests {

    @Autowired
    private AliyunOSSOperator aliyunOSSOperator;

    @Test
    public void testUpload() throws Exception {
        File file = new File(&quot;D:\\Gridea\\图标.jpg&quot;);
        String url=aliyunOSSOperator.upload(FileUtil.readBytes(file),&quot;图标.jpg&quot;);
        System.out.println(url);
    }

}
</code></pre>
<ul>
<li>若要管理的第三方 bean 对象，建议对这些bean进行集中分类配置，可以通过 @Configuration 注解声明一个配置类。【推荐】</li>
</ul>
<pre><code class="language-java">@Configuration
public class CommenConfig {
    @Bean
    public AliyunOSSOperator aliyunOSSOperator(AliyunOSSProperties aliyunOSSProperties) {//参数上省略了Autowired自动装配注解
        return new AliyunOSSOperator(aliyunOSSProperties);
    }
}
</code></pre>
<h1 id="springboot原理"><strong>SpringBoot原理</strong></h1>
<p>Spring是目前世界上最流行的Java框架，它可以帮助我们更加快速、更加容易的来构建Java项目。而在Spring家族当中提供了很多优秀的框架，而所有的框架都是基于一个基础框架的SpringFramework(也就是Spring框架)。而前面我们也提到，如果我们直接基于Spring框架进行项目的开发，会比较繁琐。</p>
<p>这个繁琐主要体现在两个地方：</p>
<ol>
<li>在pom.xml中依赖配置比较繁琐，在项目开发时，需要自己去找到对应的依赖，还需要找到依赖它所配套的依赖以及对应版本，否则就会出现版本冲突问题。</li>
<li>在使用Spring框架进行项目开发时，需要在Spring的配置文件中做大量的配置，这就造成Spring框架入门难度较大，学习成本较高。</li>
</ol>
<ul>
<li>基于Spring存在的问题，官方在Spring框架4.0版本之后，又推出了一个全新的框架：SpringBoot。</li>
<li>通过 SpringBoot来简化Spring框架的开发(是简化不是替代)。我们直接基于SpringBoot来构建Java项目，会让我们的项目开发更加简单，更加快捷。</li>
</ul>
<p>SpringBoot框架之所以使用起来更简单更快捷，是因为SpringBoot框架底层提供了两个非常重要的功能：一个是起步依赖，一个是自动配置。</p>
<ul>
<li>通过SpringBoot所提供的起步依赖，就可以大大的简化pom文件当中依赖的配置，从而解决了Spring框架当中依赖配置繁琐的问题。</li>
<li>通过自动配置的功能就可以大大的简化框架在使用时bean的声明以及bean的配置。我们只需要引入程序开发时所需要的起步依赖，项目开发时所用到常见的配置都已经有了，我们直接使用就可以了。</li>
</ul>
<h2 id="起步依赖"><strong>起步依赖</strong></h2>
<p>当我们引入了 spring-boot-starter-web 之后，maven会通过依赖传递特性，将web开发所需的常见依赖都传递下来。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703195522.png" alt="" loading="lazy"><br>
所以，起步依赖的原理就是Maven的依赖传递。</p>
<ul>
<li>在SpringBoot给我们提供的这些起步依赖当中，已提供了当前程序开发所需要的所有的常见依赖(官网地址：https://docs.spring.io/spring-boot/docs/2.7.7/reference/htmlsingle/#using.build-systems.starters)。</li>
<li>比如：springboot-starter-web，这是web开发的起步依赖，在web开发的起步依赖当中，就集成了web开发中常见的依赖：json、web、webmvc、tomcat等。我们只需要引入这一个起步依赖，其他的依赖都会自动的通过Maven的依赖传递进来。</li>
</ul>
<h2 id="自动配置"><strong>自动配置</strong></h2>
<p>SpringBoot的自动配置就是当spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。<br>
我们要将一个对象转为json，直接注入一个Gson，然后就可以直接使用了。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703195857.png" alt="" loading="lazy"></p>
<pre><code class="language-java">@Autowired
    private Gson gson;

    @Test
    public void testJson(){
        System.out.println(gson.toJson(Result.success(&quot;hello&quot;)));//{&quot;code&quot;:1,&quot;msg&quot;:&quot;success&quot;,&quot;data&quot;:&quot;hello&quot;}
    }
</code></pre>
<h3 id="实现方案"><strong>实现方案</strong></h3>
<ul>
<li>准备工作：在Idea中导入&quot;资料\03. 自动配置原理&quot; 下的 itheima-utils 工程</li>
<li>在SpringBoot项目 spring-boot-web-config 工程中，通过坐标引入itheima-utils依赖</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703200725.png" alt="" loading="lazy"></figure>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;com.example&lt;/groupId&gt;
            &lt;artifactId&gt;itheima-utils&lt;/artifactId&gt;
            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>1、引入的 itheima-utils 中配置如下:</p>
<pre><code class="language-java">@Component
public class TokenParser {
    public void parse(){
        System.out.println(&quot;TokenParser ... parse ...&quot;);
    }
}
</code></pre>
<p>2、在测试类中，添加测试方法</p>
<pre><code class="language-java">@Autowired
    private TokenParser tokenParser;

    @Test
    public void testTokenParser() {
        tokenParser.parse();
    }
</code></pre>
<p>3、执行测试方法<br>
异常信息描述： 没有com.example.TokenParse类型的bean<br>
说明：在Spring容器中没有找到com.example.TokenParse类型的bean对象</p>
<ul>
<li>思考：引入进来的第三方依赖当中的bean以及配置类为什么没有生效？
<ul>
<li>原因在我们之前讲解IOC的时候有提到过，在类上添加@Component注解来声明bean对象时，还需要保证@Component注解能被Spring的组件扫描到。</li>
<li>SpringBoot项目中的@SpringBootApplication注解，具有包扫描的作用，但是它只会扫描启动类所在的当前包以及子包。</li>
<li>当前包：com.itheima， 第三方依赖中提供的包：com.example（扫描不到）</li>
</ul>
</li>
</ul>
<p>方案1：@ComponentScan 组件扫描</p>
<pre><code class="language-java">@ComponentScan(basePackages = {&quot;com.example&quot;,&quot;com.itheima&quot;})//一旦声明了组件扫描的范围，默认扫描的范围就不再生效
@SpringBootApplication//具备组件扫描功能，但是扫描的是启动类所在的包及其子包
public class SpringbootWebConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootWebConfigApplication.class, args);
    }
}
</code></pre>
<p>我们进行项目开发时，当需要引入大量的第三方的依赖，就需要在启动类上配置N多要扫描的包，这种方式会很繁琐。而且这种大面积的扫描性能也比较低。<br>
缺点：</p>
<ol>
<li>使用繁琐</li>
<li>性能低</li>
</ol>
<p>结论：SpringBoot中并没有采用以上这种方案。<br>
方案二：@Import导入</p>
<ul>
<li>导入形式主要有以下几种：
<ol>
<li>导入普通类</li>
<li>导入配置类</li>
<li>导入ImportSelector接口实现类</li>
</ol>
</li>
</ul>
<p>1). 使用@Import导入普通类（TokenPaser上不用@Component注解了）：</p>
<pre><code class="language-java">@Import(TokenParser.class)
@SpringBootApplication//具备组件扫描功能，但是扫描的是启动类所在的包及其子包
public class SpringbootWebConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootWebConfigApplication.class, args);
    }
}
</code></pre>
<p>2). 使用@Import导入配置类(工具类中）：<br>
配置类：</p>
<pre><code class="language-java">@Configuration
public class HeaderConfig {
    @Bean
    public HeaderParser headerParser(){
        return new HeaderParser();
    }

    @Bean
    public HeaderGenerator headerGenerator(){
        return new HeaderGenerator();
    }
}
</code></pre>
<p>启动类：</p>
<pre><code class="language-java">@Import(HeaderConfig.class)
@SpringBootApplication//具备组件扫描功能，但是扫描的是启动类所在的包及其子包
public class SpringbootWebConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootWebConfigApplication.class, args);
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">@Autowired
    private HeaderParser headerParser;

    @Test
    public void testHeaderParser(){
        headerParser.parse();
    }
</code></pre>
<p>3). 使用@Import导入(工具包中）ImportSelector接口实现类：<br>
ImportSelector接口实现类：</p>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        //返回值字符串数组（数组中封装了全限定名称的类）
        return new String[]{&quot;com.example.HeaderConfig&quot;};
    }
}
</code></pre>
<p>annotationMetadata 是 Spring 用来描述“当前处理的类(SpringbootWebConfigApplication)”上的注解信息(@Import(MyImportSelector.class),@SpringBootApplication)的一个对象，常在 ImportSelector、DeferredImportSelector 等场景中出现，用来决定要引入哪些配置类。<br>
启动类:</p>
<pre><code class="language-java">@Import(MyImportSelector.class)
@SpringBootApplication//具备组件扫描功能，但是扫描的是启动类所在的包及其子包
public class SpringbootWebConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootWebConfigApplication.class, args);
    }
}
</code></pre>
<p>怎么让第三方依赖自己指定bean对象和配置类？</p>
<ul>
<li>比较常见的方案就是第三方依赖给我们提供一个注解，这个注解一般都以@EnableXxxx开头的注解，注解中封装的就是@Import注解</li>
</ul>
<p>4). 使用第三方依赖提供的 @EnableXxxxx注解<br>
第三方依赖中提供的注解：</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Import(MyImportSelector.class)
public @interface EnableHeaderConfig {
}
</code></pre>
<p>在使用时只需在启动类上加上@EnableXxxxx注解即可：</p>
<pre><code class="language-java">@EnableHeaderConfig
@SpringBootApplication//具备组件扫描功能，但是扫描的是启动类所在的包及其子包
public class SpringbootWebConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootWebConfigApplication.class, args);
    }
}
</code></pre>
<h3 id="原理分析"><strong>原理分析</strong></h3>
<p>要搞清楚SpringBoot的自动配置原理，要从SpringBoot启动类上使用的核心注解@SpringBootApplication开始分析：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703204605.png" alt="" loading="lazy"></p>
<p>我们先来看第一个注解：@SpringBootConfiguration<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703204629.png" alt="" loading="lazy"><br>
@SpringBootConfiguration注解上使用了@Configuration，表明SpringBoot启动类就是一个配置类。<br>
@Indexed注解，是用来加速应用启动的（不用关心）。<br>
接下来再先看@ComponentScan注解：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703204634.png" alt="" loading="lazy"><br>
@ComponentScan注解是用来进行组件扫描的，扫描启动类所在的包及其子包下所有被@Component及其衍生注解声明的类。<br>
SpringBoot启动类，之所以具备扫描包功能，就是因为包含了@ComponentScan注解。<br>
最后我们来看看@EnableAutoConfiguration注解（自动配置核心注解）：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703204638.png" alt="" loading="lazy"><br>
使用@Import注解，导入了实现ImportSelector接口的实现类。<br>
AutoConfigurationImportSelector类是ImportSelector接口的实现类。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703204642.png" alt="" loading="lazy"><br>
AutoConfigurationImportSelector类中重写了ImportSelector接口的selectImports()方法：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703204834.png" alt="" loading="lazy"><br>
selectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703204954.png" alt="" loading="lazy"></p>
<pre><code class="language-java">protected static class AutoConfigurationEntry {
        private final List&lt;String&gt; configurations;
        private final Set&lt;String&gt; exclusions;

        private AutoConfigurationEntry() {
            this.configurations = Collections.emptyList();
            this.exclusions = Collections.emptySet();
        }

        AutoConfigurationEntry(Collection&lt;String&gt; configurations, Collection&lt;String&gt; exclusions) {
            this.configurations = new ArrayList(configurations);
            this.exclusions = new HashSet(exclusions);
        }

        public List&lt;String&gt; getConfigurations() {
            return this.configurations;
        }

        public Set&lt;String&gt; getExclusions() {
            return this.exclusions;
        }
    }
</code></pre>
<p>getAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata, attributes)方法获取在配置文件中配置的所有自动配置类的集合<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703205225.png" alt="" loading="lazy"><br>
getCandidateConfigurations方法的功能：<br>
获取所有基于 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中配置类的集合<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703205620.png" alt="" loading="lazy"><br>
打开上面的第三方依赖中提供的 GsonAutoConfiguration 类：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703210651.png" alt="" loading="lazy"><br>
在GsonAutoConfiguration类上，添加了注解@AutoConfiguration，通过查看源码，可以明确：GsonAutoConfiguration 类是一个配置。proxyBeanMethods = false 表示 Spring 不会为这个配置类生成 CGLIB 代理（提高性能，适用于配置类中无方法互相调用）。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250703210526.png" alt="" loading="lazy"><br>
看到这里，大家就应该明白为什么可以完成自动配置了，原理就是在配置类中定义一个@Bean标识的方法，而Spring会自动调用配置类中使用@Bean标识的方法，并把方法的返回值注册到IOC容器中。在配置类上还有一个注解@ConditionalOnMissingBean，只有符合条件才会注入到IOC容器中。</p>
<h3 id="conditional"><strong>@Conditional</strong></h3>
<p>@Conditional本身是一个父注解，派生出大量的子注解：</p>
<ul>
<li>作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring的IOC容器中。</li>
<li>位置：方法、类</li>
<li>@Conditional本身是一个父注解，派生出大量的子注解：
<ul>
<li>@ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器。</li>
<li>@ConditionalOnMissingBean：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。容器不会缓存实例。</li>
<li>@ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。</li>
</ul>
</li>
</ul>
<p>@ConditionalOnClass注解：</p>
<pre><code class="language-java">@Configuration
public class HeaderConfig {

    @Bean
    @ConditionalOnClass(name=&quot;io.jsonwebtoken.Jwts&quot;)//环境中存在指定的这个类，才会将该bean加入IOC容器
    public HeaderParser headerParser(){
        return new HeaderParser();
    }
    
    //省略其他代码...
}
</code></pre>
<p>pom.xml：</p>
<pre><code class="language-xml">&lt;!--JWT令牌--&gt;
&lt;dependency&gt;
     &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
     &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
     &lt;version&gt;0.9.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">    @Autowired
    private HeaderParser headerParser;

    @Test
    public void testHeaderParser(){
        headerParser.parse();
    }
</code></pre>
<p>因为 io.jsonwebtoken.Jwts 字节码文件在启动SpringBoot程序时已存在，所以创建HeaderParser对象并注册到IOC容器中。<br>
@ConditionalOnProperty注解：<br>
先在application.yml配置文件中添加如下的键值对：</p>
<pre><code class="language-yml">name: ys
</code></pre>
<p>在声明bean的时候就可以指定一个条件@ConditionalOnProperty</p>
<pre><code class="language-java">@Configuration
public class HeaderConfig {

    @Bean
    //@ConditionalOnClass(name=&quot;io.jsonwebtoken.Jwts&quot;)//环境中存在指定的这个类，才会将该bean加入IOC容器
    @ConditionalOnProperty(name=&quot;myname&quot;,havingValue = &quot;ys&quot;)
    public HeaderParser headerParser(){
        return new HeaderParser();
    }

    @Bean
    public HeaderGenerator headerGenerator(){
        return new HeaderGenerator();
    }
}
</code></pre>
<p>例如Gson类上@ConditionalOnClass，只有存在Gson类，才会创建Bean对象。</p>
<pre><code class="language-java">@AutoConfiguration
@ConditionalOnClass(Gson.class)
@EnableConfigurationProperties(GsonProperties.class)
public class GsonAutoConfiguration {

	@Bean
	@ConditionalOnMissingBean
	public GsonBuilder gsonBuilder(List&lt;GsonBuilderCustomizer&gt; customizers) {
		GsonBuilder builder = new GsonBuilder();
		customizers.forEach((c) -&gt; c.customize(builder));
		return builder;
	}

	@Bean
	@ConditionalOnMissingBean
	public Gson gson(GsonBuilder gsonBuilder) {
		return gsonBuilder.create();
	}
...
</code></pre>
<h3 id="自定义starter"><strong>自定义starter</strong></h3>
<p>所谓starter指的就是SpringBoot当中的起步依赖。在SpringBoot当中已经给我们提供了很多的起步依赖了，我们为什么还需要自定义 starter 起步依赖？<br>
这是因为在实际的项目开发当中，我们可能会用到很多第三方的技术，并不是所有的第三方的技术官方都给我们提供了与SpringBoot整合的starter起步依赖，但是这些技术又非常的通用，在很多项目组当中都在使用。<br>
在自定义一个起步依赖starter的时候，按照规范需要定义两个模块：</p>
<ol>
<li>starter模块（进行依赖管理[把程序开发所需要的依赖都定义在starter起步依赖中]）</li>
<li>autoconfigure模块（自动配置）</li>
</ol>
<p>将来在项目当中进行相关功能开发时，只需要引入一个起步依赖就可以了，因为它会将autoconfigure自动配置的依赖给传递下来。而在springboot中，官方提供的起步依赖 或 第三方提供的起步依赖，基本都会包含两个模块，如下所示：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704110720.png" alt="" loading="lazy"><br>
其中，spring-boot-starter  或  xxx-spring-boot-starter 这个模块主要是依赖管理的功能。 而 spring-boot-autoconfigure 或 xxxx-spring-boot-autoconfigure 主要是起到自动配置的作用，自动配置的核心代码就在这个模块中编写。</p>
<ul>
<li>SpringBoot官方starter命名： spring-boot-starter-xxxx</li>
<li>第三组织提供的starter命名：  xxxx-spring-boot-starter</li>
</ul>
<p>上面我们简单介绍了自定义starter的场景，以及自定义starter时涉及到的模块之后，接下来我们就来完成一个自定义starter的案例。</p>
<ul>
<li>需求：自定义aliyun-oss-spring-boot-starter，完成阿里云OSS操作工具类 AliyunOSSOperator 的自动配置。</li>
<li>目标：引入起步依赖引入之后，要想使用阿里云OSS，注入AliyunOSSOperator 直接使用即可。</li>
</ul>
<p>1). 创建starter模块：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704111315.png" alt="" loading="lazy"><br>
选择spring版本后不用勾选依赖直接创建。<br>
2).删掉模块里除了pom.xml文件之外的内容，文件里spring版本尽量保证与要引用starter的工程版本一致，其他用不着的配置删掉，保留精简格式：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.2.10&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
    &lt;artifactId&gt;aliyun-oss-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;aliyun-oss-spring-boot-starter&lt;/name&gt;
    &lt;description&gt;aliyun-oss-spring-boot-starter&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        

    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<p>3).创建自动配置模块：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704112211.png" alt="" loading="lazy"><br>
不用选依赖直接创建。<br>
4).修改自动模块内容，pom.xml文件精简到（精简后与starter模块一样），其他的文件删除后模块结构如下：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704112828.png" alt="" loading="lazy"><br>
5).在starter模块pom.xml文件中引入自动配置模块，此时starter模块定义完成：</p>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-oss-spring-boot-autoconfigure&lt;/artifactId&gt;
            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>6).将阿里云操作类相关文件复制过来：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704114511.png" alt="" loading="lazy"><br>
pom.xml添加相关依赖：</p>
<pre><code class="language-xml">&lt;!--阿里云OSS--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
            &lt;version&gt;3.17.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
            &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
            &lt;version&gt;2.3.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.activation&lt;/groupId&gt;
            &lt;artifactId&gt;activation&lt;/artifactId&gt;
            &lt;version&gt;1.1.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- no more than 2.3.3--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
            &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
            &lt;version&gt;2.3.3&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>此时复制过来的AliyunOSSProperties上面有lombok的@Data注解，删掉并自定义getter and setter和toString()。那此时，大家思考下，在类上添加的 @Component 注解还有用吗？<br>
答案：没用了。  在SpringBoot项目中，并不会去扫描com.aliyun.oss这个包，不扫描这个包那类上的注解也就失去了作用。@Component注解不需要使用了，可以从类上删除了。<br>
7).删除 AliyunOSSOperator 工具类上的 @Component 注解 和 @Autowired 注解：</p>
<pre><code class="language-java">public class AliyunOSSOperator {

    private AliyunOSSProperties aliyunOSSProperties;

    public AliyunOSSOperator(AliyunOSSProperties aliyunOSSProperties) {
        this.aliyunOSSProperties = aliyunOSSProperties;
    }

    public String upload(byte[] content, String originalFilename) throws Exception {
        ...
</code></pre>
<p>删除 AliyunOSSProperties 实体类上的 @Component 注解：</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)
public class AliyunOSSProperties {
    private String endpoint;
    private String bucketName;
    private String region;
    ...
</code></pre>
<p>上面的@ConfigurationProperties注解，作用是可以直接将配置文件中配置项的值自动的注入到对象的属性中。<br>
8).定义自动配置类：</p>
<pre><code class="language-java">@EnableConfigurationProperties(AliyunOSSProperties.class)
@Configuration
public class AliyunOSSAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public AliyunOSSOperator getAliyunOSSOperator(AliyunOSSProperties aliyunOSSProperties) {
        return new AliyunOSSOperator(aliyunOSSProperties);
    }
}
</code></pre>
<p>@EnableConfigurationProperties 本质上就是一种“更高级、更语义化”的 @Import 封装，用来专门处理配置属性类（带 @ConfigurationProperties 注解的类）。<br>
9).在 aliyun-oss-spring-boot-autoconfigure 模块中的resources下，新建自动配置文件 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports<br>
将自动配置类的全类名，配置在文件中，这样在springboot启动的时候，就会加载到这份文件，并加载到其中的配置类了。</p>
<p>配置内容如下：</p>
<pre><code>com.aliyun.oss.AliyunOSSAutoConfiguration
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704121508.png" alt="" loading="lazy"><br>
10).测试：<br>
在导入的test工程中引入阿里云starter依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
    &lt;artifactId&gt;aliyun-oss-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704122648.png" alt="" loading="lazy"><br>
在导入的test工程中的 application.yml 中配置阿里云OSS的配置信息：</p>
<pre><code class="language-yml">aliyun:
  oss:
    endpoint: https://oss-cn-beijing.aliyuncs.com
    bucketName: java-ai-ys-wasd
    region: cn-beijing
</code></pre>
<p>在test工程中的 UploadController 类编写代码：</p>
<pre><code class="language-java">@RestController
public class UploadController {

    @Autowired
    private AliyunOSSOperator aliyunOSSOperator;

    @PostMapping(&quot;/upload&quot;)
    public String upload(MultipartFile image) throws Exception {
        //上传文件到阿里云 OSS
        String url=aliyunOSSOperator.upload(image.getBytes(), image.getOriginalFilename());
        System.out.println(url);
        return url;
    }

}
</code></pre>
<p>编写完代码后，我们启动当前的SpringBoot测试工程，使用Apifox工具进行文件上传。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250704123438.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AOP]]></title>
        <id>https://yyss1014.github.io/post/aop/</id>
        <link href="https://yyss1014.github.io/post/aop/">
        </link>
        <updated>2025-06-27T13:45:47.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#aop%E5%9F%BA%E7%A1%80"><strong>AOP基础</strong></a>
<ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><strong>核心概念</strong></a></li>
</ul>
</li>
<li><a href="#aop%E8%BF%9B%E9%98%B6"><strong>AOP进阶</strong></a>
<ul>
<li><a href="#%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><strong>通知类型</strong></a></li>
<li><a href="#%E9%80%9A%E7%9F%A5%E9%A1%BA%E5%BA%8F"><strong>通知顺序</strong></a></li>
<li><a href="#%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><strong>切入点表达式</strong></a>
<ul>
<li><a href="#execution"><strong>execution</strong></a></li>
<li><a href="#annotation"><strong>annotation</strong></a></li>
</ul>
</li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E7%82%B9"><strong>连接点</strong></a></li>
</ul>
</li>
<li><a href="#aop%E6%A1%88%E4%BE%8B"><strong>AOP案例</strong></a>
<ul>
<li><a href="#threadlocal"><strong>ThreadLocal</strong></a></li>
<li><a href="#%E8%AE%B0%E5%BD%95%E5%BD%93%E5%89%8D%E7%99%BB%E5%BD%95%E5%91%98%E5%B7%A5"><strong>记录当前登录员工</strong></a></li>
</ul>
</li>
</ul>
<br>
AOP：Aspect Oriented Programming（面向切面编程、面向方面编程），其实说白了，面向切面编程就是面向特定方法编程。<br>
AOP的优势主要体现在以下四个方面：</p>
<ul>
<li>减少重复代码：不需要在业务方法中定义大量的重复性的代码，只需要将重复性的代码抽取到AOP程序中即可。</li>
<li>代码无侵入：在基于AOP实现这些业务功能时，对原有的业务代码是没有任何侵入的，不需要修改任何的业务代码。</li>
<li>提高开发效率</li>
<li>维护方便</li>
</ul>
<h1 id="aop基础"><strong>AOP基础</strong></h1>
<ul>
<li>需求：统计部门管理各个业务层方法执行耗时。</li>
<li>原始方式：<br>
在原始的实现方式中，我们需要在业务层的也一个方法执行执行，获取方法运行的开始时间； 然后运行原始的方法逻辑； 最后在每一个方法运行结束时，获取方法运行结束时间，计算执行耗时。</li>
</ul>
<p>1). 导入依赖：在 pom.xml 文件中导入 AOP 的依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2). 编写AOP程序：针对于特定方法根据业务需要进行编程</p>
<pre><code class="language-java">@Aspect//标识当前类是AOP类
@Component
@Slf4j
public class RecordTimeAspect {

    @Around(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)
    public Object recordTime(ProceedingJoinPoint pjp) throws Throwable {
        //1.记录方法运行的开始时间
        long begin=System.currentTimeMillis();
        //2.执行原始的方法
        Object result = pjp.proceed();
        //3.记录方法运行的结束时间
        long end=System.currentTimeMillis();
        log.info(&quot;方法{}执行耗时：{}ms&quot;,pjp.getSignature(),end-begin);
        return result;
    }
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250629151953.png" alt="" loading="lazy"><br>
我们通过AOP入门程序完成了业务方法执行耗时的统计，那其实AOP的功能远不止于此，常见的应用场景如下：</p>
<ul>
<li>记录系统的操作日志</li>
<li>权限控制</li>
<li>事务管理：我们前面所讲解的Spring事务管理，底层其实也是通过AOP来实现的，只要添加@Transactional注解之后，AOP程序自动会在原始方法运行前先来开启事务，在原始方法运行完毕之后提交或回滚事务<br>
这些都是AOP应用的典型场景。</li>
</ul>
<p>通过入门程序，我们也应该感受到了AOP面向切面编程的一些优势：</p>
<ul>
<li>代码无侵入：没有修改原始的业务方法，就已经对原始的业务方法进行了功能的增强或者是功能的改变</li>
<li>减少了重复代码</li>
<li>提高开发效率</li>
<li>维护方便</li>
</ul>
<h2 id="核心概念"><strong>核心概念</strong></h2>
<p>通过SpringAOP的快速入门，感受了一下AOP面向切面编程的开发方式。下面我们再来学习AOP当中涉及到的一些核心概念。</p>
<ul>
<li>
<p>连接点：JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）</p>
<ul>
<li>连接点指的是可以被aop控制的方法。例如：入门程序当中所有的业务方法都是可以被aop控制的方法。</li>
<li>在SpringAOP提供的JoinPoint当中，封装了连接点方法在执行时的相关信息。（后面会有具体的讲解）</li>
</ul>
</li>
<li>
<p>通知：Advice，指哪些重复的逻辑，也就是共性功能（最终体现为一个方法）</p>
<ul>
<li>在入门程序中是需要统计各个业务方法的执行耗时的，此时我们就需要在这些业务方法运行开始之前，先记录这个方法运行的开始时间，在每一个业务方法运行结束的时候，再来记录这个方法运行的结束时间。</li>
<li>是在AOP面向切面编程当中，我们只需要将这部分重复的代码逻辑抽取出来单独定义。抽取出来的这一部分重复的逻辑，也就是共性的功能。</li>
</ul>
</li>
<li>
<p>切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用。</p>
<ul>
<li>在通知当中，我们所定义的共性功能到底要应用在哪些方法上？此时就涉及到了切入点pointcut概念。切入点指的是匹配连接点的条件。通知仅会在切入点方法运行时才会被应用。</li>
<li>在aop的开发当中，我们通常会通过一个切入点表达式来描述切入点(后面会有详解)。</li>
</ul>
</li>
<li>
<p>切面：Aspect，描述通知与切入点的对应关系（通知+切入点）<br>
当通知和切入点结合在一起，就形成了一个切面。通过切面就能够描述当前aop程序需要针对于哪个原始方法，在什么时候执行什么样的操作。而切面所在的类，称之为切面类（被@Aspect注解标识的类）。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250629152833.png" alt="" loading="lazy"></p>
</li>
<li>
<p>目标对象：Target，通知所应用的对象<br>
目标对象指的就是通知所应用的对象，我们就称之为目标对象。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250629152857.png" alt="" loading="lazy"></p>
</li>
</ul>
<p>AOP的核心概念我们介绍完毕之后，接下来我们再来分析一下我们所定义的通知是如何与目标对象结合在一起，对目标对象当中的方法进行功能增强的。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250629153124.png" alt="" loading="lazy"><br>
Spring的AOP底层是基于动态代理技术来实现的，也就是说在程序运行的时候，会自动的基于动态代理技术为目标对象生成一个对应的代理对象。在代理对象当中就会对目标对象当中的原始方法进行功能的增强。<br>
SpringAOP 旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程 。</p>
<h1 id="aop进阶"><strong>AOP进阶</strong></h1>
<p>AOP的基础知识学习完之后，下面我们对AOP当中的各个细节进行详细的学习。主要分为4个部分：</p>
<ol>
<li>通知类型</li>
<li>通知顺序</li>
<li>切入点表达式</li>
</ol>
<h2 id="通知类型"><strong>通知类型</strong></h2>
<table>
<thead>
<tr>
<th>Spring AOP</th>
<th>通知类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Around</td>
<td>环绕通知，此注解标注的通知方法在目标方法前、后都被执行</td>
</tr>
<tr>
<td>@Before</td>
<td>前置通知，此注解标注的通知方法在目标方法前被执行</td>
</tr>
<tr>
<td>@After</td>
<td>后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>异常后通知，此注解标注的通知方法发生异常后执行</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">@Slf4j
@Component
@Aspect
public class MyAspect1 {
    //前置通知
    @Before(&quot;execution(* com.itheima.service.*.*(..))&quot;)
    public void before(JoinPoint joinPoint){
        log.info(&quot;before ...&quot;);

    }

    //环绕通知
    @Around(&quot;execution(* com.itheima.service.*.*(..))&quot;)
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        log.info(&quot;around before ...&quot;);

        //调用目标对象的原始方法执行
        Object result = proceedingJoinPoint.proceed();
        
        //原始方法如果执行时有异常，环绕通知中的后置代码不会在执行了
        
        log.info(&quot;around after ...&quot;);
        return result;
    }

    //后置通知
    @After(&quot;execution(* com.itheima.service.*.*(..))&quot;)
    public void after(JoinPoint joinPoint){
        log.info(&quot;after ...&quot;);
    }

    //返回后通知（程序在正常执行的情况下，会执行的后置通知）
    @AfterReturning(&quot;execution(* com.itheima.service.*.*(..))&quot;)
    public void afterReturning(JoinPoint joinPoint){
        log.info(&quot;afterReturning ...&quot;);
    }

    //异常通知（程序在出现异常的情况下，执行的后置通知）
    @AfterThrowing(&quot;execution(* com.itheima.service.*.*(..))&quot;)
    public void afterThrowing(JoinPoint joinPoint){
        log.info(&quot;afterThrowing ...&quot;);
    }
}
</code></pre>
<p>1). 没有异常情况下：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250629154309.png" alt="" loading="lazy"><br>
2). 出现异常情况下：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250629154500.png" alt="" loading="lazy"><br>
在使用通知时的注意事项：</p>
<ul>
<li>@Around环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行</li>
<li>@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值，否则原始方法执行完毕，是获取不到返回值的。</li>
</ul>
<p>Spring提供了@PointCut注解，该注解的作用是将公共的切入点表达式抽取出来，需要用到时引用该切入点表达式即可。</p>
<pre><code class="language-java">@Slf4j
@Aspect
@Component
public class MyAspect1 {

    @Pointcut(&quot;execution(* com.itheima.service.*.*(..))&quot;)
    private void pt(){}
    //前置通知
    @Before(&quot;pt()&quot;)
    public void before(JoinPoint joinPoint){
        log.info(&quot;before ...&quot;);

    }

    //环绕通知
    @Around(&quot;pt()&quot;)
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        log.info(&quot;around before ...&quot;);

        //调用目标对象的原始方法执行
        Object result = proceedingJoinPoint.proceed();

        //原始方法如果执行时有异常，环绕通知中的后置代码不会在执行了

        log.info(&quot;around after ...&quot;);
        return result;
    }

    //后置通知
    @After(&quot;pt()&quot;)
    public void after(JoinPoint joinPoint){
        log.info(&quot;after ...&quot;);
    }

    //返回后通知（程序在正常执行的情况下，会执行的后置通知）
    @AfterReturning(&quot;pt()&quot;)
    public void afterReturning(JoinPoint joinPoint){
        log.info(&quot;afterReturning ...&quot;);
    }

    //异常通知（程序在出现异常的情况下，执行的后置通知）
    @AfterThrowing(&quot;pt()&quot;)
    public void afterThrowing(JoinPoint joinPoint){
        log.info(&quot;afterThrowing ...&quot;);
    }
}
</code></pre>
<p>需要注意的是：当切入点方法使用private修饰时，仅能在当前切面类中引用该表达式， 当外部其他切面类中也要引用当前类中的切入点表达式，就需要把private改为public，而在引用的时候，具体的语法为：</p>
<pre><code class="language-java">@Slf4j
@Component
@Aspect
public class MyAspect2 {
    //引用MyAspect1切面类中的切入点表达式
    @Before(&quot;com.itheima.aspect.MyAspect1.pt()&quot;)
    public void before(){
        log.info(&quot;MyAspect2 -&gt; before ...&quot;);
    }
}
</code></pre>
<h2 id="通知顺序"><strong>通知顺序</strong></h2>
<p>当在项目开发当中，我们定义了多个切面类，而多个切面类中多个切入点都匹配到了同一个目标方法。此时当目标方法在运行的时候，这多个切面类当中的这些通知方法都会运行。<br>
默认按照切面类的类名字母排序：</p>
<ul>
<li>目标方法前的通知方法：字母排名靠前的先执行</li>
<li>目标方法后的通知方法：字母排名靠前的后执行</li>
</ul>
<p>如果我们想控制通知的执行顺序有两种方式：</p>
<ol>
<li>修改切面类的类名（这种方式非常繁琐、而且不便管理）</li>
<li>使用Spring提供的@Order注解</li>
</ol>
<pre><code class="language-java">@Slf4j
@Component
@Aspect
@Order(2)  //切面类的执行顺序（前置通知：数字越小先执行; 后置通知：数字越小越后执行）
public class MyAspect2 {
    //前置通知
    @Before(&quot;execution(* com.itheima.service.*.*(..))&quot;)
    public void before(){
        log.info(&quot;MyAspect2 -&gt; before ...&quot;);
    }

    //后置通知 
    @After(&quot;execution(* com.itheima.service.*.*(..))&quot;)
    public void after(){
        log.info(&quot;MyAspect2 -&gt; after ...&quot;);
    }
}
</code></pre>
<h2 id="切入点表达式"><strong>切入点表达式</strong></h2>
<p>切入点表达式：描述切入点方法的一种表达式</p>
<ul>
<li>作用：主要用来决定项目中的哪些方法需要加入通知</li>
</ul>
<h3 id="execution"><strong>execution</strong></h3>
<p>execution主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：</p>
<pre><code class="language-java">execution(访问修饰符?  返回值  包名.类名.?方法名(方法参数) throws 异常?)
</code></pre>
<p>其中带?的表示可以省略的部分</p>
<ul>
<li>访问修饰符：可省略（比如: public、protected）</li>
<li>包名.类名： 可省略（不建议省略，扫描范围大，性能低）</li>
<li>throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常</li>
</ul>
<p>可以使用通配符描述切入点</p>
<ul>
<li>
<ul>
<li>：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分</li>
</ul>
</li>
<li>.. ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数</li>
</ul>
<p>示例：</p>
<ul>
<li>省略方法的修饰符号</li>
</ul>
<pre><code class="language-java">execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))
</code></pre>
<ul>
<li>使用*代替包名（一层包使用一个*）</li>
</ul>
<pre><code class="language-java">execution(* com.itheima.*.*.DeptServiceImpl.delete(java.lang.Integer))
</code></pre>
<ul>
<li>使用..省略包名</li>
</ul>
<pre><code class="language-java">execution(* com..DeptServiceImpl.delete(java.lang.Integer))  
</code></pre>
<ul>
<li>使用*表示以匹配任意字符</li>
</ul>
<pre><code class="language-java">execution(* com..DeptServiceImpl.del*(java.lang.Integer))
execution(* com..DeptServiceImpl.*e(java.lang.Integer))
</code></pre>
<ul>
<li>基于接口匹配</li>
</ul>
<pre><code class="language-java">execution(* com.itheima.service.*.*(..))
</code></pre>
<ul>
<li>根据业务需要，可以使用 且（&amp;&amp;）、或（||）、非（!） 来组合比较复杂的切入点表达式。</li>
</ul>
<pre><code class="language-java">execution(* com.itheima.service.DeptService.list(..)) || execution(* com.itheima.service.DeptService.delete(..))
</code></pre>
<p>切入点表达式的书写建议：</p>
<ul>
<li>所有业务方法名在命名时尽量规范，方便切入点表达式快速匹配。如：查询类方法都是 find 开头，更新类方法都是update开头</li>
<li>描述切入点方法通常基于接口描述，而不是直接描述实现类，增强拓展性</li>
<li>在满足业务需要的前提下，尽量缩小切入点的匹配范围。如：包名匹配尽量不使用 ..，使用 * 匹配单个包</li>
</ul>
<h3 id="annotation"><strong>annotation</strong></h3>
<ol>
<li>编写自定义注解</li>
</ol>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogOperation {
}
</code></pre>
<ol start="2">
<li>在业务类要做为连接点的方法上添加自定义注解</li>
<li>切面类</li>
</ol>
<pre><code class="language-java">@Slf4j
@Component
@Aspect
public class MyAspect6 {
    //针对list方法、delete方法进行前置通知和后置通知

    //前置通知
    @Before(&quot;@annotation(com.itheima.anno.LogOperation)&quot;)
    public void before(){
        log.info(&quot;MyAspect6 -&gt; before ...&quot;);
    }
    
    //后置通知
    @After(&quot;@annotation(com.itheima.anno.LogOperation)&quot;)
    public void after(){
        log.info(&quot;MyAspect6 -&gt; after ...&quot;);
    }
}
</code></pre>
<h2 id="连接点"><strong>连接点</strong></h2>
<p>在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。</p>
<ul>
<li>对于@Around通知，获取连接点信息只能使用ProceedingJoinPoint类型</li>
<li>对于其他四种通知，获取连接点信息只能使用JoinPoint，它是ProceedingJoinPoint的父类型</li>
</ul>
<pre><code class="language-java">@Before(&quot;execution(* com.itheima.service.*.*(..))&quot;)
    public void before(JoinPoint joinPoint){
        log.info(&quot;before ...&quot;);
        //1.获取目标对象
        Object target=joinPoint.getTarget();
        log.info(&quot;获取目标对象:{}&quot;,target);
        //2.获取目标类
        String className = joinPoint.getTarget().getClass().getName();
        log.info(&quot;获取目标类:{}&quot;,className);
        //获取目标方法
        String methodName = joinPoint.getSignature().getName();
        log.info(&quot;获取目标方法:{}&quot;,methodName);
        //获取目标方法参数
        Object[] args = joinPoint.getArgs();
        log.info(&quot;获取目标方法参数:{}&quot;, Arrays.toString(args));
    }
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250629163645.png" alt="" loading="lazy"></figure>
<h1 id="aop案例"><strong>AOP案例</strong></h1>
<p>需求：将案例（Tlias智能学习辅助系统）中增、删、改相关接口的操作日志记录到数据库表中</p>
<ul>
<li>就是当访问部门管理和员工管理当中的增、删、改相关功能接口时，需要详细的操作日志，并保存在数据表中，便于后期数据追踪。</li>
</ul>
<p>操作日志信息包含：</p>
<ul>
<li>操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长</li>
</ul>
<p>1). 准备工作<br>
在 pom.xml 中引入AOP的依赖。<br>
创建数据库表结构：</p>
<pre><code class="language-sql">-- 操作日志表
create table operate_log(
    id int unsigned primary key auto_increment comment 'ID',
    operate_emp_id int unsigned comment '操作人ID',
    operate_time datetime comment '操作时间',
    class_name varchar(100) comment '操作的类名',
    method_name varchar(100) comment '操作的方法名',
    method_params varchar(1000) comment '方法参数',
    return_value varchar(2000) comment '返回值, 存储json格式',
    cost_time int comment '方法执行耗时, 单位:ms'
) comment '操作日志表';
</code></pre>
<p>引入资料中准备的实体类：</p>
<pre><code class="language-java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class OperateLog {
    private Integer id; //ID
    private Integer operateEmpId; //操作人ID
    private LocalDateTime operateTime; //操作时间
    private String className; //操作类名
    private String methodName; //操作方法名
    private String methodParams; //操作方法参数
    private String returnValue; //操作方法返回值
    private Long costTime; //操作耗时
}
</code></pre>
<p>引入资料中准备的日志操作Mapper接口 OperateLogMapper</p>
<pre><code class="language-java">@Mapper
public interface OperateLogMapper {
    
    //插入日志数据
    @Insert(&quot;insert into operate_log (operate_emp_id, operate_time, class_name, method_name, method_params, return_value, cost_time) &quot; +
            &quot;values (#{operateEmpId}, #{operateTime}, #{className}, #{methodName}, #{methodParams}, #{returnValue}, #{costTime});&quot;)
    public void insert(OperateLog log);
    
}
</code></pre>
<p>2). 自定义注解 @Log</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Log {
}
</code></pre>
<p>3). 定义AOP记录日志的切面类</p>
<pre><code class="language-java">@Slf4j
@Aspect
@Component
public class OperationLogAspect {
    @Autowired
    private OperateLogMapper operateLogMapper;

    // 环绕通知
    @Around(&quot;@annotation(com.ys.anno.Log)&quot;)
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        // 记录开始时间
        long startTime = System.currentTimeMillis();
        // 执行方法
        Object result = joinPoint.proceed();
        // 当前时间
        long endTime = System.currentTimeMillis();
        // 耗时
        long costTime = endTime - startTime;

        // 构建日志对象
        //ALT+shift+鼠标左键可以列编辑或者按着鼠标滑轮下滑
        OperateLog operateLog = new OperateLog();
        operateLog.setOperateEmpId(getCurrentUserId()); // 需要实现 getCurrentUserId 方法
        operateLog.setOperateTime(LocalDateTime.now());
        operateLog.setClassName(joinPoint.getTarget().getClass().getName());
        operateLog.setMethodName(joinPoint.getSignature().getName());
        operateLog.setMethodParams(Arrays.toString(joinPoint.getArgs()));
        operateLog.setReturnValue(result.toString());
        operateLog.setCostTime(costTime);

        // 插入日志
        log.info(&quot;记录操作日志：{}&quot;, operateLog);
        operateLogMapper.insert(operateLog);
        return result;
    }
    // 示例方法，获取当前用户ID
    private int getCurrentUserId() {
        // 这里应该根据实际情况从认证信息中获取当前登录用户的ID
        return 1; // 示例返回值
    }
}
</code></pre>
<p>4). 在需要记录的日志的Controller层的方法上，加上注解 @Log</p>
<h2 id="threadlocal"><strong>ThreadLocal</strong></h2>
<ul>
<li>ThreadLocal 并不是一个Thread，而是Thread的局部变量。</li>
<li>ThreadLocal为每个线程提供一份单独的存储空间，具有线程隔离的效果，不同的线程之间不会相互干扰。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250629171922.png" alt="" loading="lazy"></figure>
<ul>
<li>常见方法：
<ul>
<li>public void set(T value)   设置当前线程的线程局部变量的值</li>
</ul>
</li>
</ul>
<pre><code class="language-java">  public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);//return t.threadLocals 设置Thread t的ThreadLocalMap属性值
        if (map != null) {
            map.set(this, value);
        } else {
            createMap(t, value);
        }
    }
</code></pre>
<ul>
<li>public T get()                     返回当前线程所对应的线程局部变量的值</li>
<li>public void remove()          移除当前线程的线程局部变量</li>
</ul>
<pre><code class="language-java">public class ThreadLocalTest {

    private static ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;();

    public static void main(String[] args) {
        local.set(&quot;Main Message&quot;);
        //创建线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                local.set(&quot;Sub Message&quot;);
                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+local.get());//Thread-0:Sub Message
            }
        }).start();
        System.out.println(Thread.currentThread().getName()+&quot;:&quot;+local.get());//main:Main Message
        local.remove();
        System.out.println(Thread.currentThread().getName()+&quot;:&quot;+local.get());//main:null
    }
}
</code></pre>
<h2 id="记录当前登录员工"><strong>记录当前登录员工</strong></h2>
<ol>
<li>定义ThreadLocal操作的工具类，用于操作当前登录员工ID。<br>
在 com.itheima.utils 引入工具类 CurrentHolder</li>
</ol>
<pre><code class="language-java">public class CurrentHolder {

    private static final ThreadLocal&lt;Integer&gt; CURRENT_LOCAL = new ThreadLocal&lt;&gt;();

    public static void setCurrentId(Integer employeeId) {
        CURRENT_LOCAL.set(employeeId);
    }

    public static Integer getCurrentId() {
        return CURRENT_LOCAL.get();
    }

    public static void remove() {
        CURRENT_LOCAL.remove();
    }
}
</code></pre>
<ol start="2">
<li>在TokenFilter中，解析完当前登录员工ID，将其存入ThreadLocal（用完之后需将其删除）。</li>
</ol>
<pre><code class="language-java">@Slf4j
@WebFilter(urlPatterns = &quot;/*&quot;)
public class TokenFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        //1.获取请求路径（获取到的ServletRequest实际是HttpServletRequest）
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        String requestURI = request.getRequestURI();// /emp/login
        //2.是否是登录请求（如果包含login，说明是登录操作，放行
        if (requestURI.contains(&quot;/login&quot;)) {
            log.info(&quot;登录请求，放行&quot;);
            filterChain.doFilter(request, response);
            return;
        }
        //3.获取请求头中的token
        String token=request.getHeader(&quot;token&quot;);
        //4. 判断令牌是否存在，如果不存在，响应 401
        if(token==null||token.isEmpty()){
            log.info(&quot;令牌为空&quot;);
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);//401
            return;
        }
        //5. 解析token，如果解析失败，响应 401
        try {
            Claims claims=JwtUtils.parseJWT(token);
            Integer empId=Integer.valueOf(claims.get(&quot;id&quot;).toString());
            CurrentHolder.setCurrentId(empId);
            log.info(&quot;当前登录员工ID：{}，将其存入ThreadLocal&quot;,empId);
        } catch (Exception e) {
            log.info(&quot;令牌非法&quot;);
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);//401
            return;
        }
        //6. 放行
        log.info(&quot;令牌合法，放行&quot;);
        filterChain.doFilter(request, response);

        //7.删除ThreadLocal中的数据
        CurrentHolder.remove();
    }
}
</code></pre>
<ol start="3">
<li>在AOP程序中，从ThreadLocal中获取当前登录员工的ID。</li>
</ol>
<pre><code class="language-java">private int getCurrentUserId() {
        return CurrentHolder.getCurrentId();// 示例返回值
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[登录认证]]></title>
        <id>https://yyss1014.github.io/post/deng-lu-ren-zheng/</id>
        <link href="https://yyss1014.github.io/post/deng-lu-ren-zheng/">
        </link>
        <updated>2025-06-26T07:27:34.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD"><strong>登录功能</strong></a></li>
<li><a href="#%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C"><strong>登录校验</strong></a></li>
<li><a href="#%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF"><strong>会话技术</strong></a>
<ul>
<li><a href="#%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%96%B9%E6%A1%88"><strong>会话跟踪方案</strong></a>
<ul>
<li><a href="#cookie"><strong>Cookie</strong></a></li>
<li><a href="#session"><strong>session</strong></a></li>
<li><a href="#%E4%BB%A4%E7%89%8C%E6%8A%80%E6%9C%AF"><strong>令牌技术</strong></a></li>
</ul>
</li>
<li><a href="#jwt%E4%BB%A4%E7%89%8C"><strong>JWT令牌</strong></a>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D"><strong>介绍</strong></a></li>
<li><a href="#%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C"><strong>生成和校验</strong></a></li>
<li><a href="#%E7%99%BB%E5%BD%95%E6%97%B6%E4%B8%8B%E5%8F%91%E4%BB%A4%E7%89%8C"><strong>登录时下发令牌</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8filter"><strong>过滤器filter</strong></a>
<ul>
<li><a href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><strong>快速入门</strong></a></li>
<li><a href="#%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><strong>登录校验过滤器</strong></a></li>
<li><a href="#filter%E8%AF%A6%E8%A7%A3"><strong>Filter详解</strong></a>
<ul>
<li><a href="#%E6%8B%A6%E6%88%AA%E8%B7%AF%E5%BE%84"><strong>拦截路径</strong></a></li>
<li><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE"><strong>过滤器链</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8interceptor"><strong>拦截器Interceptor</strong></a>
<ul>
<li><a href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-2"><strong>快速入门</strong></a></li>
<li><a href="#%E4%BB%A4%E7%89%8C%E6%A0%A1%E9%AA%8C"><strong>令牌校验</strong></a></li>
<li><a href="#%E6%8B%A6%E6%88%AA%E8%B7%AF%E5%BE%84-2"><strong>拦截路径</strong></a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><strong>执行流程</strong></a></li>
</ul>
</li>
</ul>
</p>
<h1 id="登录功能"><strong>登录功能</strong></h1>
<p>1). 准备实体类 LoginInfo， 封装登录成功后， 返回给前端的数据 。</p>
<pre><code class="language-java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginInfo {
    private Integer id;
    private String username;
    private String name;
    private String token;
}
</code></pre>
<p>2).  定义LoginController</p>
<pre><code class="language-java">@PostMapping
    public Result login(@RequestBody Emp emp) {
        log.info(&quot;登录：{}&quot;,emp);
        LoginInfo loginInfo=empService.login(emp);
        if(loginInfo!=null){
            return Result.success(loginInfo);
        }
        return Result.error(&quot;用户名或密码错误&quot;);
    }
</code></pre>
<p>3).  EmpServiceImpl 实现login方法</p>
<pre><code class="language-java">@Override
    public LoginInfo login(Emp emp) {
        //根据用户名和密码查询员工信息
        Emp e=empMapper.selectByUsernameAndPassword(emp);
        //判断是否存在这个员工
        if(e!=null){
            log.info(&quot;登录成功，员工信息为：{}&quot;,e);
            return new LoginInfo(e.getId(),e.getUsername(),e.getName(),&quot;&quot;);
        }
        //不存在返回null
        return null;
    }
</code></pre>
<p>4). EmpMapper增加接口方法</p>
<pre><code class="language-java"> @Select(&quot;select id,username,name from emp where username=#{username} and password=#{password}&quot;)
    Emp selectByUsernameAndPassword(Emp emp);
</code></pre>
<h1 id="登录校验"><strong>登录校验</strong></h1>
<p>前面在讲解HTTP协议的时候，我们提到HTTP协议是无状态协议。什么又是无状态的协议？<br>
所谓无状态，指的是每一次请求都是独立的，下一次请求并不会携带上一次请求的数据。而浏览器与服务器之间进行交互，基于HTTP协议也就意味着现在我们通过浏览器来访问了登陆这个接口，实现了登陆的操作，接下来我们在执行其他业务操作时，服务器也并不知道这个员工到底登陆了没有。因为HTTP协议是无状态的，两次请求之间是独立的，所以是无法判断这个员工到底登陆了没有。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250626161114.png" alt="" loading="lazy"><br>
实现登录校验的操作：</p>
<ol>
<li>在员工登录成功后，需要将用户登录成功的信息存起来，记录用户已经登录成功的标记。</li>
<li>在浏览器发起请求时，需要在服务端进行统一拦截，拦截后进行登录校验。</li>
</ol>
<p>我们要完成以上操作，会涉及到web开发中的两个技术：</p>
<ol>
<li>会话技术：用户登录成功之后，在后续的每一次请求中，都可以获取到该标记。</li>
<li>统一拦截技术：过滤器Filter、拦截器Interceptor</li>
</ol>
<h1 id="会话技术"><strong>会话技术</strong></h1>
<ul>
<li>在我们日常生活当中，会话指的就是谈话、交谈。</li>
<li>在web开发当中，会话指的就是浏览器与服务器之间的一次连接，我们就称为一次会话。</li>
</ul>
<p>在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。<br>
<strong>会话跟踪</strong>：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。会话跟踪技术有两种：</p>
<ol>
<li>Cookie（客户端会话跟踪技术）：数据存储在客户端浏览器当中</li>
<li>Session（服务端会话跟踪技术）：数据存储在储在服务端</li>
<li>令牌技术</li>
</ol>
<h2 id="会话跟踪方案"><strong>会话跟踪方案</strong></h2>
<h3 id="cookie"><strong>Cookie</strong></h3>
<p>cookie 是客户端会话跟踪技术，它是存储在客户端浏览器的，我们使用 cookie 来跟踪会话，我们就可以在浏览器第一次发起请求来请求服务器的时候，我们在服务器端来设置一个cookie。<br>
比如第一次请求了登录接口，登录接口执行完成之后，我们就可以设置一个cookie，在 cookie 当中我们就可以来存储用户相关的一些数据信息。比如我可以在 cookie 当中来存储当前登录用户的用户名，用户的ID。<br>
服务器端在给客户端在响应数据的时候，会自动的将 cookie 响应给浏览器，浏览器接收到响应回来的 cookie 之后，会自动的将 cookie 的值存储在浏览器本地。接下来在后续的每一次请求当中，都会将浏览器本地所存储的 cookie 自动地携带到服务端。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250626162302.png" alt="" loading="lazy"><br>
接下来在服务端我们就可以获取到 cookie 的值。我们可以去判断一下这个 cookie 的值是否存在，如果不存在这个cookie，就说明客户端之前是没有访问登录接口的；如果存在 cookie 的值，就说明客户端之前已经登录完成了。这样我们就可以基于 cookie 在同一次会话的不同请求之间来共享数据。</p>
<ul>
<li>服务器会 自动 的将 cookie 响应给浏览器。</li>
<li>浏览器接收到响应回来的数据之后，会 自动 的将 cookie 存储在浏览器本地。</li>
<li>在后续的请求当中，浏览器会 自动 的将 cookie 携带到服务器端。</li>
</ul>
<p>为什么这一切都是自动化进行的？<br>
是因为 cookie 它是 HTP 协议当中所支持的技术，而各大浏览器厂商都支持了这一标准。在 HTTP 协议官方给我们提供了一个响应头和请求头：</p>
<ul>
<li>响应头 Set-Cookie ：设置Cookie数据的</li>
<li>请求头 Cookie：携带Cookie数据的</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250626162600.png" alt="" loading="lazy"><br>
代码测试：</p>
<pre><code class="language-java">@Slf4j
@RestController
public class SessionController {

    //设置Cookie
    @GetMapping(&quot;/c1&quot;)
    public Result cookie1(HttpServletResponse response){
        response.addCookie(new Cookie(&quot;login_username&quot;,&quot;itheima&quot;)); //设置Cookie/响应Cookie
        return Result.success();
    }
        
    //获取Cookie
    @GetMapping(&quot;/c2&quot;)
    public Result cookie2(HttpServletRequest request){
        Cookie[] cookies = request.getCookies();
        for (Cookie cookie : cookies) {
            if(cookie.getName().equals(&quot;login_username&quot;)){
                System.out.println(&quot;login_username: &quot;+cookie.getValue()); //输出name为login_username的cookie
            }
        }
        return Result.success();
    }
}    
</code></pre>
<p>A. 访问c1接口，设置Cookie，http://localhost:8080/c1<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250626164751.png" alt="" loading="lazy"><br>
我们可以看到，设置的cookie，通过<strong>响应头Set-Cookie</strong>响应给浏览器，并且浏览器会将Cookie，存储在浏览器端。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250626164851.png" alt="" loading="lazy"><br>
B. 访问c2接口 http://localhost:8080/c2，此时浏览器会自动的将Cookie携带到服务端，是通过<strong>请求头Cookie</strong>，携带的。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250626165032.png" alt="" loading="lazy"><br>
优缺点：</p>
<ul>
<li>优点：HTTP协议中支持的技术（像Set-Cookie 响应头的解析以及 Cookie 请求头数据的携带，都是浏览器自动进行的，是无需我们手动操作的）</li>
<li>缺点：
<ul>
<li>移动端APP(Android、IOS)中无法使用Cookie</li>
<li>不安全，用户可以自己禁用Cookie</li>
<li>Cookie不能跨域</li>
</ul>
</li>
</ul>
<p>跨域介绍：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250626165605.png" alt="" loading="lazy"></p>
<ul>
<li>现在的项目，大部分都是前后端分离的，前后端最终也会分开部署，前端部署在服务器 192.168.150.200 上，端口 80，后端部署在 192.168.150.100上，端口 8080</li>
<li>我们打开浏览器直接访问前端工程，访问url：http://192.168.150.200/login.html</li>
<li>然后在该页面发起请求到服务端，而服务端所在地址不再是localhost，而是服务器的IP地址192.168.150.100，假设访问接口地址为：http://192.168.150.100:8080/login</li>
<li>那此时就存在跨域操作了，因为我们是在 http://192.168.150.200/login.html 这个页面上访问了http://192.168.150.100:8080/login 接口</li>
<li>此时如果服务器设置了一个Cookie，这个Cookie是不能使用的，因为Cookie无法跨域</li>
</ul>
<p>区分跨域的维度（三个维度有任何一个维度不同，那就是跨域操作）：</p>
<ul>
<li>协议</li>
<li>IP/协议</li>
<li>端口</li>
</ul>
<h3 id="session"><strong>session</strong></h3>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250626214434.png" alt="" loading="lazy"><br>
如果我们现在要基于 Session 来进行会话跟踪，浏览器在第一次请求服务器的时候，我们就可以直接在服务器当中来获取到会话对象Session。如果是第一次请求Session ，会话对象是不存在的，这个时候服务器会自动的创建一个会话对象Session 。而每一个会话对象Session ，它都有一个ID（示意图中Session后面括号中的1，就表示ID），我们称之为 Session 的ID。<br>
接下来，服务器端在给浏览器响应数据的时候，它会将 Session 的 ID 通过 Cookie 响应给浏览器。其实在响应头当中增加了一个 Set-Cookie 响应头。这个  Set-Cookie  响应头对应的值是不是cookie？ cookie 的名字是固定的 JSESSIONID 代表的服务器端会话对象 Session 的 ID。浏览器会自动识别这个响应头，然后自动将Cookie存储在浏览器本地。<br>
接下来，在后续的每一次请求当中，都会将 Cookie 的数据获取出来，并且携带到服务端。接下来服务器拿到JSESSIONID这个 Cookie 的值，也就是 Session 的ID。拿到 ID 之后，就会从众多的 Session 当中来找到当前请求对应的会话对象Session。<br>
代码测试：</p>
<pre><code class="language-java">@Slf4j
@RestController
public class SessionController {

    @GetMapping(&quot;/s1&quot;)
    public Result session1(HttpSession session){
        log.info(&quot;HttpSession-s1: {}&quot;, session.hashCode());

        session.setAttribute(&quot;loginUser&quot;, &quot;tom&quot;); //往session中存储数据
        return Result.success();
    }

    @GetMapping(&quot;/s2&quot;)
    public Result session2(HttpServletRequest request){
        HttpSession session = request.getSession();
        log.info(&quot;HttpSession-s2: {}&quot;, session.hashCode());

        Object loginUser = session.getAttribute(&quot;loginUser&quot;); //从session中获取数据
        log.info(&quot;loginUser: {}&quot;, loginUser);
        return Result.success(loginUser);
    }
}
</code></pre>
<p>A. 访问 s1 接口，http://localhost:8080/s1<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250626215945.png" alt="" loading="lazy"><br>
B. 访问 s2 接口，http://localhost:8080/s2<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250626220006.png" alt="" loading="lazy"><br>
接下来，在后续的每次请求时，都会将Cookie的值，携带到服务端，那服务端呢，接收到Cookie之后，会自动的根据JSESSIONID的值，找到对应的会话对象Session。</p>
<ul>
<li>优点：Session是存储在服务端的，安全</li>
<li>缺点：
<ul>
<li>服务器集群环境下无法直接使用Session</li>
<li>移动端APP(Android、IOS)中无法使用Cookie</li>
<li>用户可以自己禁用Cookie</li>
<li>Cookie不能跨域</li>
</ul>
</li>
</ul>
<p>PS：Session 底层是基于Cookie实现的会话跟踪，如果Cookie不可用，则该方案，也就失效了。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250626220223.png" alt="" loading="lazy"><br>
服务器集群环境为何无法使用Session？</p>
<ul>
<li>首先第一点，我们现在所开发的项目，一般都不会只部署在一台服务器上，因为一台服务器会存在一个很大的问题，就是单点故障。所谓单点故障，指的就是一旦这台服务器挂了，整个应用都没法访问了。</li>
<li>所以在现在的企业项目开发当中，最终部署的时候都是以集群的形式来进行部署，也就是同一个项目它会部署多份。比如这个项目我们现在就部署了 3 份。</li>
<li>而用户在访问的时候，到底访问这三台其中的哪一台？其实用户在访问的时候，他会访问一台前置的服务器，我们叫负载均衡服务器，我们在后面项目当中会详细讲解。目前大家先有一个印象负载均衡服务器，它的作用就是将前端发起的请求均匀的分发给后面的这三台服务器。</li>
<li>此时假如我们通过 session 来进行会话跟踪，可能就会存在这样一个问题。用户打开浏览器要进行登录操作，此时会发起登录请求。登录请求到达负载均衡服务器，将这个请求转给了第一台 Tomcat 服务器，获取到会话对象session。获取到会话对象 session 之后，要给浏览器响应数据，最终在给浏览器响应数据的时候，就会携带这么一个 cookie 的名字，就是 JSESSIONID。此时假如又执行了一次查询操作，要查询部门的数据。这次请求到达负载均衡服务器之后，负载均衡服务器将这次请求转给了第二台 Tomcat 服务器，此时他就要到第二台 Tomcat 服务器当中。根据JSESSIONID 也就是对应的 session 的 ID 值，要找对应的 session 会话对象。我想请问在第二台服务器当中有没有这个ID的会话对象 Session， 是没有的。</li>
</ul>
<h3 id="令牌技术"><strong>令牌技术</strong></h3>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250627150536.png" alt="" loading="lazy"><br>
如果通过令牌技术来跟踪会话，我们就可以在浏览器发起请求。在请求登录接口的时候，如果登录成功，我就可以生成一个令牌，令牌就是用户的合法身份凭证。接下来我在响应数据的时候，我就可以直接将令牌响应给前端。<br>
接下来我们在前端程序当中接收到令牌之后，就需要将这个令牌存储起来。这个存储可以存储在 cookie 当中，也可以存储在其他的存储空间(比如：localStorage)当中。<br>
接下来，在后续的每一次请求当中，都需要将令牌携带到服务端。携带到服务端之后，接下来我们就需要来校验令牌的有效性。如果令牌是有效的，就说明用户已经执行了登录操作，如果令牌是无效的，就说明用户之前并未执行登录操作。<br>
此时，如果是在同一次会话的多次请求之间，我们想共享数据，我们就可以将共享的数据存储在令牌当中就可以了。</p>
<ul>
<li>优点：
<ul>
<li>支持PC端、移动端</li>
<li>解决集群环境下的认证问题</li>
<li>减轻服务器的存储压力（无需在服务器端存储）</li>
</ul>
</li>
<li>缺点：需要自己实现（包括令牌的生成、令牌的传递、令牌的校验）</li>
</ul>
<h2 id="jwt令牌"><strong>JWT令牌</strong></h2>
<h3 id="介绍"><strong>介绍</strong></h3>
<p>JWT全称 JSON Web Token  （官网：https://jwt.io/），定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。</p>
<ul>
<li>简洁：是指jwt就是一个简单的字符串。可以在请求参数或者是请求头当中直接传递。</li>
<li>自包含：指的是jwt令牌，看似是一个随机的字符串，但是我们是可以根据自身的需求在jwt令牌中存储自定义的数据内容。如：可以直接在jwt令牌中存储用户的相关信息。</li>
<li>简单来讲，jwt就是将原始的json数据格式进行了安全的封装，这样就可以直接基于jwt在通信双方安全的进行信息传输了。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250627150953.png" alt="" loading="lazy"><br>
JWT的组成： （JWT令牌由三个部分组成，三个部分之间使用英文的点来分割）</p>
<ul>
<li>第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{&quot;alg&quot;:&quot;HS256&quot;,&quot;type&quot;:&quot;JWT&quot;}</li>
<li>第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{&quot;id&quot;:&quot;1&quot;,&quot;username&quot;:&quot;Tom&quot;}</li>
<li>第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。</li>
</ul>
<p>JWT是如何将原始的JSON格式数据，转变为字符串的呢？</p>
<ul>
<li>其实在生成JWT令牌时，会对JSON格式的数据进行一次编码：进行base64编码</li>
<li>Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符号，那就是等号。等号它是一个补位的符号</li>
<li>需要注意的是Base64是编码方式，而不是加密方式。</li>
</ul>
<h3 id="生成和校验"><strong>生成和校验</strong></h3>
<p>首先我们先来实现JWT令牌的生成。要想使用JWT令牌，需要先引入JWT的依赖：</p>
<pre><code class="language-xml">&lt;!-- JWT依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
    &lt;version&gt;0.9.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>生成JWT令牌时，需要指定生成令牌签名时签名算法以及密钥。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250627161336.png" alt="" loading="lazy"></p>
<pre><code class="language-java">public class JwtTest {

    @Test
    public void testGenerateJwt(){
        Map&lt;String, Object&gt; dataMap = new HashMap&lt;String, Object&gt;();
        dataMap.put(&quot;name&quot;, &quot;ys&quot;);
        dataMap.put(&quot;age&quot;, 20);
        //指定加密算法以及密钥
        String jwt=Jwts.builder().signWith(SignatureAlgorithm.HS256,&quot;eXM=&quot;)
                .addClaims(dataMap)//添加自定义信息
                .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000))//设置过期时间
                .compact();
        //eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoieXMiLCJhZ2UiOjIwLCJleHAiOjE3NTEwMTUwNDh9.JkYK4rEWbAiNtA69OeB2Li71t_yIFsqDkRQqzpas97o
        System.out.println(jwt);
    }
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250627161211.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">    @Test
    public void testParseJwt(){
        String token=&quot;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoieXMiLCJhZ2UiOjIwLCJleHAiOjE3NTEwMTUwNDh9.JkYK4rEWbAiNtA69OeB2Li71t_yIFsqDkRQqzpas97o&quot;;
        Claims claims=Jwts.parser().setSigningKey(&quot;eXM=&quot;)//指定密钥
                .parseClaimsJws(token)//解析令牌
                .getBody();//获取自定义信息
        System.out.println(claims);
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250627161458.png" alt="" loading="lazy"></figure>
<h3 id="登录时下发令牌"><strong>登录时下发令牌</strong></h3>
<ol>
<li>引入JWT工具类：在项目工程下创建 com.ys.util 包，并把提供JWT工具类复制到该包下</li>
</ol>
<pre><code class="language-java">public class JwtUtils {
    private static String signKey = &quot;SVRIRUlNQQ==&quot;;//密钥
    private static Long expire = 43200000L;//12个小时

    /**
     * 生成JWT令牌
     * @return
     */
    public static String generateJwt(Map&lt;String,Object&gt; claims){
        String jwt = Jwts.builder()
                .addClaims(claims)
                .signWith(SignatureAlgorithm.HS256, signKey)
                .setExpiration(new Date(System.currentTimeMillis() + expire))
                .compact();
        return jwt;
    }

    /**
     * 解析JWT令牌
     * @param jwt JWT令牌
     * @return JWT第二部分负载 payload 中存储的内容
     */
    public static Claims parseJWT(String jwt){
        Claims claims = Jwts.parser()
                .setSigningKey(signKey)
                .parseClaimsJws(jwt)
                .getBody();
        return claims;
    }
}
</code></pre>
<ol start="2">
<li>完善 EmpServiceImpl中的 login 方法逻辑， 登录成功，生成JWT令牌并返回</li>
</ol>
<pre><code class="language-java">@Override
    public LoginInfo login(Emp emp) {
        //根据用户名和密码查询员工信息
        Emp e=empMapper.selectByUsernameAndPassword(emp);
        //判断是否存在这个员工
        if(e!=null){
            log.info(&quot;登录成功，员工信息为：{}&quot;,e);
            Map&lt;String,Object&gt; claims=new HashMap&lt;&gt;();
            claims.put(&quot;id&quot;,e.getId());
            claims.put(&quot;username&quot;,e.getUsername());
            String jwt=JwtUtils.generateJwt(claims);
            return new LoginInfo(e.getId(),e.getUsername(),e.getName(),jwt);
        }
        //不存在返回null
        return null;
    }
</code></pre>
<p>在当前案例中，JWT令牌存储在浏览器的本地存储空间 localstorage中了。 localstorage 是浏览器的本地存储，在移动端也是支持的。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250627164426.png" alt="" loading="lazy"><br>
我们在发起一个查询班级数据的请求，此时我们可以看到在请求头中包含一个token(JWT令牌)，后续的每一次请求当中，都会将这个令牌携带到服务端。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250627164731.png" alt="" loading="lazy"></p>
<h1 id="过滤器filter"><strong>过滤器filter</strong></h1>
<h2 id="快速入门"><strong>快速入门</strong></h2>
<ul>
<li>Filter表示过滤器，是 JavaWeb三大组件(Servlet、Filter、Listener)之一。</li>
<li>过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能
<ul>
<li>使用了过滤器之后，要想访问web服务器上的资源，必须先经过滤器，过滤器处理完毕之后，才可以访问对应的资源。</li>
</ul>
</li>
<li>过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250627165143.png" alt="" loading="lazy"><br>
下面我们通过Filter快速入门程序掌握过滤器的基本使用操作：</p>
<ul>
<li>第1步，定义过滤器 ：1.定义一个类，实现 Filter 接口，并重写其所有方法。</li>
<li>第2步，配置过滤器：Filter类上加 @WebFilter 注解，配置拦截资源的路径。引导类上加 @ServletComponentScan 开启Servlet组件支持。</li>
</ul>
<p>1). 定义过滤器</p>
<pre><code class="language-java">public class DemoFilter implements Filter {
    //初始化方法, web服务器启动, 创建Filter实例时调用, 只调用一次
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println(&quot;init ...&quot;);
    }

    //拦截到请求时,调用该方法,可以调用多次
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException {
        System.out.println(&quot;拦截到了请求...&quot;);
    }

    //销毁方法, web服务器关闭时调用, 只调用一次
    public void destroy() {
        System.out.println(&quot;destroy ... &quot;);
    }
}
</code></pre>
<p>2). 配置过滤器<br>
在定义完Filter之后，Filter其实并不会生效，还需要完成Filter的配置，Filter的配置非常简单，只需要在Filter类上添加一个注解：@WebFilter，并指定属性urlPatterns，通过这个属性指定过滤器要拦截哪些请求。</p>
<pre><code class="language-java">@WebFilter(urlPatterns = &quot;/*&quot;) //配置过滤器要拦截的请求路径（ /* 表示拦截浏览器的所有请求 ）
public class DemoFilter implements Filter {
    //初始化方法, web服务器启动, 创建Filter实例时调用, 只调用一次
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println(&quot;init ...&quot;);
    }

    //拦截到请求时,调用该方法,可以调用多次
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException {
        System.out.println(&quot;拦截到了请求...&quot;);
    }

    //销毁方法, web服务器关闭时调用, 只调用一次
    public void destroy() {
        System.out.println(&quot;destroy ... &quot;);
    }
}
</code></pre>
<p>当我们在Filter类上面加了@WebFilter注解之后，接下来我们还需要在启动类上面加上一个注解@ServletComponentScan，通过这个@ServletComponentScan注解来开启SpringBoot项目对于Servlet组件的支持。</p>
<pre><code class="language-java">@ServletComponentScan//开启了SpringBoot对Servlet组件的支持
@SpringBootApplication
public class TliasWebManagementApplication {

    public static void main(String[] args) {
        SpringApplication.run(TliasWebManagementApplication.class, args);
    }

}
</code></pre>
<p>注意事项：在过滤器Filter中，如果不执行放行操作，将无法访问后面的资源。 放行操作：chain.doFilter(request, response);</p>
<h2 id="登录校验过滤器"><strong>登录校验过滤器</strong></h2>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250627175556.png" alt="" loading="lazy"></figure>
<ol>
<li>获取请求url</li>
<li>判断请求url中是否包含login，如果包含，说明是登录操作，放行</li>
<li>获取请求头中的令牌（token）</li>
<li>判断令牌是否存在，如果不存在，响应 401</li>
<li>解析token，如果解析失败，响应 401</li>
<li>放行</li>
</ol>
<pre><code class="language-java">@Slf4j
@WebFilter(urlPatterns = &quot;/*&quot;)
public class TokenFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        //1.获取请求路径（获取到的ServletRequest实际是HttpServletRequest）
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        String requestURI = request.getRequestURI();// /emp/login
        //2.是否是登录请求（如果包含login，说明是登录操作，放行
        if (requestURI.contains(&quot;/login&quot;)) {
            log.info(&quot;登录请求，放行&quot;);
            filterChain.doFilter(request, response);
            return;
        }
        //3.获取请求头中的token
        String token=request.getHeader(&quot;token&quot;);
        //4. 判断令牌是否存在，如果不存在，响应 401
        if(token==null||token.isEmpty()){
            log.info(&quot;令牌为空&quot;);
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);//401
            return;
        }
        //5. 解析token，如果解析失败，响应 401
        try {
            JwtUtils.parseJWT(token);
        } catch (Exception e) {
            log.info(&quot;令牌非法&quot;);
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);//401
            return;
        }
        //6. 放行
        log.info(&quot;令牌合法，放行&quot;);
        filterChain.doFilter(request, response);
    }
}
</code></pre>
<h2 id="filter详解"><strong>Filter详解</strong></h2>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250627181820.png" alt="" loading="lazy"><br>
过滤器当中我们拦截到了请求之后，如果希望继续访问后面的web资源，就要执行放行操作，放行就是调用 FilterChain对象当中的doFilter()方法，在调用doFilter()这个方法之前所编写的代码属于放行之前的逻辑。<br>
在放行后访问完 web 资源之后还会回到过滤器当中，回到过滤器之后如有需求还可以执行放行之后的逻辑，放行之后的逻辑我们写在doFilter()这行代码之后。</p>
<h3 id="拦截路径"><strong>拦截路径</strong></h3>
<p>执行流程我们搞清楚之后，接下来再来介绍一下过滤器的拦截路径，Filter可以根据需求，配置不同的拦截资源路径：</p>
<table>
<thead>
<tr>
<th>拦截路径</th>
<th>urlPatterns值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>拦截具体路径</td>
<td>/login</td>
<td>只有访问 /login 路径时，才会被拦截</td>
</tr>
<tr>
<td>目录拦截</td>
<td>/emps/*</td>
<td>访问/emps下的所有资源，都会被拦截</td>
</tr>
<tr>
<td>拦截所有</td>
<td>/*</td>
<td>访问所有资源，都会被拦截</td>
</tr>
</tbody>
</table>
<h3 id="过滤器链"><strong>过滤器链</strong></h3>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250627182210.png" alt="" loading="lazy"><br>
比如：在我们web服务器当中，定义了两个过滤器，这两个过滤器就形成了一个过滤器链。而这个链上的过滤器在执行的时候会一个一个的执行，会先执行第一个Filter，放行之后再来执行第二个Filter，如果执行到了最后一个过滤器放行之后，才会访问对应的web资源。访问完web资源之后，按照我们刚才所介绍的过滤器的执行流程，还会回到过滤器当中来执行过滤器放行后的逻辑，而在执行放行后的逻辑的时候，顺序是反着的。先要执行过滤器2放行之后的逻辑，再来执行过滤器1放行之后的逻辑，最后在给浏览器响应数据。<br>
过滤器链FilterChain上过滤器的执行顺序：注解配置的Filter，优先级是按照过滤器类名（字符串）的自然排序。 比如：</p>
<ul>
<li>AbcFilter</li>
<li>DemoFilter</li>
</ul>
<p>这两个过滤器来说，AbcFilter 会先执行，DemoFilter会后执行。</p>
<h1 id="拦截器interceptor"><strong>拦截器Interceptor</strong></h1>
<h2 id="快速入门-2"><strong>快速入门</strong></h2>
<ul>
<li>是一种动态拦截方法调用的机制，类似于过滤器。</li>
<li>拦截器是Spring框架中提供的，用来动态拦截控制器方法的执行。</li>
<li>拦截器的作用：拦截请求，在指定方法调用前后，根据业务需要执行预先设定的代码。</li>
</ul>
<p>在拦截器当中，我们通常也是做一些通用性的操作，比如：我们可以通过拦截器来拦截前端发起的请求，将登录校验的逻辑全部编写在拦截器当中。在校验的过程当中，如发现用户登录了(携带JWT令牌且是合法令牌)，就可以直接放行，去访问spring当中的资源。如果校验时发现并没有登录或是非法令牌，就可以直接给前端响应未登录的错误信息。</p>
<p>下面我们通过快速入门程序，来学习下拦截器的基本使用。拦截器的使用步骤和过滤器类似，也分为两步：</p>
<ol>
<li>定义拦截器</li>
<li>注册配置拦截器</li>
</ol>
<p>1). 自定义拦截器<br>
实现HandlerInterceptor接口，并重写其所有方法</p>
<pre><code class="language-java">@Slf4j
@Component
public class DemoInterceptor implements HandlerInterceptor {
    //目标资源方法执行前执行。 返回true：放行    返回false：不放行
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        log.info(&quot;preHandle ....&quot;);

        return true; //true表示放行
    }

    //目标资源方法执行后执行
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        log.info(&quot;postHandle ... &quot;);
    }

    //视图渲染完毕后执行，最后执行
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        log.info(&quot;afterCompletion .... &quot;);
    }
}
</code></pre>
<p>2). 注册配置拦截器<br>
在 com.ys下创建一个包，然后创建一个配置类 WebConfig， 实现 WebMvcConfigurer 接口，并重写 addInterceptors 方法</p>
<pre><code class="language-java">@Configuration//配置类，注释里包含了component
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private DemoInterceptor demoInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(demoInterceptor).addPathPatterns(&quot;/**&quot;);//拦截所有请求
    }
}
</code></pre>
<h2 id="令牌校验"><strong>令牌校验</strong></h2>
<p>1). TokenInterceptor<br>
在 com.ys.interceptor 包下创建 TokenInterceptor</p>
<pre><code class="language-java">@Component
@Slf4j
public class TokenInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //1.获取请求路径
        String requestURI = request.getRequestURI();// /emp/login
        //2.是否是登录请求（如果包含login，说明是登录操作，放行
        if (requestURI.contains(&quot;/login&quot;)) {
            log.info(&quot;登录请求，放行&quot;);
            return true;
        }
        //3.获取请求头中的token
        String token=request.getHeader(&quot;token&quot;);
        //4. 判断令牌是否存在，如果不存在，响应 401
        if(token==null||token.isEmpty()){
            log.info(&quot;令牌为空&quot;);
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);//401
            return false;
        }
        //5. 解析token，如果解析失败，响应 401
        try {
            JwtUtils.parseJWT(token);
        } catch (Exception e) {
            log.info(&quot;令牌非法&quot;);
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);//401
            return false;
        }
        //6. 放行
        log.info(&quot;令牌合法，放行&quot;);
        return true;
    }
}
</code></pre>
<p>2). 配置拦截器</p>
<pre><code class="language-java">@Configuration//配置类，注释里包含了component
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private DemoInterceptor demoInterceptor;

    @Autowired
    private TokenInterceptor tokenInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(tokenInterceptor).addPathPatterns(&quot;/**&quot;);//拦截所有请求
    }
}
</code></pre>
<h2 id="拦截路径-2"><strong>拦截路径</strong></h2>
<p>首先我们先来看拦截器的拦截路径的配置，在注册配置拦截器的时候，我们要指定拦截器的拦截路径，通过addPathPatterns(&quot;要拦截路径&quot;)方法，就可以指定要拦截哪些资源。<br>
在入门程序中我们配置的是/**，表示拦截所有资源，而在配置拦截器时，不仅可以指定要拦截哪些资源，还可以指定不拦截哪些资源，只需要调用excludePathPatterns(&quot;不拦截路径&quot;)方法，指定哪些资源不需要拦截。</p>
<pre><code class="language-java">@Configuration//配置类，注释里包含了component
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private DemoInterceptor demoInterceptor;

    @Autowired
    private TokenInterceptor tokenInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(tokenInterceptor).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/login&quot;);
    }
}
</code></pre>
<table>
<thead>
<tr>
<th>拦截路径</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>/*</td>
<td>一级路径</td>
<td>能匹配/depts，/emps，/login，不能匹配 /depts/1</td>
</tr>
<tr>
<td>/**</td>
<td>任意级路径</td>
<td>能匹配/depts，/depts/1，/depts/1/2</td>
</tr>
<tr>
<td>/depts/*</td>
<td>/depts下的一级路径</td>
<td>能匹配/depts/1，不能匹配/depts/1/2，/depts</td>
</tr>
<tr>
<td>/depts/**</td>
<td>/depts下的任意级路径</td>
<td>能匹配/depts，/depts/1，/depts/1/2，不能匹配/emps/1</td>
</tr>
</tbody>
</table>
<h2 id="执行流程"><strong>执行流程</strong></h2>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250627212758.png" alt="" loading="lazy"></figure>
<ul>
<li>当我们打开浏览器来访问部署在web服务器当中的web应用时，此时我们所定义的过滤器会拦截到这次请求。拦截到这次请求之后，它会先执行放行前的逻辑，然后再执行放行操作。而由于我们当前是基于springboot开发的，所以放行之后是进入到了spring的环境当中，也就是要来访问我们所定义的controller当中的接口方法。</li>
<li>Tomcat并不识别所编写的Controller程序，但是它识别Servlet程序，所以在Spring的Web环境中提供了一个非常核心的Servlet：DispatcherServlet（前端控制器），所有请求都会先进行到DispatcherServlet，再将请求转给Controller。</li>
<li>当我们定义了拦截器后，会在执行Controller的方法之前，请求被拦截器拦截住。执行preHandle()方法，这个方法执行完成后需要返回一个布尔类型的值，如果返回true，就表示放行本次操作，才会继续访问controller中的方法；如果返回false，则不会放行（controller中的方法也不会执行）。</li>
<li>在controller当中的方法执行完毕之后，再回过来执行postHandle()这个方法以及afterCompletion() 方法，然后再返回给DispatcherServlet，最终再来执行过滤器当中放行后的这一部分逻辑的逻辑。执行完毕之后，最终给浏览器响应数据。</li>
</ul>
<p>以上就是拦截器的执行流程。通过执行流程分析，大家应该已经清楚了过滤器和拦截器之间的区别，其实它们之间的区别主要是两点：</p>
<ul>
<li>接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口。</li>
<li>拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[删改员工与统计]]></title>
        <id>https://yyss1014.github.io/post/shan-gai-yuan-gong-yu-tong-ji/</id>
        <link href="https://yyss1014.github.io/post/shan-gai-yuan-gong-yu-tong-ji/">
        </link>
        <updated>2025-06-19T12:59:50.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%88%A0%E9%99%A4%E5%91%98%E5%B7%A5"><strong>删除员工</strong></a>
<ul>
<li><a href="#%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91"><strong>功能开发</strong></a>
<ul>
<li><a href="#controller%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0"><strong>Controller接收参数</strong></a></li>
<li><a href="#service"><strong>Service</strong></a></li>
<li><a href="#mapper"><strong>Mapper</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BF%AE%E6%94%B9%E5%91%98%E5%B7%A5"><strong>修改员工</strong></a>
<ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E5%9B%9E%E6%98%BE"><strong>查询回显</strong></a>
<ul>
<li><a href="#resultmap"><strong>resultMap</strong></a></li>
</ul>
</li>
<li><a href="#%E4%BF%AE%E6%94%B9%E5%91%98%E5%B7%A5-2"><strong>修改员工</strong></a>
<ul>
<li><a href="#set%E6%A0%87%E7%AD%BE"><strong>set标签</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><strong>异常处理</strong></a>
<ul>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><strong>解决方案</strong></a></li>
<li><a href="#%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8"><strong>全局异常处理器</strong></a></li>
</ul>
</li>
<li><a href="#%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF%E7%BB%9F%E8%AE%A1"><strong>员工信息统计</strong></a>
<ul>
<li><a href="#%E8%81%8C%E4%BD%8D%E7%BB%9F%E8%AE%A1"><strong>职位统计</strong></a>
<ul>
<li><a href="#case%E5%87%BD%E6%95%B0"><strong>case函数</strong></a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><strong>代码实现</strong></a></li>
</ul>
</li>
<li><a href="#%E6%80%A7%E5%88%AB%E7%BB%9F%E8%AE%A1"><strong>性别统计</strong></a>
<ul>
<li><a href="#if%E5%87%BD%E6%95%B0"><strong>if函数</strong></a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><strong>代码实现</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="删除员工"><strong>删除员工</strong></h1>
<p>请求路径：/emps<br>
请求方式：DELETE<br>
接口描述：该接口用于批量删除员工的数据信息<br>
请求参数：</p>
<ul>
<li>参数格式：查询参数</li>
<li>请求参数样例：/emps?ids=1,2,3</li>
</ul>
<p>响应参数</p>
<ul>
<li>参数格式：application/json</li>
<li>响应数据样例：</li>
</ul>
<pre><code class="language-json">{
    &quot;code&quot;:1,
    &quot;msg&quot;:&quot;success&quot;,
    &quot;data&quot;:null
}
</code></pre>
<h2 id="功能开发"><strong>功能开发</strong></h2>
<h3 id="controller接收参数"><strong>Controller接收参数</strong></h3>
<p>在 EmpController 中增加如下方法 delete ，来执行批量删除员工的操作。<br>
方式一：在Controller方法中通过数组来接收<br>
多个参数，默认可以将其封装到一个数组中，需要保证前端传递的参数名 与 方法形参名称保持一致。</p>
<pre><code class="language-java">@DeleteMapping
    public Result delete(Integer[] ids) {
        log.info(&quot;删除员工：{}&quot;, Arrays.toString(ids));
        return Result.success();
    }
</code></pre>
<p>方式二：在Controller方法中通过集合来接收<br>
也可以将其封装到一个List<Integer> 集合中，如果要将其封装到一个集合中，需要在集合这样的复杂类型前面加上 @RequestParam 注解。</p>
<pre><code class="language-java">@DeleteMapping
    public Result delete(@RequestParam List&lt;Integer&gt; ids) {
        log.info(&quot;删除员工：{}&quot;, ids);
        empService.delete(ids);
        return Result.success();
    }
</code></pre>
<h3 id="service"><strong>Service</strong></h3>
<pre><code class="language-java">@Transactional(rollbackFor = Exception.class)
    @Override
    public void delete(List&lt;Integer&gt; ids) {
        //1.删除员工的基本信息
        empMapper.deleteByIds(ids);
        //2.删除员工的工作经历信息
        empExprMapper.deleteByEmpIds(ids);

    }

    }
</code></pre>
<h3 id="mapper"><strong>Mapper</strong></h3>
<p>在 EmpMapper.xml 配置文件中, 配置对应的SQL语句</p>
<pre><code class="language-xml">&lt;delete id=&quot;deleteByIds&quot;&gt;
       delete from emp where id in
       &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
           #{id}
       &lt;/foreach&gt;
   &lt;/delete&gt;
</code></pre>
<p>在 EmpExprMapper.xml 配置文件中, 配置对应的SQL语句</p>
<pre><code class="language-xml">&lt;delete id=&quot;deleteByEmpIds&quot;&gt;
        delete from emp_expr where emp_id in
        &lt;foreach collection=&quot;empIds&quot; item=&quot;empId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
            #{empId}
        &lt;/foreach&gt;
    &lt;/delete&gt;
</code></pre>
<h1 id="修改员工"><strong>修改员工</strong></h1>
<h2 id="查询回显"><strong>查询回显</strong></h2>
<p>请求路径：/emps/{id}<br>
请求方式：GET<br>
接口描述：该接口用于根据主键ID查询员工的信息<br>
参数格式：路径参数<br>
请求参数样例：/emps/1<br>
响应数据样例：</p>
<pre><code class="language-json">{
  &quot;code&quot;: 1,
  &quot;msg&quot;: &quot;success&quot;,
  &quot;data&quot;: {
    &quot;id&quot;: 2,
    &quot;username&quot;: &quot;zhangwuji&quot;,
    &quot;name&quot;: &quot;张无忌&quot;,
    &quot;gender&quot;: 1,
    &quot;image&quot;: &quot;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-53B.jpg&quot;,
    &quot;job&quot;: 2,
    &quot;salary&quot;: 8000,
    &quot;entryDate&quot;: &quot;2015-01-01&quot;,
    &quot;deptId&quot;: 2,
    &quot;createTime&quot;: &quot;2022-09-01T23:06:30&quot;,
    &quot;updateTime&quot;: &quot;2022-09-02T00:29:04&quot;,
    &quot;exprList&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;begin&quot;: &quot;2012-07-01&quot;,
        &quot;end&quot;: &quot;2019-03-03&quot;
        &quot;company&quot;: &quot;百度科技股份有限公司&quot;
        &quot;job&quot;: &quot;java开发&quot;,
        &quot;empId&quot;: 2
      },
      {
        &quot;id&quot;: 2,
        &quot;begin&quot;: &quot;2019-3-15&quot;,
        &quot;end&quot;: &quot;2023-03-01&quot;
        &quot;company&quot;: &quot;阿里巴巴科技股份有限公司&quot;
        &quot;job&quot;: &quot;架构师&quot;,
        &quot;empId&quot;: 2
      }
    ]
  }
}
</code></pre>
<h3 id="resultmap"><strong>resultMap</strong></h3>
<p>1). EmpController 添加 getInfo 用来根据ID查询员工数据，用于页面回显</p>
<pre><code class="language-java">@GetMapping(&quot;/{id}&quot;)
    public Result getInfo(@PathVariable Integer id) {
        log.info(&quot;根据ID查询员工信息：{}&quot;,id);
        Emp emp=empService.getInfo(id);
        return Result.success(emp);
    }
</code></pre>
<p>2). EmpServiceImpl 实现类中实现 <code>getInfo</code> 方法</p>
<pre><code class="language-java">@Override
    public Emp getInfo(Integer id) {
        return empMapper.getById(id);
    }
</code></pre>
<p>3). EmpMapper 接口中增加 getById 方法</p>
<pre><code class="language-java">Emp getById(Integer id);
</code></pre>
<p>4). EmpMapper.xml 配置文件中定义对应的SQL</p>
<pre><code class="language-xml">&lt;!--自定义结果集ResultMap--&gt;
    &lt;resultMap id=&quot;empResultMap&quot; type=&quot;com.ys.pojo.Emp&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;username&quot; property=&quot;username&quot; /&gt;
        &lt;result column=&quot;password&quot; property=&quot;password&quot; /&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;
        &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt;
        &lt;result column=&quot;phone&quot; property=&quot;phone&quot; /&gt;
        &lt;result column=&quot;job&quot; property=&quot;job&quot; /&gt;
        &lt;result column=&quot;salary&quot; property=&quot;salary&quot; /&gt;
        &lt;result column=&quot;image&quot; property=&quot;image&quot; /&gt;
        &lt;result column=&quot;entry_date&quot; property=&quot;entryDate&quot; /&gt;
        &lt;result column=&quot;dept_id&quot; property=&quot;deptId&quot; /&gt;
        &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; /&gt;
        &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot; /&gt;

        &lt;!--封装exprList--&gt;
        &lt;collection property=&quot;exprList&quot; ofType=&quot;com.ys.pojo.EmpExpr&quot;&gt;
            &lt;id column=&quot;ee_id&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;ee_company&quot; property=&quot;company&quot;/&gt;
            &lt;result column=&quot;ee_job&quot; property=&quot;job&quot;/&gt;
            &lt;result column=&quot;ee_begin&quot; property=&quot;begin&quot;/&gt;
            &lt;result column=&quot;ee_end&quot; property=&quot;end&quot;/&gt;
            &lt;result column=&quot;ee_empid&quot; property=&quot;empId&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
&lt;!--    根据员工ID查询基本信息与工作经历信息--&gt;
    &lt;select id=&quot;getById&quot; resultMap=&quot;empResultMap&quot;&gt;
        select
            e.*,
            ee.id ee_id,
            ee.emp_id ee_empid,
            ee.begin ee_begin,
            ee.end ee_end,
            ee.company ee_company,
            ee.job ee_job
        from emp e left join emp_expr ee on e.id = ee.emp_id where e.id=#{id};
    &lt;/select&gt;
</code></pre>
<h2 id="修改员工-2"><strong>修改员工</strong></h2>
<p>请求路径：/emps<br>
请求方式：PUT<br>
参数格式：application/json<br>
请求数据样例：</p>
<pre><code class="language-json">{
    &quot;id&quot;: 2,
    &quot;username&quot;: &quot;zhangwuji&quot;,
    &quot;password&quot;: &quot;123456&quot;,
    &quot;name&quot;: &quot;张无忌&quot;,
    &quot;gender&quot;: 1,
    &quot;image&quot;: &quot;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-53B.jpg&quot;,
    &quot;job&quot;: 2,
    &quot;salary&quot;: 8000,
    &quot;entryDate&quot;: &quot;2015-01-01&quot;,
    &quot;deptId&quot;: 2,
    &quot;createTime&quot;: &quot;2022-09-01T23:06:30&quot;,
    &quot;updateTime&quot;: &quot;2022-09-02T00:29:04&quot;,
    &quot;exprList&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;begin&quot;: &quot;2012-07-01&quot;,
        &quot;end&quot;: &quot;2015-06-20&quot;
        &quot;company&quot;: &quot;中软国际股份有限公司&quot;
        &quot;job&quot;: &quot;java开发&quot;,
        &quot;empId&quot;: 2
      },
      {
        &quot;id&quot;: 2,
        &quot;begin&quot;: &quot;2015-07-01&quot;,
        &quot;end&quot;: &quot;2019-03-03&quot;
        &quot;company&quot;: &quot;百度科技股份有限公司&quot;
        &quot;job&quot;: &quot;java开发&quot;,
        &quot;empId&quot;: 2
      },
      {
        &quot;id&quot;: 3,
        &quot;begin&quot;: &quot;2019-3-15&quot;,
        &quot;end&quot;: &quot;2023-03-01&quot;
        &quot;company&quot;: &quot;阿里巴巴科技股份有限公司&quot;
        &quot;job&quot;: &quot;架构师&quot;,
        &quot;empId&quot;: 2
      }
    ]
  }
</code></pre>
<p>参数格式：application/json<br>
响应数据样例：</p>
<pre><code class="language-json">{
  &quot;code&quot;:1,
  &quot;msg&quot;:&quot;success&quot;,
  &quot;data&quot;:null
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250624160855.png" alt="" loading="lazy"></figure>
<h3 id="set标签"><strong>set标签</strong></h3>
<p>自动生成set关键字，会自动删除更新字段多余的逗号。<br>
1). EmpController 增加 update 方法接收请求参数，响应数据</p>
<pre><code class="language-java">@PutMapping
    public Result update(@RequestBody Emp emp) {
        log.info(&quot;修改员工：{}&quot;,emp);
        empService.update(emp);
        return Result.success();
    }
</code></pre>
<p>2).  EmpServiceImpl实现类实现 update 方法</p>
<pre><code class="language-java">@Transactional(rollbackFor = {Exception.class})
    @Override
    public void update(Emp emp) {
        //1.修改员工的基本信息
        emp.setUpdateTime(LocalDateTime.now());
        empMapper.updateById(emp);
        //2.员工经历
        //先删除
        empExprMapper.deleteByEmpIds(Arrays.asList(emp.getId()));
        //再添加
        List&lt;EmpExpr&gt; exprList=emp.getExprList();
        if(!CollectionUtils.isEmpty(exprList)){
            exprList.forEach(expr-&gt;{
                expr.setEmpId(emp.getId());
            });
            empExprMapper.insertBatch(exprList);
        }
    }
</code></pre>
<p>3). EmpMapper 接口中增加 updateById 方法</p>
<pre><code class="language-java">void updateById(Emp emp);
</code></pre>
<p>4). EmpMapper.xml 配置文件中定义对应的SQL语句，基于动态SQL更新员工信息</p>
<pre><code class="language-xml">&lt;update id=&quot;updateById&quot;&gt;
        update emp
        &lt;set&gt;
            &lt;if test=&quot;username != null and username != ''&quot;&gt;username = #{username},&lt;/if&gt;
            &lt;if test=&quot;password != null and password != ''&quot;&gt;password = #{password},&lt;/if&gt;
            &lt;if test=&quot;name != null and name != ''&quot;&gt;name = #{name},&lt;/if&gt;
            &lt;if test=&quot;gender != null&quot;&gt;gender = #{gender},&lt;/if&gt;
            &lt;if test=&quot;phone != null and phone != ''&quot;&gt;phone = #{phone},&lt;/if&gt;
            &lt;if test=&quot;job != null&quot;&gt;job = #{job},&lt;/if&gt;
            &lt;if test=&quot;salary != null&quot;&gt;salary = #{salary},&lt;/if&gt;
            &lt;if test=&quot;image != null and image != ''&quot;&gt;image = #{image},&lt;/if&gt;
            &lt;if test=&quot;entryDate != null&quot;&gt;entry_date = #{entryDate},&lt;/if&gt;
            &lt;if test=&quot;deptId != null&quot;&gt;dept_id = #{deptId},&lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;update_time = #{updateTime},&lt;/if&gt;
        &lt;/set&gt;
        where id = #{id}
    &lt;/update&gt;
</code></pre>
<h1 id="异常处理"><strong>异常处理</strong></h1>
<p>当我们在修改部门数据的时候，如果输入一个在数据库表中已经存在的手机号，点击保存按钮之后，前端提示了错误信息，但是返回的结果并不是统一的响应结果，而是框架默认返回的错误结果 。<br>
当我们没有做任何的异常处理时，我们三层架构处理异常的方案：</p>
<ul>
<li>Mapper接口在操作数据库的时候出错了，此时异常会往上抛(谁调用Mapper就抛给谁)，会抛给service。</li>
<li>service 中也存在异常了，会抛给controller。</li>
<li>而在controller当中，我们也没有做任何的异常处理，所以最终异常会再往上抛。最终抛给框架之后，框架就会返回一个JSON格式的数据，里面封装的就是错误的信息，但是框架返回的JSON格式的数据并不符合我们的开发规范。</li>
</ul>
<h2 id="解决方案"><strong>解决方案</strong></h2>
<ul>
<li>方案一：在所有Controller的所有方法中进行try…catch处理<br>
缺点：代码臃肿（不推荐）<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250624171347.png" alt="" loading="lazy"></li>
<li>方案二：全局异常处理器<br>
好处：简单、优雅（推荐）<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250624171413.png" alt="" loading="lazy"></li>
</ul>
<h2 id="全局异常处理器"><strong>全局异常处理器</strong></h2>
<ul>
<li>定义全局异常处理器非常简单，就是定义一个类，在类上加上一个注解@RestControllerAdvice，加上这个注解就代表我们定义了一个全局异常处理器。</li>
<li>在全局异常处理器当中，需要定义一个方法来捕获异常，在这个方法上需要加上注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定我们要捕获的是哪一类型的异常。可以不指定value属性，按照异常类的继承关系从下往上匹配。</li>
</ul>
<pre><code class="language-java">@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler
    public Result handleException(Exception e){
        log.error(&quot;程序出错了~&quot;+e);
        return Result.error(&quot;出错了，请联系管理员&quot;);
    }

    @ExceptionHandler
    public Result handleDuplicateKeyException(DuplicateKeyException e){
        log.error(&quot;程序出错了~&quot;+e);
        String message = e.getMessage();
        int i=message.indexOf(&quot;Duplicate entry&quot;);
        String errMsg=message.substring(i);
        String[] arr=errMsg.split(&quot; &quot;);
        return Result.error(arr[2]+&quot;已存在&quot;);
    }
}
</code></pre>
<p>@RestControllerAdvice = @ControllerAdvice + @ResponseBody<br>
处理异常的方法返回值会转换为json后再响应给前端</p>
<h1 id="员工信息统计"><strong>员工信息统计</strong></h1>
<p>员工管理的增删改查功能我们已开发完成，接下来，我们再来完成员工信息统计的接口开发。  是基于现成的一些图形报表的组件开发的，比如：Echarts、HighCharts等。而报表的制作，主要是前端人员开发，引入对应的组件（比如：ECharts）即可。  服务端开发人员仅为其提供数据即可。<br>
官网：https://echarts.apache.org/zh/index.html</p>
<h2 id="职位统计"><strong>职位统计</strong></h2>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250624203029.png" alt="" loading="lazy"><br>
请求路径：/report/empJobData<br>
请求方式：GET<br>
接口描述：统计各个职位的员工人数<br>
响应参数格式：application/json</p>
<pre><code class="language-json">{
  &quot;code&quot;: 1,
  &quot;msg&quot;: &quot;success&quot;,
  &quot;data&quot;: {
    &quot;jobList&quot;: [&quot;教研主管&quot;,&quot;学工主管&quot;,&quot;其他&quot;,&quot;班主任&quot;,&quot;咨询师&quot;,&quot;讲师&quot;],
    &quot;dataList&quot;: [1,1,2,6,8,13]
  }
}
</code></pre>
<h3 id="case函数"><strong>case函数</strong></h3>
<pre><code class="language-sql">-- 统计每一种对应的人数
select count(*), job from emp group by job;
-- case函数：case 表达式 when val1 then result1 when val2 then result2 ...else...end
select
    (case job when 1 then '班主任'
        when 2 then '讲师'
        when 3 then '学工主管'
        when 4 then '教研主管'
        when 5 then '咨询师'
        else '其他'end) pos,
    count(*) num
from emp group by job order by num asc;
-- case函数：case when 条件表达式1 then result1 when 条件表达式2 then result2 ...else...end
select
    (case when job=1 then '班主任'
        when job=2 then '讲师'
        when job=3 then '学工主管'
        when job=4 then '教研主管'
        when job=5 then '咨询师'
        else '其他'end) pos,
    count(*) num
from emp group by job order by num asc;
</code></pre>
<h3 id="代码实现"><strong>代码实现</strong></h3>
<p>1). 定义封装结果对象JobOption<br>
在 com.ys.pojo 包中定义实体类 JobOption</p>
<pre><code class="language-java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class JobOption {
    private List jobList;
    private List dataList;
}
</code></pre>
<p>2). 定义ReportController，并添加方法。</p>
<pre><code class="language-java">@Slf4j
@RequestMapping(&quot;/report&quot;)
@RestController
public class ReportController {

    @Autowired
    private ReportService reportService;

    @GetMapping(&quot;/empJobData&quot;)
    public Result getEmpJobData(){
        log.info(&quot;统计员工人数&quot;);
        JobOption jobOption = reportService.getEmpJobData();
        return Result.success(jobOption);
    }
}
</code></pre>
<p>3). 定义ReportServiceImpl实现类，并实现方法</p>
<pre><code class="language-java@Service">public class ReportServiceImpl implements ReportService {

    @Autowired
    private EmpMapper empMapper;

    @Override
    public JobOption getEmpJobData() {
        List&lt;Map&lt;String,Object&gt;&gt; list = empMapper.countEmpJobData();
        List&lt;Object&gt; jobList=list.stream().map(dataMap-&gt;dataMap.get(&quot;pos&quot;)).toList();
        List&lt;Object&gt; dataList=list.stream().map(dataMap-&gt;dataMap.get(&quot;num&quot;)).toList();
        return new JobOption(jobList,dataList);

    }
}
</code></pre>
<p>4). 定义EmpMapper 接口</p>
<pre><code class="language-java">List&lt;Map&lt;String,Object&gt;&gt; countEmpJobData();
</code></pre>
<p>如果查询的记录往Map中封装，可以通过@MapKey注解指定返回的map中的唯一标识是那个字段。【也可以不指定】<br>
5). 定义EmpMapper.xml</p>
<pre><code class="language-xml">&lt;select id=&quot;countEmpJobData&quot; resultType=&quot;java.util.Map&quot;&gt;
        select
            (case when job=1 then '班主任'
                  when job=2 then '讲师'
                  when job=3 then '学工主管'
                  when job=4 then '教研主管'
                  when job=5 then '咨询师'
                  else '其他'end) pos,
            count(*) num
        from emp group by job order by num asc
    &lt;/select&gt;
</code></pre>
<h2 id="性别统计"><strong>性别统计</strong></h2>
<p>请求路径：/report/empGenderData<br>
请求方式：GET<br>
接口描述：统计员工性别信息<br>
响应参数格式：application/json</p>
<pre><code class="language-json">{
  &quot;code&quot;: 1,
  &quot;msg&quot;: &quot;success&quot;,
  &quot;data&quot;: [
    {&quot;name&quot;: &quot;男性员工&quot;,&quot;value&quot;: 5},
    {&quot;name&quot;: &quot;女性员工&quot;,&quot;value&quot;: 6}
  ]
}
</code></pre>
<h3 id="if函数"><strong>if函数</strong></h3>
<pre><code class="language-sql">-- if(条件,true_value,false_value)
select
    if(gender=1,'男性员工','女性员工') name,
    count(*) value
from emp group by gender;
</code></pre>
<p>ifnull函数语法：ifnull(expr, val1)    如果expr不为null，取自身，否则取val1</p>
<h3 id="代码实现-2"><strong>代码实现</strong></h3>
<p>1). 在ReportController，添加方法。</p>
<pre><code class="language-java">@GetMapping(&quot;/empGenderData&quot;)
    public Result getEmpGenderData(){
        log.info(&quot;统计员工信息&quot;);
        List&lt;Map&lt;String,Object&gt;&gt; genderList=reportService.getEmpGenderData();
        return Result.success(genderList);
    }
</code></pre>
<p>2). 在ReportServiceImpl实现类，实现方法</p>
<pre><code class="language-java">@Override
    public List&lt;Map&lt;String, Object&gt;&gt; getEmpGenderData() {
        return empMapper.countEmpGenderData();
    }
</code></pre>
<p>3). 定义EmpMapper 接口</p>
<pre><code class="language-java">List&lt;Map&lt;String,Object&gt;&gt; countEmpGenderData();
</code></pre>
<p>4). 定义EmpMapper.xml</p>
<pre><code class="language-xml">&lt;select id=&quot;countEmpGenderData&quot; resultType=&quot;java.util.Map&quot;&gt;
        select
            if(gender=1,'男性员工','女性员工') name,
            count(*) value
        from emp group by gender
    &lt;/select&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新增员工与上传]]></title>
        <id>https://yyss1014.github.io/post/xin-zeng-yuan-gong-yu-shang-chuan/</id>
        <link href="https://yyss1014.github.io/post/xin-zeng-yuan-gong-yu-shang-chuan/">
        </link>
        <updated>2025-06-18T08:30:18.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%96%B0%E5%A2%9E%E5%91%98%E5%B7%A5"><strong>新增员工</strong></a>
<ul>
<li><a href="#%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0"><strong>接口描述</strong></a></li>
<li><a href="#%E4%BF%9D%E5%AD%98%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF"><strong>保存员工信息</strong></a></li>
<li><a href="#%E6%89%B9%E9%87%8F%E4%BF%9D%E5%AD%98%E5%B7%A5%E4%BD%9C%E7%BB%8F%E5%8E%86"><strong>批量保存工作经历</strong></a></li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><strong>事务管理</strong></a>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D"><strong>介绍</strong></a></li>
<li><a href="#%E6%93%8D%E4%BD%9C"><strong>操作</strong></a></li>
<li><a href="#spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><strong>Spring事务管理</strong></a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E8%BF%9B%E9%98%B6"><strong>事务进阶</strong></a>
<ul>
<li><a href="#rollbackfor"><strong>rollbackFor</strong></a></li>
<li><a href="#propagation"><strong>propagation</strong></a></li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><strong>事务四大特性</strong></a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><strong>文件上传</strong></a>
<ul>
<li><a href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><strong>本地存储</strong></a></li>
<li><a href="#%E9%98%BF%E9%87%8C%E4%BA%91oss"><strong>阿里云OSS</strong></a>
<ul>
<li><a href="#%E5%85%A5%E9%97%A8"><strong>入门</strong></a></li>
<li><a href="#%E9%9B%86%E6%88%90"><strong>集成</strong></a></li>
</ul>
</li>
<li><a href="#%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96"><strong>功能优化</strong></a></li>
</ul>
</li>
</ul>
</p>
<h1 id="新增员工"><strong>新增员工</strong></h1>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250618163149.png" alt="" loading="lazy"><br>
在新增员工的时候，在表单中，我们既要录入员工的基本信息，又要录入员工的工作经历信息。 员工基本信息，对应的表结构是 emp表，员工工作经历信息，对应的表结构是 emp_expr 表，所以这里我们要操作两张表，往两张表中保存数据。</p>
<h2 id="接口描述"><strong>接口描述</strong></h2>
<p>请求路径：/emps<br>
请求方式：POST<br>
接口描述：该接口用于添加员工的信息<br>
参数格式：application/json<br>
请求数据样例：</p>
<pre><code class="language-json">{
  &quot;image&quot;: &quot;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-03-07-37-38222.jpg&quot;,
  &quot;username&quot;: &quot;linpingzhi&quot;,
  &quot;name&quot;: &quot;林平之&quot;,
  &quot;gender&quot;: 1,
  &quot;job&quot;: 1,
  &quot;entryDate&quot;: &quot;2022-09-18&quot;,
  &quot;deptId&quot;: 1,
  &quot;phone&quot;: &quot;18809091234&quot;,
  &quot;salary&quot;: 8000,
  &quot;exprList&quot;: [
      {
         &quot;company&quot;: &quot;百度科技股份有限公司&quot;,
         &quot;job&quot;: &quot;java开发&quot;,
         &quot;begin&quot;: &quot;2012-07-01&quot;,
         &quot;end&quot;: &quot;2019-03-03&quot;
      },
      {
         &quot;company&quot;: &quot;阿里巴巴科技股份有限公司&quot;,
         &quot;job&quot;: &quot;架构师&quot;,
         &quot;begin&quot;: &quot;2019-03-15&quot;,
         &quot;end&quot;: &quot;2023-03-01&quot;
      }
   ]
}
</code></pre>
<p>参数格式：application/json<br>
响应数据样例：</p>
<pre><code class="language-json">{
    &quot;code&quot;:1,
    &quot;msg&quot;:&quot;success&quot;,
    &quot;data&quot;:null
}
</code></pre>
<h2 id="保存员工信息"><strong>保存员工信息</strong></h2>
<p>1). EmpController</p>
<pre><code class="language-java">@PostMapping
    public Result save(@RequestBody Emp emp) {
        log.info(&quot;新增员工：{}&quot;,emp);
        empService.save(emp);
        return Result.success();
    }
</code></pre>
<p>2). EmpService &amp; EmpServiceImpl</p>
<pre><code class="language-java">@Override
public void save(Emp emp) {
    //1.补全基础属性
    emp.setCreateTime(LocalDateTime.now());
    emp.setUpdateTime(LocalDateTime.now());
    
    //2.保存员工基本信息
    empMapper.insert(emp);

    //3. 保存员工的工作经历信息 - 批量 (稍后完成)
    
}
</code></pre>
<p>3). EmpMapper</p>
<pre><code class="language-java">@Insert(&quot;insert into emp(username, name, gender, phone, job, salary, image, entry_date, dept_id, create_time, update_time) &quot; +
            &quot;values (#{username},#{name},#{gender},#{phone},#{job},#{salary},#{image},#{entryDate},#{deptId},#{createTime},#{updateTime})&quot;)
    void insert(Emp emp);
</code></pre>
<h2 id="批量保存工作经历"><strong>批量保存工作经历</strong></h2>
<p>这里用到Mybatis中的动态SQL里提供的 &lt;foreach&gt; 标签，改标签的作用，是用来遍历循环，常见的属性说明：</p>
<ol>
<li>collection：集合名称</li>
<li>item：集合遍历出来的元素/项</li>
<li>separator：每一次遍历使用的分隔符</li>
<li>open：遍历开始前拼接的片段</li>
<li>close：遍历结束后拼接的片段</li>
</ol>
<p>上述的属性，是可选的，并不是所有的都是必须的。 可以自己根据实际需求，来指定对应的属性。<br>
1). EmpServiceImpl</p>
<pre><code class="language-java">@Override
    public void save(Emp emp) {
        //1.保存员工基本信息
        emp.setCreateTime(LocalDateTime.now());
        emp.setUpdateTime(LocalDateTime.now());
        empMapper.insert(emp);
        //2.保存员工的工作经历信息
        List&lt;EmpExpr&gt; exprList=emp.getExprList();
        if(!CollectionUtils.isEmpty(exprList)){
            exprList.forEach(expr-&gt;{
                expr.setEmpId(emp.getId());
            });
            empExprMapper.insertBatch(exprList);
        }
    }
</code></pre>
<p>2). EmpExprMapper</p>
<pre><code class="language-java">public interface EmpExprMapper {

    void insertBatch(List&lt;EmpExpr&gt; exprList);
}
</code></pre>
<p>3). EmpExprMapper.xml</p>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.ys.mapper.EmpExprMapper&quot;&gt;

&lt;!--    批量保存员工工作经历--&gt;
    &lt;insert id=&quot;insertBatch&quot;&gt;
        insert into emp_expr(emp_id, begin, end, company, job) values
        &lt;foreach collection=&quot;exprList&quot; item=&quot;expr&quot; separator=&quot;,&quot;&gt;
            (#{expr.empId}, #{expr.begin}, #{expr.end}, #{expr.company}, #{expr.job})
        &lt;/foreach&gt;
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<p>4). EmpMapper<br>
主键返回：@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)<br>
由于稍后，我们在保存工作经历信息的时候，需要记录是哪位员工的工作经历。 所以，保存完员工信息之后，是需要获取到员工的ID的，那这里就需要通过Mybatis中提供的主键返回功能来获取。</p>
<pre><code class="language-java">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)
    @Insert(&quot;insert into emp(username, name, gender, phone, job, salary, image, entry_date, dept_id, create_time, update_time) &quot; +
            &quot;values (#{username},#{name},#{gender},#{phone},#{job},#{salary},#{image},#{entryDate},#{deptId},#{createTime},#{updateTime})&quot;)
    void insert(Emp emp);
</code></pre>
<h1 id="事务管理"><strong>事务管理</strong></h1>
<p>目前我们实现的新增员工功能中，操作了两次数据库，执行了两次 insert 操作。</p>
<ul>
<li>第一次：保存员工的基本信息到 emp 表中。</li>
<li>第二次：保存员工的工作经历信息到 emp_expr 表中。</li>
</ul>
<p>如果说，保存员工的基本信息成功了，而保存员工的工作经历信息出错了，会发生什么现象呢？那接下来，我们来做一个测试 。 我们可以在代码中，人为在保存员工的service层的save方法中，构造一个错误：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250618193824.png" alt="" loading="lazy"><br>
点击 “保存” 之后，提示 “系统接口异常”。我们可以打开IDEA控制台看一下，报出的错误信息。 我们看到，保存了员工的基本信息之后，系统出现了异常。最终，我们看到，程序出现了异常 ，员工表 emp 数据保存成功了, 但是 emp_expr 员工工作经历信息表，数据保存失败了。 那是否允许这种情况发生呢？</p>
<ul>
<li>不允许</li>
<li>因为这属于一个业务操作，如果保存员工信息成功了，保存工作经历信息失败了，就会造成数据库数据的不完整、不一致。</li>
</ul>
<h2 id="介绍"><strong>介绍</strong></h2>
<p>概念： 事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作 要么同时成功，要么同时失败。<br>
默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</p>
<h2 id="操作"><strong>操作</strong></h2>
<p>事务控制主要三步操作：开启事务、提交事务/回滚事务。</p>
<ul>
<li>需要在这组操作执行之前，先开启事务  ( start transaction; / begin;)。</li>
<li>所有操作如果全部都执行成功，则提交事务 ( commit; )。</li>
<li>如果这组操作中，有任何一个操作执行失败，都应该回滚事务 ( rollback )。</li>
</ul>
<p>那接下来，我们就可以将添加员工的业务操作，进行事务管理。 具体的SQL如下：</p>
<pre><code class="language-sql">-- 开启事务
start transaction; / begin;

-- 1. 保存员工基本信息
insert into emp values (39, 'Tom', '123456', '汤姆', 1, '13300001111', 1, 4000, '1.jpg', '2023-11-01', 1, now(), now());

-- 2. 保存员工的工作经历信息
insert into emp_expr(emp_id, begin, end, company, job) values (39,'2019-01-01', '2020-01-01', '百度', '开发'), (39,'2020-01-10', '2022-02-01', '阿里', '架构'); 

-- 此时用select语句可以看到执行成功的sql数据，但事务并没有提交（新打开一个窗口查看这个表时看不到新增的数据，打开新窗口可以看成一个新事务，这是事务的独立性）

-- 提交事务(全部成功)
commit;

-- 回滚事务(有一个失败)
rollback;
</code></pre>
<h2 id="spring事务管理"><strong>Spring事务管理</strong></h2>
<p>注解：@Transactional<br>
作用：就是在当前这个方法执行开始之前来开启事务，方法执行完毕之后提交事务。如果在这个方法执行的过程当中出现了异常，就会进行事务的回滚操作。<br>
位置：业务层的方法上、类上、接口上</p>
<ul>
<li>方法上：当前方法交给spring进行事务管理</li>
<li>类上：当前类中所有的方法都交由spring进行事务管理</li>
<li>接口上：接口下所有的实现类当中所有的方法都交给spring 进行事务管理</li>
</ul>
<p>接下来，我们就可以在业务方法save上加上 @Transactional 来控制事务 。</p>
<pre><code class="language-yml">#spring事务管理日志,控制这个包下这个类的日志输出
logging:
  level:
    org.springframework.jdbc.support.JdbcTransactionManager: debug
</code></pre>
<pre><code class="language-java">@Transactional
    @Override
    public void save(Emp emp) {
        //1.保存员工基本信息
        emp.setCreateTime(LocalDateTime.now());
        emp.setUpdateTime(LocalDateTime.now());
        empMapper.insert(emp);

        int i=1/0;

        //2.保存员工的工作经历信息
        List&lt;EmpExpr&gt; exprList=emp.getExprList();
        if(!CollectionUtils.isEmpty(exprList)){
            exprList.forEach(expr-&gt;{
                expr.setEmpId(emp.getId());
            });
            empExprMapper.insertBatch(exprList);
        }
    }
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250618211050.png" alt="" loading="lazy"><br>
打开数据库，我们会看到 emp 表 与 emp_expr 表中都没有对应的数据信息，保证了数据的一致性、完整性。</p>
<h2 id="事务进阶"><strong>事务进阶</strong></h2>
<p>@Transactional注解当中的两个常见的属性：</p>
<ul>
<li>异常回滚的属性：rollbackFor</li>
<li>事务传播行为：propagation</li>
</ul>
<h3 id="rollbackfor"><strong>rollbackFor</strong></h3>
<p>下面我们在做一个测试，我们修改业务功能代码，在模拟异常的位置上直接抛出Exception异常（编译时异常）</p>
<pre><code class="language-java">@Transactional
@Override
public void save(Emp emp) {
    //1.补全基础属性
    emp.setCreateTime(LocalDateTime.now());
    emp.setUpdateTime(LocalDateTime.now());
    //2.保存员工基本信息
    empMapper.insert(emp);
        
    //模拟：异常发生
    if(true){
        throw new Exception(&quot;出现异常了~~~&quot;);
    }
        
    //3. 保存员工的工作经历信息 - 批量
    Integer empId = emp.getId();
    List&lt;EmpExpr&gt; exprList = emp.getExprList();
    if(!CollectionUtils.isEmpty(exprList)){
        exprList.forEach(empExpr -&gt; empExpr.setEmpId(empId));
        empExprMapper.insertBatch(exprList);
    }
}
</code></pre>
<p>我们看到数据库的事务居然提交了，并没有进行回滚。<br>
通过以上测试可以得出一个结论：默认情况下，只有出现RuntimeException(运行时异常)才会回滚事务。假如我们想让所有的异常都回滚，需要来配置@Transactional注解当中的rollbackFor属性，通过rollbackFor这个属性可以指定出现何种异常类型回滚事务。</p>
<pre><code class="language-java">@Transactional(rollbackFor = {Exception.class})
</code></pre>
<h3 id="propagation"><strong>propagation</strong></h3>
<p>事务的传播行为：当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250618213225.png" alt="" loading="lazy"></p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>REQUIRED</td>
<td>【默认值】需要事务，有则加入，无则创建新事务</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>需要新事务，无论有无，总是创建新事务</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>支持事务，有则加入，无则在无事务状态中运行</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>必须有事务，否则抛异常</td>
</tr>
<tr>
<td>NEVER</td>
<td>必须没事务，否则抛异常</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
</tbody>
</table>
<p>需求：在新增员工信息时，无论是成功还是失败，都要记录操作日志。<br>
步骤：</p>
<ol>
<li>准备日志表 emp_log、实体类EmpLog、Mapper接口EmpLogMapper</li>
<li>在新增员工时记录日志</li>
</ol>
<p><strong>准备工作</strong>：<br>
1). 创建数据库表 emp_log 日志表</p>
<pre><code class="language-java">-- 创建员工日志表
create table emp_log(
    id int unsigned primary key auto_increment comment 'ID, 主键',
    operate_time datetime comment '操作时间',
    info varchar(2000) comment '日志信息'
) comment '员工日志表';
</code></pre>
<p>2). 引入资料中提供的实体类：EmpLog</p>
<pre><code class="language-java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class EmpLog {
    private Integer id; //ID
    private LocalDateTime operateTime; //操作时间
    private String info; //详细信息
}
</code></pre>
<p>3). 引入资料中提供的Mapper接口：EmpLogMapper</p>
<pre><code class="language-java">@Mapper
public interface EmpLogMapper {
        //插入日志
    @Insert(&quot;insert into emp_log (operate_time, info) values (#{operateTime}, #{info})&quot;)
    public void insert(EmpLog empLog);
}
</code></pre>
<p>4). 引入资料中提供的业务接口：EmpLogService</p>
<pre><code class="language-java">public interface EmpLogService {
        //记录新增员工日志
    public void insertLog(EmpLog empLog);
}
</code></pre>
<p>5). 引入资料中提供的业务实现类：EmpLogServiceImpl</p>
<pre><code class="language-java">@Service
public class EmpLogServiceImpl implements EmpLogService {

    @Autowired
    private EmpLogMapper empLogMapper;

    @Transactional
    @Override
    public void insertLog(EmpLog empLog) {
        empLogMapper.insert(empLog);
    }
}
</code></pre>
<p>6).业务实现类：EmpServiceImpl</p>
<pre><code class="language-java">@Service
public class EmpServiceImpl implements EmpService {

    @Autowired
    private EmpMapper empMapper;
    @Autowired
    private EmpExprMapper empExprMapper;
    @Autowired
    private EmpLogService empLogService;

    //原始分页查询
    /*@Override
    public PageResult&lt;Emp&gt; page(Integer page, Integer pageSize) {
        Long total=empMapper.count();
        Integer start=(page-1)*pageSize;
        List&lt;Emp&gt; rows= empMapper.list(start, pageSize);
        return new PageResult&lt;Emp&gt;(total, rows);
    }*/

    @Override
    public PageResult&lt;Emp&gt; page(EmpQueryParam empQueryParam) {
        //1.设置分页参数
        PageHelper.startPage(empQueryParam.getPage(), empQueryParam.getPageSize());
        //2.执行查询
        List&lt;Emp&gt; empList=empMapper.list(empQueryParam);
        //3.解析查询结果，并封装
        Page&lt;Emp&gt; p= (Page&lt;Emp&gt;) empList;
        return new PageResult&lt;Emp&gt;(p.getTotal(),p.getResult());
    }

    @Transactional(rollbackFor = Exception.class)
    @Override
    public void save(Emp emp) throws Exception {
        try {
            //1.保存员工基本信息
            emp.setCreateTime(LocalDateTime.now());
            emp.setUpdateTime(LocalDateTime.now());
            empMapper.insert(emp);
            
            int i=1/0;

            //2.保存员工的工作经历信息
            List&lt;EmpExpr&gt; exprList=emp.getExprList();
            if(!CollectionUtils.isEmpty(exprList)){
                exprList.forEach(expr-&gt;{
                    expr.setEmpId(emp.getId());
                });
                empExprMapper.insertBatch(exprList);
            }
        } finally {
            //记录操作日志
            EmpLog empLog=new EmpLog(null,LocalDateTime.now(),&quot;新增员工：&quot;+emp);
            empLogService.insertLog(empLog);
        }
    }
}
</code></pre>
<p><strong>测试</strong>:<br>
重新启动SpringBoot服务，测试新增员工操作 。我们可以看到控制台中输出的日志：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250618214901.png" alt="" loading="lazy"><br>
从日志中我们可以看到：</p>
<ul>
<li>执行了插入员工数据的操作</li>
<li>执行了插入日志操作</li>
<li>程序发生Exception异常</li>
<li>执行事务回滚（保存员工数据、插入操作日志 因为在一个事务范围内，两个操作都会被回滚）</li>
</ul>
<p>然后在 emp_log 表中没有记录日志数据 。<br>
<strong>原因分析</strong>:<br>
接下来我们就需要来分析一下具体是什么原因导致的日志没有成功的记录。</p>
<ul>
<li>在执行 save 方法时开启了一个事务</li>
<li>当执行 empLogService.insertLog 操作时，insertLog设置的事务传播行是默认值REQUIRED，表示有事务就加入，没有则新建事务</li>
<li>此时：save 和 insertLog 操作使用了同一个事务，同一个事务中的多个操作，要么同时成功，要么同时失败，所以当异常发生时进行事务回滚，就会回滚 save 和  insertLog 操作。</li>
</ul>
<p><strong>解决方案</strong>：<br>
在EmpLogServiceImpl类中insertLog方法上，添加 @Transactional(propagation = Propagation.REQUIRES_NEW)<br>
重启SpringBoot服务，再次测试 新增员工的操作 ，会看到具体的日志如下：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250618215234.png" alt="" loading="lazy"><br>
那此时，EmpServiceImpl 中的 save 方法运行时，会开启一个事务。 当调用  empLogService.insertLog(empLog)  时，也会创建一个新的事务，那此时，当 insertLog 方法运行完毕之后，事务就已经提交了。 即使外部的事务出现异常，内部已经提交的事务，也不会回滚了，因为是两个独立的事务。</p>
<h2 id="事务四大特性"><strong>事务四大特性</strong></h2>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250618215601.png" alt="" loading="lazy"></figure>
<ul>
<li>原子性（Atomicity） ：原子性是指事务包装的一组sql是一个不可分割的工作单元，事务中的操作要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：一个事务完成之后数据都必须处于一致性状态。
<ul>
<li>如果事务成功的完成，那么数据库的所有变化将生效。</li>
<li>如果事务执行出现错误，那么数据库的所有变化将会被回滚(撤销)，返回到原始状态。</li>
</ul>
</li>
<li>隔离性（Isolation）：多个用户并发的访问数据库时，一个用户的事务不能被其他用户的事务干扰，多个并发的事务之间要相互隔离。
<ul>
<li>一个事务的成功或者失败对于其他的事务是没有影响。</li>
</ul>
</li>
<li>持久性（Durability）：一个事务一旦被提交或回滚，它对数据库的改变将是永久性的，哪怕数据库发生异常，重启之后数据亦然存在。</li>
</ul>
<h1 id="文件上传"><strong>文件上传</strong></h1>
<p>在我们完成的 新增员工 功能中，还存在一个问题：没有头像(图片缺失)<br>
1). 生成的前端代码形式如下:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;上传文件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
        姓名: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
        年龄: &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt;
        头像: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>上传文件的原始form表单，要求表单必须具备以下三点（上传文件页面三要素）：</p>
<ul>
<li>表单必须有file域，用于选择要上传的文件</li>
<li>表单提交方式必须为POST：通常上传的文件会比较大，所以需要使用 POST 提交方式</li>
<li>表单的编码类型enctype必须要设置为：multipart/form-data：普通默认的编码格式是不适合传输大型的二进制数据的，所以在文件上传时，表单的编码格式必须设置为multipart/form-data</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250619161047.png" alt="" loading="lazy"><br>
2). 生成的服务端代码形式如下</p>
<pre><code class="language-java">@Slf4j
@RestController
public class UploadController {

    @PostMapping(&quot;/upload&quot;)
    public Result upload(String name,Integer age,MultipartFile file) {
        log.info(&quot;接收参数：{},{},{}&quot;,name,age,file);
        return Result.success();
    }
}
</code></pre>
<p>会将上传上来的文件存放在C盘的临时目录，一旦这次请求响应完毕，文件也就删掉了。</p>
<h2 id="本地存储"><strong>本地存储</strong></h2>
<p>利用原始文件名存储：</p>
<pre><code class="language-java">@Slf4j
@RestController
public class UploadController {

    @PostMapping(&quot;/upload&quot;)
    public Result upload(String name,Integer age,MultipartFile file) throws IOException {
        log.info(&quot;接收参数：{},{},{}&quot;,name,age,file);
        //获取原始文件名
        String originalFilename=file.getOriginalFilename();
        //保存文件
        file.transferTo(new File(&quot;D:/images/&quot;+originalFilename));
        return Result.success();
    }
}
</code></pre>
<p>生成唯一文件名：</p>
<pre><code class="language-java">@Slf4j
@RestController
public class UploadController {

    @PostMapping(&quot;/upload&quot;)
    public Result upload(String name,Integer age,MultipartFile file) throws IOException {
        log.info(&quot;接收参数：{},{},{}&quot;,name,age,file);
        //获取原始文件名
        String originalFilename=file.getOriginalFilename();

        //新的文件名
        String extension=originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));
        String newFilename= UUID.randomUUID().toString()+extension;
        //保存文件
        file.transferTo(new File(&quot;D:/images/&quot;+newFilename));
        return Result.success();
    }
}
</code></pre>
<p>在SpringBoot中，文件上传时默认单个文件最大大小为1M<br>
那么如果需要上传大文件，可以在 application.properties 进行如下配置：</p>
<pre><code class="language-yml">spring:
  application:
    name: tlias-web-management
  datasource:
    url: jdbc:mysql://localhost:3306/tlias
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: 123456
  servlet:
    multipart:
      # 最大单个文件大小
      max-file-size: 10MB
      # 单个请求最大大小
      max-request-size: 100MB
</code></pre>
<h2 id="阿里云oss"><strong>阿里云OSS</strong></h2>
<p>如果直接存储在服务器的磁盘目录中，存在以下缺点：</p>
<ul>
<li>不安全：磁盘如果损坏，所有的文件就会丢失</li>
<li>容量有限：如果存储大量的图片，磁盘空间有限(磁盘不可能无限制扩容)</li>
<li>无法直接访问</li>
</ul>
<p>为了解决上述问题呢，通常有两种解决方案：</p>
<ul>
<li>自己搭建存储服务器，如：fastDFS 、MinIO</li>
<li>使用现成的云服务，如：阿里云，腾讯云，华为云</li>
</ul>
<p>阿里云对象存储OSS（Object Storage Service），是一款海量、安全、低成本、高可靠的云存储服务。使用OSS，您可以通过网络随时存储和调用包括文本、图片、音频和视频等在内的各种文件。在我们使用了阿里云OSS对象存储服务之后，我们的项目当中如果涉及到文件上传这样的业务，在前端进行文件上传并请求到服务端时，在服务器本地磁盘当中就不需要再来存储文件了。我们直接将接收到的文件上传到oss，由 oss帮我们存储和管理，同时阿里云的oss存储服务还保障了我们所存储内容的安全可靠。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250619170013.png" alt="" loading="lazy"><br>
SDK：Software Development Kit 的缩写，软件开发工具包，包括辅助软件开发的依赖（jar包）、代码示例等，都可以叫做SDK。<br>
简单说，sdk中包含了我们使用第三方云服务时所需要的依赖，以及一些示例代码。我们可以参照sdk所提供的示例代码就可以完成入门程序。<br>
Bucket：存储空间是用户用于存储对象（Object，就是文件）的容器，所有的对象都必须隶属于某个存储空间。<br>
1).开通OSS服务之后，就可以进入到阿里云对象存储的控制台<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250619173509.png" alt="" loading="lazy"><br>
2).创建AccessKey<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250619173605.png" alt="" loading="lazy"><br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250619173615.png" alt="" loading="lazy"><br>
3).配置AccessKey<br>
以管理员身份打开CMD命令行，执行如下命令，配置系统的环境变量。</p>
<pre><code class="language-shell">set OSS_ACCESS_KEY_ID=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
set OSS_ACCESS_KEY_SECRET=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
</code></pre>
<p>执行如下命令，让更改生效。</p>
<pre><code class="language-shell">setx OSS_ACCESS_KEY_ID &quot;%OSS_ACCESS_KEY_ID%&quot;
setx OSS_ACCESS_KEY_SECRET &quot;%OSS_ACCESS_KEY_SECRET%&quot;
</code></pre>
<p>执行如下命令，验证环境变量是否生效。</p>
<pre><code class="language-shell">echo %OSS_ACCESS_KEY_ID%
echo %OSS_ACCESS_KEY_SECRET%
</code></pre>
<h3 id="入门"><strong>入门</strong></h3>
<p>阿里云oss 对象存储服务的准备工作我们已经完成了，接下来我们就来完成第二步操作：参照官方所提供的sdk示例来编写入门程序。<br>
首先我们需要来打开阿里云OSS的官方文档，在官方文档中找到 SDK 的示例代码：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250619174802.png" alt="" loading="lazy"></p>
<pre><code class="language-xml">&lt;!--阿里云OSS依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
    &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
    &lt;version&gt;3.17.4&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
    &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
    &lt;version&gt;2.3.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.activation&lt;/groupId&gt;
    &lt;artifactId&gt;activation&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- no more than 2.3.3--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
    &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
    &lt;version&gt;2.3.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">public class Demo {

    public static void main(String[] args) throws Exception {
        // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。
        String endpoint = &quot;https://oss-cn-beijing.aliyuncs.com&quot;;
        // 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。
        EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();
        // 填写Bucket名称，例如examplebucket。
        String bucketName = &quot;java-ai-ys-wasd&quot;;
        // 填写Object完整路径，例如exampledir/exampleobject.txt。Object完整路径中不能包含Bucket名称。
        String objectName = &quot;001.jpg&quot;;
        // 填写Bucket所在地域。以华东1（杭州）为例，Region填写为cn-hangzhou。
        String region = &quot;cn-beijing&quot;;

        // 创建OSSClient实例。
        ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration();
        clientBuilderConfiguration.setSignatureVersion(SignVersion.V4);
        OSS ossClient = OSSClientBuilder.create()
                .endpoint(endpoint)
                .credentialsProvider(credentialsProvider)
                .clientConfiguration(clientBuilderConfiguration)
                .region(region)
                .build();

        try {

            File file = new File(&quot;D:\\Gridea\\图标.jpg&quot;);
            byte[] content = Files.readAllBytes(file.toPath());

            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(content));
        } catch (OSSException oe) {
            System.out.println(&quot;Caught an OSSException, which means your request made it to OSS, &quot;
                    + &quot;but was rejected with an error response for some reason.&quot;);
            System.out.println(&quot;Error Message:&quot; + oe.getErrorMessage());
            System.out.println(&quot;Error Code:&quot; + oe.getErrorCode());
            System.out.println(&quot;Request ID:&quot; + oe.getRequestId());
            System.out.println(&quot;Host ID:&quot; + oe.getHostId());
        } catch (ClientException ce) {
            System.out.println(&quot;Caught an ClientException, which means the client encountered &quot;
                    + &quot;a serious internal problem while trying to communicate with OSS, &quot;
                    + &quot;such as not being able to access the network.&quot;);
            System.out.println(&quot;Error Message:&quot; + ce.getMessage());
        } finally {
            if (ossClient != null) {
                ossClient.shutdown();
            }
        }
    }
}
</code></pre>
<p>在以上代码中，需要替换的内容为：</p>
<ul>
<li>endpoint：阿里云OSS中的bucket对应的域名</li>
<li>bucketName：Bucket名称</li>
<li>objectName：对象名称，在Bucket中存储的对象的名称</li>
<li>region：bucket所属区域</li>
</ul>
<p>运行以上程序后，会把本地的文件上传到阿里云OSS服务器上。</p>
<h3 id="集成"><strong>集成</strong></h3>
<p>阿里云oss对象存储服务的准备工作以及入门程序我们都已经完成了，接下来我们就需要在案例当中集成oss对象存储服务，来存储和管理案例中上传的图片。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250619181913.png" alt="" loading="lazy"><br>
在新增员工的时候，上传员工的图像，而之所以需要上传员工的图像，是因为将来我们需要在系统页面当中访问并展示员工的图像。而要想完成这个操作，需要做两件事：</p>
<ol>
<li>需要上传员工的图像，并把图像保存起来（存储到阿里云OSS）</li>
<li>访问员工图像（通过图像在阿里云OSS的存储地址访问图像）</li>
</ol>
<ul>
<li>OSS中的每一个文件都会分配一个访问的url，通过这个url就可以访问到存储在阿里云上的图片。所以需要把url返回给前端，这样前端就可以通过url获取到图像。</li>
</ul>
<p>我们参照接口文档来开发文件上传功能：<br>
基本信息</p>
<ul>
<li>请求路径：/upload</li>
<li>请求方式：POST</li>
<li>接口描述：上传图片接口</li>
</ul>
<p>请求参数</p>
<ul>
<li>参数格式：multipart/form-data</li>
</ul>
<p>响应数据</p>
<ul>
<li>参数格式：application/json</li>
<li>响应数据样例：</li>
</ul>
<pre><code class="language-json">{
    &quot;code&quot;: 1,
    &quot;msg&quot;: &quot;success&quot;,
    &quot;data&quot;: &quot;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-0400.jpg&quot;
}
</code></pre>
<p>1). 引入阿里云OSS上传文件工具类（由官方的示例代码改造而来）</p>
<pre><code class="language-java">@Component
public class AliyunOSSOperator {

    private String endpoint = &quot;https://oss-cn-beijing.aliyuncs.com&quot;;
    private String bucketName = &quot;java-ai-ys-wasd&quot;;
    private String region = &quot;cn-beijing&quot;;

    public String upload(byte[] content, String originalFilename) throws Exception {
        // 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。
        EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();

        // 填写Object完整路径，例如202406/1.png。Object完整路径中不能包含Bucket名称。
        //获取当前系统日期的字符串,格式为 yyyy/MM
        String dir = LocalDate.now().format(DateTimeFormatter.ofPattern(&quot;yyyy/MM&quot;));
        //生成一个新的不重复的文件名
        String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));
        String objectName = dir + &quot;/&quot; + newFileName;

        // 创建OSSClient实例。
        ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration();
        clientBuilderConfiguration.setSignatureVersion(SignVersion.V4);
        OSS ossClient = OSSClientBuilder.create()
                .endpoint(endpoint)
                .credentialsProvider(credentialsProvider)
                .clientConfiguration(clientBuilderConfiguration)
                .region(region)
                .build();

        try {
            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(content));
        } finally {
            ossClient.shutdown();
        }

        // 返回文件路径，类似https://java-ai-ys-wasd.oss-cn-beijing.aliyuncs.com/001.jpg
        return endpoint.split(&quot;//&quot;)[0] + &quot;//&quot; + bucketName + &quot;.&quot; + endpoint.split(&quot;//&quot;)[1] + &quot;/&quot; + objectName;
    }

}
</code></pre>
<p>2). 修改UploadController代码</p>
<pre><code class="language-java">@Slf4j
@RestController
public class UploadController {

    @Autowired
    private AliyunOSSOperator aliyunOSSOperator;

    @PostMapping(&quot;/upload&quot;)
    public Result upload(MultipartFile file) throws Exception {
        log.info(&quot;文件上传：{}&quot;, file.getOriginalFilename());
        String url=aliyunOSSOperator.upload(file.getBytes(), file.getOriginalFilename() );
        log.info(&quot;文件上传OSS，url：{}&quot;,url);
        return Result.success(url);
    }
}
</code></pre>
<h2 id="功能优化"><strong>功能优化</strong></h2>
<p>员工管理的新增功能我们已开发完成，但在我们所开发的程序中还一些小问题，下面我们就来分析一下当前案例中存在的问题以及如何优化解决。<br>
在刚才我们制作的AliyunOSS操作的工具类中，我们直接将 endpoint、bucketName参数直接在java文件中写死了。如下所示：</p>
<pre><code class="language-java">@Component
public class AliyunOSSOperator {

    private String endpoint = &quot;https://oss-cn-beijing.aliyuncs.com&quot;;
    private String bucketName = &quot;java-ai-ys-wasd&quot;;
    private String region = &quot;cn-beijing&quot;;
</code></pre>
<p>那么对于这些容易变动的参数，我们可以将其配置在配置文件中，然后通过 @Value 注解来注解外部配置的属性。如下所示：</p>
<pre><code class="language-yml">#阿里云OSS
aliyun:
  oss:
    endpoint: https://oss-cn-beijing.aliyuncs.com
    bucketName: java-ai-ys-wasd
    region: cn-beijing
</code></pre>
<pre><code class="language-java">@Component
public class AliyunOSSOperator {

    @Value(&quot;${aliyun.oss.endpoint}&quot;)
    private String endpoint;
    @Value(&quot;${aliyun.oss.bucketName}&quot;)
    private String bucketName;
    @Value(&quot;${aliyun.oss.region}&quot;)
    private String region;
</code></pre>
<p>如果只有一两个属性需要注入，而且不需要考虑复用性，使用@Value注解就可以了。<br>
但是使用@Value注解注入配置文件的配置项，如果配置项多，注入繁琐，不便于维护管理 和 复用。<br>
Spring中给我们提供了一种简化方式，可以直接将配置文件中配置项的值自动的注入到对象的属性中。</p>
<p>Spring提供的简化方式套路：<br>
1). 需要创建一个实现类，且实体类中的属性名和配置文件当中key的名字必须要一致<br>
比如：配置文件当中叫endpoint，实体类当中的属性也得叫endpoint，另外实体类当中的属性还需要提供 getter / setter方法<br>
2). 需要将实体类交给Spring的IOC容器管理，成为IOC容器当中的bean对象<br>
3). 在实体类上添加@ConfigurationProperties注解，并通过perfect属性来指定配置参数项的前缀</p>
<p>1). 定义实体类AliyunOSSProperties ，并交给IOC容器管理</p>
<pre><code class="language-java">@Data
@Component
@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)
public class AliyunOSSProperties {
    private String endpoint;
    private String bucketName;
    private String region;
}
</code></pre>
<p>2). 修改AliyunOSSOperator</p>
<pre><code class="language-java">@Component
public class AliyunOSSOperator {

    @Autowired
    private AliyunOSSProperties aliyunOSSProperties;


    public String upload(byte[] content, String originalFilename) throws Exception {
        String endpoint=aliyunOSSProperties.getEndpoint();
        String bucketName=aliyunOSSProperties.getBucketName();
        String region=aliyunOSSProperties.getRegion();
        // 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。
        EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多表关系与员工查询]]></title>
        <id>https://yyss1014.github.io/post/hou-duan-web-shi-zhan-yuan-gong-guan-li/</id>
        <link href="https://yyss1014.github.io/post/hou-duan-web-shi-zhan-yuan-gong-guan-li/">
        </link>
        <updated>2025-06-16T13:51:30.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB"><strong>多表关系</strong></a>
<ul>
<li><a href="#%E4%B8%80%E5%AF%B9%E5%A4%9A"><strong>一对多</strong></a></li>
<li><a href="#%E5%A4%9A%E8%A1%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><strong>多表问题分析</strong></a></li>
<li><a href="#%E4%B8%80%E5%AF%B9%E4%B8%80"><strong>一对一</strong></a></li>
<li><a href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A"><strong>多对多</strong></a></li>
<li><a href="#%E5%A4%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1%E6%A1%88%E4%BE%8B"><strong>多表设计案例</strong></a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><strong>多表查询</strong></a>
<ul>
<li><a href="#%E5%88%86%E7%B1%BB"><strong>分类</strong></a></li>
<li><a href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><strong>内连接</strong></a></li>
<li><a href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><strong>外连接</strong></a></li>
<li><a href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><strong>子查询</strong></a></li>
<li><a href="#%E6%A1%88%E4%BE%8B"><strong>案例</strong></a></li>
</ul>
</li>
<li><a href="#%E5%91%98%E5%B7%A5%E5%88%97%E8%A1%A8%E6%9F%A5%E8%AF%A2"><strong>员工列表查询</strong></a>
<ul>
<li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><strong>准备工作</strong></a></li>
<li><a href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><strong>分页查询</strong></a>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><strong>代码实现</strong></a></li>
<li><a href="#pagehelper%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6"><strong>PageHelper分页插件</strong></a></li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><strong>条件分页查询</strong></a>
<ul>
<li><a href="#%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91"><strong>功能开发</strong></a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96"><strong>程序优化</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="多表关系"><strong>多表关系</strong></h1>
<p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p>
<ul>
<li>一对多(多对一)</li>
<li>多对多</li>
<li>一对一</li>
</ul>
<h2 id="一对多"><strong>一对多</strong></h2>
<ul>
<li>场景：部门与员工的关系（一个部门下有多个员工）。</li>
<li>部门管理的页面原型：</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250617142912.png" alt="" loading="lazy"></figure>
<ul>
<li>员工管理的页面原型：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250617142941.png" alt="" loading="lazy"><br>
由于一个部门下，会关联多个员工。 而一个员工，是归属于某一个部门的 。那么此时，我们就需要在 emp 表中增加一个字段 dept_id 来标识这个员工属于哪一个部门，dept_id 关联的是 dept 的 id 。</p>
<pre><code class="language-sql">CREATE TABLE dept (
  id int unsigned PRIMARY KEY AUTO_INCREMENT COMMENT 'ID, 主键',
  name varchar(10) NOT NULL UNIQUE COMMENT '部门名称',
  create_time datetime DEFAULT NULL COMMENT '创建时间',
  update_time datetime DEFAULT NULL COMMENT '修改时间'
) COMMENT '部门表';

INSERT INTO dept VALUES (1,'学工部','2023-09-25 09:47:40','2023-09-25 09:47:40'),
						  (2,'教研部','2023-09-25 09:47:40','2023-10-09 15:17:04'),
						  (3,'咨询部2','2023-09-25 09:47:40','2023-11-30 21:26:24'),
						  (4,'就业部','2023-09-25 09:47:40','2023-09-25 09:47:40'),
						  (5,'人事部','2023-09-25 09:47:40','2023-09-25 09:47:40'),
						  (15,'行政部','2023-11-30 20:56:37','2023-11-30 20:56:37');




create table emp(
    id int unsigned primary key auto_increment comment 'ID,主键',
    username varchar(20) not null unique comment '用户名',
    password varchar(32) default '123456' comment '密码',
    name varchar(10) not null comment '姓名',
    gender tinyint unsigned not null comment '性别, 1:男, 2:女',
    phone char(11) not null unique comment '手机号',
    job tinyint unsigned comment '职位, 1 班主任, 2 讲师 , 3 学工主管, 4 教研主管, 5 咨询师',
    salary int unsigned comment '薪资',
    image varchar(255) comment '头像',
    entry_date date comment '入职日期',
    dept_id int unsigned comment '部门ID',
    create_time datetime comment '创建时间',
    update_time datetime comment '修改时间'
) comment '员工表';


INSERT INTO emp VALUES
(1,'shinaian','123456','施耐庵',1,'13309090001',4,15000,'5.png','2000-01-01',2,'2023-10-20 16:35:33','2023-11-16 16:11:26'),
(2,'songjiang','123456','宋江',1,'13309090002',2,8600,'01.png','2015-01-01',2,'2023-10-20 16:35:33','2023-10-20 16:35:37'),
(3,'lujunyi','123456','卢俊义',1,'13309090003',2,8900,'01.png','2008-05-01',2,'2023-10-20 16:35:33','2023-10-20 16:35:39'),
(4,'wuyong','123456','吴用',1,'13309090004',2,9200,'01.png','2007-01-01',2,'2023-10-20 16:35:33','2023-10-20 16:35:41'),
(5,'gongsunsheng','123456','公孙胜',1,'13309090005',2,9500,'01.png','2012-12-05',2,'2023-10-20 16:35:33','2023-10-20 16:35:43'),
(6,'huosanniang','123456','扈三娘',2,'13309090006',3,6500,'01.png','2013-09-05',1,'2023-10-20 16:35:33','2023-10-20 16:35:45'),
(7,'chaijin','123456','柴进',1,'13309090007',1,4700,'01.png','2005-08-01',1,'2023-10-20 16:35:33','2023-10-20 16:35:47'),
(8,'likui','123456','李逵',1,'13309090008',1,4800,'01.png','2014-11-09',1,'2023-10-20 16:35:33','2023-10-20 16:35:49'),
(9,'wusong','123456','武松',1,'13309090009',1,4900,'01.png','2011-03-11',1,'2023-10-20 16:35:33','2023-10-20 16:35:51'),
(10,'linchong','123456','林冲',1,'13309090010',1,5000,'01.png','2013-09-05',1,'2023-10-20 16:35:33','2023-10-20 16:35:53'),
(11,'huyanzhuo','123456','呼延灼',1,'13309090011',2,9700,'01.png','2007-02-01',2,'2023-10-20 16:35:33','2023-10-20 16:35:55'),
(12,'xiaoliguang','123456','小李广',1,'13309090012',2,10000,'01.png','2008-08-18',2,'2023-10-20 16:35:33','2023-10-20 16:35:57'),
(13,'yangzhi','123456','杨志',1,'13309090013',1,5300,'01.png','2012-11-01',1,'2023-10-20 16:35:33','2023-10-20 16:35:59'),
(14,'shijin','123456','史进',1,'13309090014',2,10600,'01.png','2002-08-01',2,'2023-10-20 16:35:33','2023-10-20 16:36:01'),
(15,'sunerniang','123456','孙二娘',2,'13309090015',2,10900,'01.png','2011-05-01',2,'2023-10-20 16:35:33','2023-10-20 16:36:03'),
(16,'luzhishen','123456','鲁智深',1,'13309090016',2,9600,'01.png','2010-01-01',2,'2023-10-20 16:35:33','2023-10-20 16:36:05'),
(17,'liying','12345678','李应',1,'13309090017',1,5800,'01.png','2015-03-21',1,'2023-10-20 16:35:33','2023-10-20 16:36:07'),
(18,'shiqian','123456','时迁',1,'13309090018',2,10200,'01.png','2015-01-01',2,'2023-10-20 16:35:33','2023-10-20 16:36:09'),
(19,'gudasao','123456','顾大嫂',2,'13309090019',2,10500,'01.png','2008-01-01',2,'2023-10-20 16:35:33','2023-10-20 16:36:11'),
(20,'ruanxiaoer','123456','阮小二',1,'13309090020',2,10800,'01.png','2018-01-01',2,'2023-10-20 16:35:33','2023-10-20 16:36:13'),
(21,'ruanxiaowu','123456','阮小五',1,'13309090021',5,5200,'01.png','2015-01-01',3,'2023-10-20 16:35:33','2023-10-20 16:36:15'),
(22,'ruanxiaoqi','123456','阮小七',1,'13309090022',5,5500,'01.png','2016-01-01',3,'2023-10-20 16:35:33','2023-10-20 16:36:17'),
(23,'ruanji','123456','阮籍',1,'13309090023',5,5800,'01.png','2012-01-01',3,'2023-10-20 16:35:33','2023-10-20 16:36:19'),
(24,'tongwei','123456','童威',1,'13309090024',5,5000,'01.png','2006-01-01',3,'2023-10-20 16:35:33','2023-10-20 16:36:21'),
(25,'tongmeng','123456','童猛',1,'13309090025',5,4800,'01.png','2002-01-01',3,'2023-10-20 16:35:33','2023-10-20 16:36:23'),
(26,'yanshun','123456','燕顺',1,'13309090026',5,5400,'01.png','2011-01-01',3,'2023-10-20 16:35:33','2023-11-08 22:12:46'),
(27,'lijun','123456','李俊',1,'13309090027',2,6600,'8.png','2004-01-01',2,'2023-10-20 16:35:33','2023-11-16 17:56:59'),
(28,'lizhong','123456','李忠',1,'13309090028',5,5000,'6.png','2007-01-01',3,'2023-10-20 16:35:33','2023-11-17 16:34:22'),
(30,'liyun','123456','李云',1,'13309090030',NULL,NULL,'01.png','2020-03-01',NULL,'2023-10-20 16:35:33','2023-10-20 16:36:31'),
(36,'linghuchong','123456','令狐冲',1,'18809091212',2,6800,'1.png','2023-10-19',2,'2023-10-20 20:44:54','2023-11-09 09:41:04');
</code></pre>
<h2 id="多表问题分析"><strong>多表问题分析</strong></h2>
<ul>
<li>现象：部门数据可以直接删除，然而还有部分员工归属于该部门下，此时就出现了数据的不完整、不一致问题 。</li>
<li>原因：目前上述的两张表，在数据库层面，并未建立关联，所以是无法保证数据的一致性和完整性的 。</li>
<li>解决方案：想解决上述的问题呢，我们就可以通过数据库中的 外键约束 来解决。</li>
</ul>
<p>外键约束的语法：</p>
<pre><code class="language-sql">-- 创建表时指定
create table 表名(
        字段名    数据类型,
        ...
        [constraint]   [外键名称]  foreign  key (外键字段名)   references   主表 (主表列名)        
);


-- 建完表后，添加外键
alter table  表名  add constraint  外键名称  foreign key(外键字段名) references 主表(主表列名);
</code></pre>
<p>方式1：通过SQL语句操作</p>
<pre><code class="language-sql">-- 添加外键约束
alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);
</code></pre>
<p>方式2：图形化界面操作<br>
在左侧菜单栏，在emp表上右键，选择 modify Table...<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250617145745.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>物理外键</p>
<ul>
<li>概念：使用foreign key定义外键关联另外一张表。</li>
<li>缺点：
<ul>
<li>影响增、删、改的效率（需要检查外键关系）。</li>
<li>仅用于单节点数据库，不适用于分布式、集群场景。</li>
<li>容易引发数据库的死锁问题，消耗性能。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>逻辑外键</p>
<ul>
<li>概念：在业务层逻辑中，解决外键关联。</li>
<li>通过逻辑外键，就可以很方便的解决上述问题。</li>
</ul>
</li>
</ul>
<p>在现在的企业开发中，很少会使用物理外键，都是使用逻辑外键。 甚至在一些数据库开发规范中，会明确指出禁止使用物理外键 foreign key</p>
<h2 id="一对一"><strong>一对一</strong></h2>
<p>如果在业务系统当中，对用户的基本信息查询频率特别的高，但是对于用户的身份信息查询频率很低，此时出于提高查询效率的考虑，我就可以将这张大表拆分成两张小表，第一张表存放的是用户的基本信息，而第二张表存放的就是用户的身份信息。他们两者之间一对一的关系，一个用户只能对应一个身份证，而一个身份证也只能关联一个用户。</p>
<ul>
<li>基本信息：用户的ID、姓名、性别、手机号、学历</li>
<li>身份信息：民族、生日、身份证号、身份证签发机关，身份证的有效期(开始时间、结束时间)</li>
<li>在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</li>
</ul>
<h2 id="多对多"><strong>多对多</strong></h2>
<p>案例：学生与课程的关系</p>
<ul>
<li>关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</li>
<li>实现关系：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li>
</ul>
<h2 id="多表设计案例"><strong>多表设计案例</strong></h2>
<p>员工表与工作经历表是一对多关系，逻辑外键：</p>
<pre><code class="language-sql">create table emp_expr(
    id int unsigned primary key auto_increment comment 'ID,主键',
    begin date comment '开始时间',
    end date comment '结束时间',
    company varchar(50) comment '公司名字',
    job varchar(50) comment '职位',
    emp_id int unsigned comment '关联员工ID'
)comment '工作经历表'
</code></pre>
<h1 id="多表查询"><strong>多表查询</strong></h1>
<p>查询用户表和部门表中的数据：</p>
<pre><code class="language-sql">select * from  emp , dept;
</code></pre>
<p>此时，我们看到查询结果中包含了大量的结果集，总共180条记录，而这其实就是员工表所有的记录(30行)与部门表所有记录(6行)的所有组合情况，这种现象称之为笛卡尔积。<br>
在SQL语句中，如何去除无效的笛卡尔积呢？只需要给多表查询加上连接查询的条件即可。</p>
<pre><code class="language-sql">select * from emp , dept where emp.dept_id = dept.id ;
</code></pre>
<p>这样，我们就查询出来了所有的员工，及其这个员工所属的部门信息。 而由于id为29、30的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询到。</p>
<h2 id="分类"><strong>分类</strong></h2>
<p>多表查询可以分为：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250617155309.png" alt="" loading="lazy"></p>
<ol>
<li>连接查询</li>
</ol>
<ul>
<li>内连接：相当于查询A、B交集部分数据</li>
<li>外连接
<ul>
<li>左外连接：查询左表所有数据(包括两张表交集部分数据)</li>
<li>右外连接：查询右表所有数据(包括两张表交集部分数据)</li>
</ul>
</li>
</ul>
<ol start="2">
<li>子查询</li>
</ol>
<pre><code class="language-sql">-- 部门管理
create table dept(
    id int unsigned primary key auto_increment comment 'ID, 主键',
    name varchar(10) not null unique comment '部门名称',
    create_time datetime comment '创建时间',
    update_time datetime comment '修改时间'
) comment '部门表' ;

insert into dept (id, name, create_time, update_time) values
        (1,'学工部',now(),now()),
        (2,'教研部',now(),now()),
        (3,'咨询部',now(),now()),
        (4,'就业部',now(),now()),
        (5,'人事部',now(),now());


-- 员工管理
create table emp(
    id int unsigned primary key auto_increment comment 'ID,主键',
    username varchar(20) not null unique comment '用户名',
    password varchar(32) not null comment '密码',
    name varchar(10) not null comment '姓名',
    gender tinyint unsigned not null comment '性别, 1:男, 2:女',
    phone char(11) not null unique comment '手机号',
    job tinyint unsigned comment '职位, 1:班主任,2:讲师,3:学工主管,4:教研主管,5:咨询师',
    salary int unsigned comment '薪资',
    image varchar(255) comment '头像',
    entry_date date comment '入职日期',
    dept_id int unsigned COMMENT '关联的部门ID',
    create_time datetime comment '创建时间',
    update_time datetime comment '修改时间'
) comment '员工表';


-- 准备测试数据
INSERT INTO `emp` VALUES (1,'shinaian','123456','施耐庵',1,'13309090001',4,15000,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2000-01-01',2,'2024-10-27 16:35:33','2024-10-27 16:35:35'),
			(2,'songjiang','123456','宋江',1,'13309090002',2,8600,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2015-01-01',2,'2024-10-27 16:35:33','2024-10-27 16:35:37'),
			(3,'lujunyi','123456','卢俊义',1,'13309090003',2,8900,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2008-05-01',2,'2024-10-27 16:35:33','2024-10-27 16:35:39'),
			(4,'wuyong','123456','吴用',1,'13309090004',2,9200,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2007-01-01',2,'2024-10-27 16:35:33','2024-10-27 16:35:41'),
			(5,'gongsunsheng','123456','公孙胜',1,'13309090005',2,9500,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2012-12-05',2,'2024-10-27 16:35:33','2024-10-27 16:35:43'),
			(6,'huosanniang','123456','扈三娘',2,'13309090006',3,6500,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2013-09-05',1,'2024-10-27 16:35:33','2024-10-27 16:35:45'),
			(7,'chaijin','123456','柴进',1,'13309090007',1,4700,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2005-08-01',1,'2024-10-27 16:35:33','2024-10-27 16:35:47'),
			(8,'likui','123456','李逵',1,'13309090008',1,4800,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2014-11-09',1,'2024-10-27 16:35:33','2024-10-27 16:35:49'),
			(9,'wusong','123456','武松',1,'13309090009',1,4900,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2011-03-11',1,'2024-10-27 16:35:33','2024-10-27 16:35:51'),
			(10,'lichong','123456','林冲',1,'13309090010',1,5000,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2013-09-05',1,'2024-10-27 16:35:33','2024-10-27 16:35:53'),
			(11,'huyanzhuo','123456','呼延灼',1,'13309090011',2,9700,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2007-02-01',2,'2024-10-27 16:35:33','2024-10-27 16:35:55'),
			(12,'xiaoliguang','123456','小李广',1,'13309090012',2,10000,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2008-08-18',2,'2024-10-27 16:35:33','2024-10-27 16:35:57'),
			(13,'yangzhi','123456','杨志',1,'13309090013',1,5300,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2012-11-01',1,'2024-10-27 16:35:33','2024-10-27 16:35:59'),
			(14,'shijin','123456','史进',1,'13309090014',2,10600,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2002-08-01',2,'2024-10-27 16:35:33','2024-10-27 16:36:01'),
			(15,'sunerniang','123456','孙二娘',2,'13309090015',2,10900,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2011-05-01',2,'2024-10-27 16:35:33','2024-10-27 16:36:03'),
			(16,'luzhishen','123456','鲁智深',1,'13309090016',2,9600,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2010-01-01',2,'2024-10-27 16:35:33','2024-10-27 16:36:05'),
			(17,'liying','12345678','李应',1,'13309090017',1,5800,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2015-03-21',1,'2024-10-27 16:35:33','2024-10-27 16:36:07'),
			(18,'shiqian','123456','时迁',1,'13309090018',2,10200,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2015-01-01',2,'2024-10-27 16:35:33','2024-10-27 16:36:09'),
			(19,'gudasao','123456','顾大嫂',2,'13309090019',2,10500,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2008-01-01',2,'2024-10-27 16:35:33','2024-10-27 16:36:11'),
			(20,'ruanxiaoer','123456','阮小二',1,'13309090020',2,10800,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2018-01-01',2,'2024-10-27 16:35:33','2024-10-27 16:36:13'),
			(21,'ruanxiaowu','123456','阮小五',1,'13309090021',5,5200,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2015-01-01',3,'2024-10-27 16:35:33','2024-10-27 16:36:15'),
			(22,'ruanxiaoqi','123456','阮小七',1,'13309090022',5,5500,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2016-01-01',3,'2024-10-27 16:35:33','2024-10-27 16:36:17'),
			(23,'ruanji','123456','阮籍',1,'13309090023',5,5800,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2012-01-01',3,'2024-10-27 16:35:33','2024-10-27 16:36:19'),
			(24,'tongwei','123456','童威',1,'13309090024',5,5000,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2006-01-01',3,'2024-10-27 16:35:33','2024-10-27 16:36:21'),
			(25,'tongmeng','123456','童猛',1,'13309090025',5,4800,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2002-01-01',3,'2024-10-27 16:35:33','2024-10-27 16:36:23'),
			(26,'yanshun','123456','燕顺',1,'13309090026',5,5400,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2011-01-01',3,'2024-10-27 16:35:33','2024-10-27 16:36:25'),
			(27,'lijun','123456','李俊',1,'13309090027',5,6600,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2004-01-01',3,'2024-10-27 16:35:33','2024-10-27 16:36:27'),
			(28,'lizhong','123456','李忠',1,'13309090028',5,5000,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2007-01-01',3,'2024-10-27 16:35:33','2024-10-27 16:36:29'),
			(29,'songqing','123456','宋清',1,'13309090029',NULL,5100,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2020-01-01',NULL,'2024-10-27 16:35:33','2024-10-27 16:36:31'),
			(30,'liyun','123456','李云',1,'13309090030',NULL,NULL,'https://dawn-itcast.oss-cn-hangzhou.aliyuncs.com/01.png','2020-03-01',NULL,'2024-10-27 16:35:33','2024-10-27 16:36:31');
</code></pre>
<h2 id="内连接"><strong>内连接</strong></h2>
<p>内连接查询：查询两表或多表中交集部分数据。<br>
内连接从语法上可以分为：</p>
<ul>
<li>隐式内连接</li>
<li>显式内连接</li>
</ul>
<pre><code class="language-sql">-- ============================= 内连接 ==========================
-- A. 查询所有员工的ID, 姓名 , 及所属的部门名称 (隐式、显式内连接实现)
select emp.id,emp.name,dept.name from emp,dept where emp.dept_id=dept.id;
-- inner关键字可省略
select emp.id,emp.name,dept.name from emp inner join dept on emp.dept_id=dept.id;


-- B. 查询 性别为男, 且工资 高于8000 的员工的ID, 姓名, 及所属的部门名称 (隐式、显式内连接实现)
select emp.id,emp.name,dept.name from emp,dept where emp.dept_id=dept.id and gender=1 and salary&gt;8000;

select emp.id,emp.name,dept.name from emp join dept on emp.dept_id=dept.id where gender=1 and salary&gt;8000;

-- 为表起别名
select e.id,e.name,d.name from emp e join dept d on e.dept_id=d.id where gender=1 and salary&gt;8000;
</code></pre>
<h2 id="外连接"><strong>外连接</strong></h2>
<p>外连接分为两种：左外连接 和 右外连接，语法中outer可省略。</p>
<pre><code class="language-sql">-- =============================== 外连接 ============================
-- A. 查询员工表 所有 员工的姓名, 和对应的部门名称 (左外连接)
select e.name,d.name from emp e left outer join dept d on e.dept_id = d.id;

-- B. 查询部门表 所有 部门的名称, 和对应的员工名称 (右外连接)
select e.name,d.name from emp e right outer join dept d on e.dept_id = d.id;

-- C. 查询工资 高于8000 的 所有员工的姓名, 和对应的部门名称 (左外连接)
select e.name,d.name from emp e left outer join dept d on e.dept_id = d.id where salary&gt;8000;
</code></pre>
<p>左外连接和右外连接是可以相互替换的，只需要调整连接查询时SQL语句中表的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。</p>
<h2 id="子查询"><strong>子查询</strong></h2>
<p>SQL语句中嵌套select语句，称为嵌套查询，又称子查询。子查询外部的语句可以是insert / update / delete / select 的任何一个，最常见的是 select。<br>
根据子查询结果的不同分为：</p>
<ol>
<li>标量子查询（子查询结果为单个值 [一行一列]）</li>
<li>列子查询（子查询结果为一列，但可以是多行）</li>
<li>行子查询（子查询结果为一行，但可以是多列）</li>
<li>表子查询（子查询结果为多行多列[相当于子查询结果是一张表]）</li>
</ol>
<p>子查询的要点是，先对需求做拆分，明确具体的步骤，然后再逐条编写SQL语句。 最终将多条SQL语句合并为一条。</p>
<pre><code class="language-sql">-- ========================= 子查询 ================================
-- 标量子查询
-- A. 查询 最早入职 的员工信息
-- a.最早入职时间
select min(entry_date) from emp;
-- b.最早入职的员工信息
select * from emp where entry_date= (select min(entry_date) from emp);

-- B. 查询在 &quot;阮小五&quot; 入职之后入职的员工信息
select * from emp where entry_date &gt; (select entry_date from emp where name='阮小五');

-- 列子查询
-- A. 查询 &quot;教研部&quot; 和 &quot;咨询部&quot; 的所有员工信息
-- a.查询教研部和咨询部的id
select id from dept where name='教研部' or name='咨询部';

-- b.查询指定部门ID的员工信息
select * from emp where dept_id in (select id from dept where name='教研部' or name='咨询部');

-- 行子查询
-- A. 查询与 &quot;李忠&quot; 的薪资 及 职位都相同的员工信息 ;
-- a.李忠的薪资和职位
select salary,job from emp where name='李忠';

-- b. 指定薪资和职位的员工信息
select * from emp where (salary, job)=(select salary,job from emp where name='李忠');

-- 表子查询
-- A. 获取每个部门中薪资最高的员工信息
-- a. 每个部门的最高薪资
select dept_id,max(salary) from emp group by dept_id;

-- b. 查询每个部门薪资最高的员工信息
select * from emp e ,(select dept_id,max(salary) max_salary from emp group by dept_id) a
         where e.dept_id=a.dept_id and e.salary=a.max_salary;

select * from emp where (dept_id,salary) in (select dept_id,max(salary) from emp group by dept_id);
</code></pre>
<p>在SQL中，NULL值是特殊的，它既不等于任何值，也不等于另一个NULL值。</p>
<h2 id="案例"><strong>案例</strong></h2>
<pre><code class="language-sql">-- 需求:
-- 1. 查询 &quot;教研部&quot; 性别为 男，且在 &quot;2011-05-01&quot; 之后入职的员工信息 。
select emp.* from emp,dept where emp.dept_id=dept.id and dept.name='教研部' and gender=1 and entry_date&gt;'2011-05-01';

-- 2. 查询工资 低于公司平均工资的 且 性别为男 的员工信息 。
select * from emp where salary&lt;(select avg(salary) from emp) and gender=1;

-- 3. 查询部门人数超过 10 人的部门名称 。
select d.name from emp e join dept d on e.dept_id=d.id group by d.name having count(*) &gt;10;

-- 4. 查询在 &quot;2010-05-01&quot; 后入职，且薪资高于 10000 的 &quot;教研部&quot; 员工信息，并根据薪资倒序排序。
select e.* from emp e,dept d where e.dept_id=d.id and d.name='教研部'
                               and salary&gt;10000 and entry_date&gt;'2010-05-01' order by salary desc;


-- 5. 查询工资 低于本部门平均工资的员工信息 。
select avg(salary),dept_id from emp group by dept_id;
select e.* from emp e,(select avg(salary) avg_sal,dept_id from emp group by dept_id) a
           where e.dept_id=a.dept_id and e.salary&lt;a.avg_sal;
</code></pre>
<h1 id="员工列表查询"><strong>员工列表查询</strong></h1>
<h2 id="准备工作"><strong>准备工作</strong></h2>
<p>1). 创建员工管理相关表结构</p>
<pre><code class="language-sql">-- 员工表
create table emp(
    id int unsigned primary key auto_increment comment 'ID,主键',
    username varchar(20) not null unique comment '用户名',
    password varchar(32) default '123456' comment '密码',
    name varchar(10) not null comment '姓名',
    gender tinyint unsigned not null comment '性别, 1:男, 2:女',
    phone char(11) not null unique comment '手机号',
    job tinyint unsigned comment '职位, 1 班主任, 2 讲师 , 3 学工主管, 4 教研主管, 5 咨询师',
    salary int unsigned comment '薪资',
    image varchar(255) comment '头像',
    entry_date date comment '入职日期',
    dept_id int unsigned comment '部门ID',
    create_time datetime comment '创建时间',
    update_time datetime comment '修改时间'
) comment '员工表';


INSERT INTO emp VALUES 
(1,'shinaian','123456','施耐庵',1,'13309090001',4,15000,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2000-01-01',2,'2023-10-20 16:35:33','2023-11-16 16:11:26'),
(2,'songjiang','123456','宋江',1,'13309090002',2,8600,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2015-01-01',2,'2023-10-20 16:35:33','2023-10-20 16:35:37'),
(3,'lujunyi','123456','卢俊义',1,'13309090003',2,8900,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2008-05-01',2,'2023-10-20 16:35:33','2023-10-20 16:35:39'),
(4,'wuyong','123456','吴用',1,'13309090004',2,9200,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2007-01-01',2,'2023-10-20 16:35:33','2023-10-20 16:35:41'),
(5,'gongsunsheng','123456','公孙胜',1,'13309090005',2,9500,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2012-12-05',2,'2023-10-20 16:35:33','2023-10-20 16:35:43'),
(6,'huosanniang','123456','扈三娘',2,'13309090006',3,6500,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2013-09-05',1,'2023-10-20 16:35:33','2023-10-20 16:35:45'),
(7,'chaijin','123456','柴进',1,'13309090007',1,4700,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2005-08-01',1,'2023-10-20 16:35:33','2023-10-20 16:35:47'),
(8,'likui','123456','李逵',1,'13309090008',1,4800,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2014-11-09',1,'2023-10-20 16:35:33','2023-10-20 16:35:49'),
(9,'wusong','123456','武松',1,'13309090009',1,4900,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2011-03-11',1,'2023-10-20 16:35:33','2023-10-20 16:35:51'),
(10,'linchong','123456','林冲',1,'13309090010',1,5000,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2013-09-05',1,'2023-10-20 16:35:33','2023-10-20 16:35:53'),
(11,'huyanzhuo','123456','呼延灼',1,'13309090011',2,9700,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2007-02-01',2,'2023-10-20 16:35:33','2023-10-20 16:35:55'),
(12,'xiaoliguang','123456','小李广',1,'13309090012',2,10000,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2008-08-18',2,'2023-10-20 16:35:33','2023-10-20 16:35:57'),
(13,'yangzhi','123456','杨志',1,'13309090013',1,5300,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2012-11-01',1,'2023-10-20 16:35:33','2023-10-20 16:35:59'),
(14,'shijin','123456','史进',1,'13309090014',2,10600,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2002-08-01',2,'2023-10-20 16:35:33','2023-10-20 16:36:01'),
(15,'sunerniang','123456','孙二娘',2,'13309090015',2,10900,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2011-05-01',2,'2023-10-20 16:35:33','2023-10-20 16:36:03'),
(16,'luzhishen','123456','鲁智深',1,'13309090016',2,9600,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2010-01-01',2,'2023-10-20 16:35:33','2023-10-20 16:36:05'),
(17,'liying','12345678','李应',1,'13309090017',1,5800,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2015-03-21',1,'2023-10-20 16:35:33','2023-10-20 16:36:07'),
(18,'shiqian','123456','时迁',1,'13309090018',2,10200,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2015-01-01',2,'2023-10-20 16:35:33','2023-10-20 16:36:09'),
(19,'gudasao','123456','顾大嫂',2,'13309090019',2,10500,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2008-01-01',2,'2023-10-20 16:35:33','2023-10-20 16:36:11'),
(20,'ruanxiaoer','123456','阮小二',1,'13309090020',2,10800,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2018-01-01',2,'2023-10-20 16:35:33','2023-10-20 16:36:13'),
(21,'ruanxiaowu','123456','阮小五',1,'13309090021',5,5200,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2015-01-01',3,'2023-10-20 16:35:33','2023-10-20 16:36:15'),
(22,'ruanxiaoqi','123456','阮小七',1,'13309090022',5,5500,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2016-01-01',3,'2023-10-20 16:35:33','2023-10-20 16:36:17'),
(23,'ruanji','123456','阮籍',1,'13309090023',5,5800,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2012-01-01',3,'2023-10-20 16:35:33','2023-10-20 16:36:19'),
(24,'tongwei','123456','童威',1,'13309090024',5,5000,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2006-01-01',3,'2023-10-20 16:35:33','2023-10-20 16:36:21'),
(25,'tongmeng','123456','童猛',1,'13309090025',5,4800,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2002-01-01',3,'2023-10-20 16:35:33','2023-10-20 16:36:23'),
(26,'yanshun','123456','燕顺',1,'13309090026',5,5400,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2011-01-01',3,'2023-10-20 16:35:33','2023-11-08 22:12:46'),
(27,'lijun','123456','李俊',1,'13309090027',2,6600,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2004-01-01',2,'2023-10-20 16:35:33','2023-11-16 17:56:59'),
(28,'lizhong','123456','李忠',1,'13309090028',5,5000,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2007-01-01',3,'2023-10-20 16:35:33','2023-11-17 16:34:22'),
(30,'liyun','123456','李云',1,'13309090030',NULL,NULL,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2020-03-01',NULL,'2023-10-20 16:35:33','2023-10-20 16:36:31'),
(36,'linghuchong','123456','令狐冲',1,'18809091212',2,6800,'https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg','2023-10-19',2,'2023-10-20 20:44:54','2023-11-09 09:41:04');


-- 员工工作经历信息
create table emp_expr(
    id int unsigned primary key auto_increment comment 'ID, 主键',
    emp_id int unsigned comment '员工ID',
    begin date comment '开始时间',
    end  date comment '结束时间',
    company varchar(50) comment '公司名称',
    job varchar(50) comment '职位'
)comment '工作经历';
</code></pre>
<p>2). 准备emp表对应的实体类Emp、EmpExpr</p>
<pre><code class="language-java">@Data
public class Emp {
    private Integer id; //ID,主键
    private String username; //用户名
    private String password; //密码
    private String name; //姓名
    private Integer gender; //性别, 1:男, 2:女
    private String phone; //手机号
    private Integer job; //职位, 1:班主任,2:讲师,3:学工主管,4:教研主管,5:咨询师
    private Integer salary; //薪资
    private String image; //头像
    private LocalDate entryDate; //入职日期
    private Integer deptId; //关联的部门ID
    private LocalDateTime createTime; //创建时间
    private LocalDateTime updateTime; //修改时间
}
</code></pre>
<pre><code class="language-java">@Data
public class EmpExpr {
    private Integer id; //ID
    private Integer empId; //员工ID
    private LocalDate begin; //开始时间
    private LocalDate end; //结束时间
    private String company; //公司名称
    private String job; //职位
}
</code></pre>
<p>3). 准备Emp员工管理的基础结构，包括Controller、Service、Mapper</p>
<pre><code class="language-sql">-- 查询所有的员工信息，如果员工关联了部门，也要查询出部门名称
select e.*, d.name as dept_name from emp e left join dept d on e.dept_id = d.id;
</code></pre>
<h2 id="分页查询"><strong>分页查询</strong></h2>
<ol>
<li>前端在请求服务端时，传递的参数</li>
</ol>
<ul>
<li>当前页码  page</li>
<li>每页显示条数  pageSize</li>
</ul>
<ol start="2">
<li>后端需要响应什么数据给前端</li>
</ol>
<ul>
<li>所查询到的数据列表（存储到List 集合中）</li>
<li>总记录数</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250617193154.png" alt="" loading="lazy"><br>
请求路径：/emps<br>
请求方式：GET<br>
接口描述：该接口用于员工列表数据的条件分页查询<br>
参数格式：queryString<br>
参数说明：</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>是否必须</th>
<th>示例</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>否</td>
<td>张</td>
<td>姓名</td>
</tr>
<tr>
<td>gender</td>
<td>否</td>
<td>1</td>
<td>性别 , 1 男 , 2 女</td>
</tr>
<tr>
<td>begin</td>
<td>否</td>
<td>2010-01-01</td>
<td>范围匹配的开始时间(入职日期)</td>
</tr>
<tr>
<td>end</td>
<td>否</td>
<td>2020-01-01</td>
<td>范围匹配的结束时间(入职日期)</td>
</tr>
<tr>
<td>page</td>
<td>是</td>
<td>1</td>
<td>分页查询的页码，如果未指定，默认为1</td>
</tr>
<tr>
<td>pageSize</td>
<td>是</td>
<td>10</td>
<td>分页查询的每页记录数，如果未指定，默认为10</td>
</tr>
</tbody>
</table>
<p>请求数据样例：<br>
/emps?name=张&amp;gender=1&amp;begin=2007-09-01&amp;end=2022-09-01&amp;page=1&amp;pageSize=10<br>
后台给前端返回的数据包含：List集合(数据列表)、total(总记录数)。而这两部分我们通常封装到PageResult对象中，并将该对象转换为json格式的数据响应回给浏览器。响应数据样例：</p>
<pre><code class="language-json">{
  &quot;code&quot;: 1,
  &quot;msg&quot;: &quot;success&quot;,
  &quot;data&quot;: {
    &quot;total&quot;: 2,
    &quot;rows&quot;: [
       {
        &quot;id&quot;: 1,
        &quot;username&quot;: &quot;jinyong&quot;,
        &quot;name&quot;: &quot;金庸&quot;,
        &quot;gender&quot;: 1,
        &quot;image&quot;: &quot;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-53B.jpg&quot;,
        &quot;job&quot;: 2,
        &quot;salary&quot;: 8000,
        &quot;entryDate&quot;: &quot;2015-01-01&quot;,
        &quot;deptId&quot;: 2,
        &quot;deptName&quot;: &quot;教研部&quot;,
        &quot;createTime&quot;: &quot;2022-09-01T23:06:30&quot;,
        &quot;updateTime&quot;: &quot;2022-09-02T00:29:04&quot;
      },
      {
        &quot;id&quot;: 2,
        &quot;username&quot;: &quot;zhangwuji&quot;,
        &quot;name&quot;: &quot;张无忌&quot;,
        &quot;gender&quot;: 1,
        &quot;image&quot;: &quot;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-53B.jpg&quot;,
        &quot;job&quot;: 2,
        &quot;salary&quot;: 6000,
        &quot;entryDate&quot;: &quot;2015-01-01&quot;,
        &quot;deptId&quot;: 2,
        &quot;deptName&quot;: &quot;教研部&quot;,
        &quot;createTime&quot;: &quot;2022-09-01T23:06:30&quot;,
        &quot;updateTime&quot;: &quot;2022-09-02T00:29:04&quot;
      }
    ]
  }
}
</code></pre>
<pre><code class="language-java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class PageResult&lt;T&gt; {
    private Long total; //总记录数
    private List&lt;T&gt; rows; //当前页数据列表
}
</code></pre>
<h3 id="代码实现"><strong>代码实现</strong></h3>
<p>1). EmpController</p>
<pre><code class="language-java">@Slf4j
@RestController
@RequestMapping(&quot;/emps&quot;)
public class EmpController {
    @Autowired
    private EmpService empService;

    @GetMapping
    public Result page(@RequestParam(defaultValue = &quot;1&quot;) Integer page,
                       @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize){
        log.info(&quot;分页查询：{},{}&quot;,page,pageSize);
        PageResult&lt;Emp&gt; pageResult =empService.page(page,pageSize);
        return Result.success(pageResult);
    }
}
</code></pre>
<p>@RequestParam(defaultValue=&quot;默认值&quot;)   //设置请求参数默认值<br>
2). EmpService</p>
<pre><code class="language-java">@Service
public class EmpServiceImpl implements EmpService {

    @Autowired
    private EmpMapper empMapper;

    @Override
    public PageResult&lt;Emp&gt; page(Integer page, Integer pageSize) {
        Long total=empMapper.count();
        Integer start=(page-1)*pageSize;
        List&lt;Emp&gt; rows= empMapper.list(start, pageSize);
        return new PageResult&lt;Emp&gt;(total, rows);
    }
}
</code></pre>
<p>3). EmpMapper</p>
<pre><code class="language-java">@Mapper
public interface EmpMapper {

    @Select(&quot;select count(*) from emp e left join dept d on e.dept_id=d.id&quot;)
    public Long count();

    @Select(&quot;select e.* ,d.name deptName from emp e left join dept d on e.dept_id=d.id order by e.update_time desc limit #{start},#{pageSize} &quot;)
    public List&lt;Emp&gt; list(Integer start,Integer pageSize);
}
</code></pre>
<h3 id="pagehelper分页插件"><strong>PageHelper分页插件</strong></h3>
<p>分页查询的思路、步骤是比较固定的。 在Mapper接口中定义两个方法执行两条不同的SQL语句：</p>
<ol>
<li>查询总记录数</li>
<li>指定页码的数据列表<br>
在Service当中，调用Mapper接口的两个方法，分别获取：总记录数、查询结果列表，然后在将获取的数据结果封装到PageBean对象中。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250617203958.png" alt="" loading="lazy"><br>
PageHelper是第三方提供的Mybatis框架中的一款功能强大、方便易用的分页插件，支持任何形式的单标、多表的分页查询。当使用了PageHelper分页插件进行分页，就无需再Mapper中进行手动分页了。 在Mapper中我们只需要进行正常的列表查询即可。在Service层中，调用Mapper的方法之前设置分页参数，在调用Mapper方法执行查询之后，解析分页结果，并将结果封装到PageResult对象中返回。<br>
1). 在pom.xml引入依赖</li>
</ol>
<pre><code class="language-xml">&lt;!--分页插件PageHelper--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.4.7&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2). EmpServiceImpl</p>
<pre><code class="language-java">@Override
public PageResult page(Integer page, Integer pageSize) {
    //1. 设置分页参数
    PageHelper.startPage(page,pageSize);

    //2. 执行查询
    List&lt;Emp&gt; empList = empMapper.list();
    Page&lt;Emp&gt; p = (Page&lt;Emp&gt;) empList;

    //3. 封装结果
    return new PageResult(p.getTotal(), p.getResult());
}
</code></pre>
<ul>
<li>实现机制</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250617210752.png" alt="" loading="lazy"><br>
其实就是将我们编写的SQL语句进行的改造增强，将查询返回的字段列表替换成了 count(0) 来统计总记录数且在SQL语句之后拼接上了limit进行分页查询。而PageHelper在进行分页查询时，会执行上述两条SQL语句，并将查询到的总记录数，与数据列表封装到了 Page<Emp> 对象中，我们再获取查询结果时，只需要调用Page对象的方法就可以获取。</p>
<pre><code class="language-java">List&lt;Emp&gt; empList = empMapper.list();
</code></pre>
<p>虽然 empMapper.list() 返回的是 List<Emp> 类型，但底层返回的是 com.github.pagehelper.Page<Emp>，它实现了 List<Emp> 接口。<br>
注意：</p>
<ul>
<li>PageHelper实现分页查询时，SQL语句的结尾一定一定一定不要加分号(;)。</li>
<li>PageHelper只会对紧跟在其后的第一条SQL语句进行分页处理（Service层）。</li>
</ul>
<h2 id="条件分页查询"><strong>条件分页查询</strong></h2>
<p>sql语句字符串拼接：</p>
<pre><code class="language-sql">select concat('%','阮','%')
</code></pre>
<h3 id="功能开发"><strong>功能开发</strong></h3>
<p>1). 在EmpController方法中通过多个方法形参，依次接收这几个参数</p>
<pre><code class="language-java">@Slf4j
@RestController
@RequestMapping(&quot;/emps&quot;)
public class EmpController {
    @Autowired
    private EmpService empService;

    @GetMapping
    public Result page(@RequestParam(defaultValue = &quot;1&quot;) Integer page,
                       @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize,
                       String name,
                       Integer gender,
                       @DateTimeFormat(pattern = &quot;yyy-MM-dd&quot;) LocalDate begin,
                       @DateTimeFormat(pattern = &quot;yyy-MM-dd&quot;) LocalDate end) {
        log.info(&quot;分页查询：{},{},{},{},{},{}&quot;,page,pageSize,name,gender,begin,end);
        PageResult&lt;Emp&gt; pageResult =empService.page(page,pageSize,name,gender,begin,end);
        return Result.success(pageResult);
    }
}
</code></pre>
<p>日期时间类型参数接收时，需要通过@DateTimeFormat注解指定前端传递的日期格式。<br>
2). 修改EmpService及EmpServiceImpl中的代码逻辑</p>
<pre><code class="language-java">@Override
    public PageResult&lt;Emp&gt; page(Integer page, Integer pageSize,
                                String name,
                                Integer gender,
                                LocalDate begin,
                                LocalDate end) {
        //1.设置分页参数
        PageHelper.startPage(page, pageSize);
        //2.执行查询
        List&lt;Emp&gt; empList=empMapper.list(name, gender, begin, end);
        //3.解析查询结果，并封装
        Page&lt;Emp&gt; p= (Page&lt;Emp&gt;) empList;
        return new PageResult&lt;Emp&gt;(p.getTotal(),p.getResult());
    }
</code></pre>
<p>3). 调整EmpMapper接口方法</p>
<pre><code class="language-java">public List&lt;Emp&gt; list(String name, Integer gender, LocalDate begin, LocalDate end);
</code></pre>
<p>由于SQL语句比较复杂，建议将SQL语句配置在XML映射文件中。<br>
4). 新增Mapper映射文件EmpMapper.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.ys.mapper.EmpMapper&quot;&gt;

    &lt;select id=&quot;list&quot; resultType=&quot;com.ys.pojo.Emp&quot;&gt;
        select e.* ,d.name from emp e left join dept d on e.dept_id=d.id
        where e.name like concat('%',#{name},'%')
          and gender=#{gender}
          and e.entry_date between #{begin} and #{end}
        order by e.update_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="程序优化"><strong>程序优化</strong></h3>
<p>在上述分页条件查询中，请求参数比较多，有6个，如下所示：</p>
<ul>
<li>请求参数：/emps?name=张&amp;gender=1&amp;begin=2007-09-01&amp;end=2022-09-01&amp;page=1&amp;pageSize=10</li>
</ul>
<p>那我们在controller层方法中，接收请求参数的时候，直接在controller方法中声明这样6个参数即可，这样做，功能可以实现，但是不方便维护和管理。<br>
优化思路：定义一个实体类，来封装这几个请求参数。 【需要保证，前端传递的请求参数和实体类的属性名是一样的】<br>
1). 定义实体类：EmpQueryParam</p>
<pre><code class="language-java">@Data
public class EmpQueryParam {
    private Integer page=1;
    private Integer pageSize=10;
    private String name; //姓名
    private Integer gender; //性别
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
    private LocalDate begin; //入职开始时间
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
    private LocalDate end; //入职结束时间
}
</code></pre>
<p>2). EmpController接收请求参数</p>
<pre><code class="language-java">@Slf4j
@RestController
@RequestMapping(&quot;/emps&quot;)
public class EmpController {
    @Autowired
    private EmpService empService;

    @GetMapping
    public Result page(EmpQueryParam empQueryParam) {
        log.info(&quot;分页查询：{}&quot;,empQueryParam);
        PageResult&lt;Emp&gt; pageResult =empService.page(empQueryParam);
        return Result.success(pageResult);
    }
}
</code></pre>
<p>3). 修改EmpServiceImpl中的page方法</p>
<pre><code class="language-java">@Override
    public PageResult&lt;Emp&gt; page(EmpQueryParam empQueryParam) {
        //1.设置分页参数
        PageHelper.startPage(empQueryParam.getPage(), empQueryParam.getPageSize());
        //2.执行查询
        List&lt;Emp&gt; empList=empMapper.list(empQueryParam);
        //3.解析查询结果，并封装
        Page&lt;Emp&gt; p= (Page&lt;Emp&gt;) empList;
        return new PageResult&lt;Emp&gt;(p.getTotal(),p.getResult());
    }
}
</code></pre>
<p>4). 修改EmpMapper接口方法</p>
<pre><code class="language-java">public List&lt;Emp&gt; list(EmpQueryParam empQueryParam);
</code></pre>
<p>5). EmpMapper.xml 中配置修改<br>
当前，我们在查询的时候，Mapper映射配置文件中的SQL语句中，查询条件是写死的。 而我们在员工管理中，根据条件查询员工信息时，查询条件是可选的，可以输入也可以不输入。我们看到，这个SQL语句不应该是写死的，而应该根据用户输入的条件的变化而变化。 那这里呢，就要通过Mybatis中的动态SQL来实现。</p>
<ul>
<li>所谓动态SQL，指的就是随着用户的输入或外部的条件的变化而变化的SQL语句。</li>
<li>&lt;if&gt;：判断条件是否成立，如果条件为true，则拼接SQL。</li>
<li>&lt;where&gt;：根据查询条件，来生成where关键字，并会自动去除条件前面多余的and或or。</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.ys.mapper.EmpMapper&quot;&gt;

    &lt;select id=&quot;list&quot; resultType=&quot;com.ys.pojo.Emp&quot;&gt;
        select e.* ,d.name deptName from emp e left join dept d on e.dept_id=d.id
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != ''&quot;&gt;
                e.name like concat('%',#{name},'%')
            &lt;/if&gt;
            &lt;if test=&quot;gender != null&quot;&gt;
                and e.gender = #{gender}
            &lt;/if&gt;
            &lt;if test=&quot;begin != null and end != null&quot;&gt;
                and e.entry_date between #{begin} and #{end}
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[后端Web实战(部门管理)]]></title>
        <id>https://yyss1014.github.io/post/hou-duan-web-shi-zhan-bu-men-guan-li/</id>
        <link href="https://yyss1014.github.io/post/hou-duan-web-shi-zhan-bu-men-guan-li/">
        </link>
        <updated>2025-06-11T09:21:23.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><strong>准备工作</strong></a>
<ul>
<li><a href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91"><strong>前后端分离开发</strong></a></li>
<li><a href="#restful%E9%A3%8E%E6%A0%BC"><strong>Restful风格</strong></a></li>
<li><a href="#apifox"><strong>Apifox</strong></a></li>
<li><a href="#%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA"><strong>工程搭建</strong></a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E8%AF%A2%E9%83%A8%E9%97%A8"><strong>查询部门</strong></a>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><strong>代码实现</strong></a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85"><strong>数据封装</strong></a>
<ul>
<li><a href="#%E6%89%8B%E5%8A%A8%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84"><strong>手动结果映射</strong></a></li>
<li><a href="#%E8%B5%B7%E5%88%AB%E5%90%8D"><strong>起别名</strong></a></li>
<li><a href="#%E5%BC%80%E5%90%AF%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D"><strong>开启驼峰命名</strong></a></li>
</ul>
</li>
<li><a href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E5%90%88%E6%B5%8B%E8%AF%95"><strong>前后端联合测试</strong></a></li>
</ul>
</li>
<li><a href="#%E5%88%A0%E9%99%A4%E9%83%A8%E9%97%A8"><strong>删除部门</strong></a>
<ul>
<li><a href="#%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6"><strong>简单参数接收</strong></a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><strong>代码实现</strong></a></li>
</ul>
</li>
<li><a href="#%E6%96%B0%E5%A2%9E%E9%83%A8%E9%97%A8"><strong>新增部门</strong></a>
<ul>
<li><a href="#json%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6"><strong>json参数接收</strong></a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><strong>代码实现</strong></a></li>
</ul>
</li>
<li><a href="#%E4%BF%AE%E6%94%B9%E9%83%A8%E9%97%A8"><strong>修改部门</strong></a>
<ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E5%9B%9E%E6%98%BE"><strong>查询回显</strong></a>
<ul>
<li><a href="#%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6"><strong>路径参数接收</strong></a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><strong>代码实现</strong></a></li>
</ul>
</li>
<li><a href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><strong>修改数据</strong></a>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><strong>代码实现</strong></a></li>
<li><a href="#requestmapping"><strong>@RequestMapping</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF"><strong>日志技术</strong></a>
<ul>
<li><a href="#logback%E5%85%A5%E9%97%A8"><strong>Logback入门</strong></a></li>
<li><a href="#logback%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><strong>Logback配置文件</strong></a></li>
<li><a href="#logback%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><strong>Logback日志级别</strong></a></li>
<li><a href="#%E6%A1%88%E4%BE%8B%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><strong>案例日志记录</strong></a></li>
</ul>
</li>
</ul>
</p>
<h1 id="准备工作"><strong>准备工作</strong></h1>
<h2 id="前后端分离开发"><strong>前后端分离开发</strong></h2>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250611172203.png" alt="" loading="lazy"><br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250611172240.png" alt="" loading="lazy"></p>
<ol>
<li>需求分析：首先我们需要阅读需求文档，分析需求，理解需求。</li>
<li>接口定义：查询接口文档中关于需求的接口的定义，包括地址，参数，响应数据类型等等</li>
<li>前后台并行开发：各自按照接口文档进行开发，实现需求</li>
<li>测试：前后台开发完了，各自按照接口文档进行测试</li>
<li>前后段联调测试：前段工程请求后端工程，测试功能</li>
</ol>
<h2 id="restful风格"><strong>Restful风格</strong></h2>
<ul>
<li>REST（Representational State Transfer），表述性状态转换，它是一种软件架构风格。</li>
</ul>
<p>传统URL风格如下：</p>
<ul>
<li>http://localhost:8080/user/getById?id=1      GET：查询id为1的用户</li>
<li>http://localhost:8080/user/saveUser            POST：新增用户</li>
<li>http://localhost:8080/user/updateUser         POST：修改用户</li>
<li>http://localhost:8080/user/deleteUser?id=1  GET：删除id为1的用户</li>
</ul>
<p>于开发人员来说，每一个开发人员都有自己的命名习惯，就拿根据id查询用户信息来说的，不同的开发人员定义的路径可能是这样的：getById，selectById，queryById，loadById... 。 每一个人都有自己的命名习惯，如果都按照各自的习惯来，一个项目组，几十号或上百号人，那最终开发出来的项目，将会变得难以维护，没有一个统一的标准。<br>
基于REST风格URL如下：</p>
<ul>
<li>http://localhost:8080/users/1       GET：查询id为1的用户</li>
<li>http://localhost:8080/users          POST：新增用户</li>
<li>http://localhost:8080/users          PUT：修改用户</li>
<li>http://localhost:8080/users/1       DELETE：删除id为1的用户</li>
</ul>
<p>通过URL定位要操作的资源，通过HTTP动词(请求方式)来描述具体的操作。在REST风格的URL中，通过四种请求方式，来操作数据的增删改查。</p>
<ul>
<li>GET ：  查询</li>
<li>POST ：新增</li>
<li>PUT ：  修改</li>
<li>DELETE ：删除</li>
</ul>
<p>注意事项：</p>
<ul>
<li>REST是风格，是约定方式，约定不是规定，可以打破</li>
<li>描述模块的功能通常使用复数，也就是加s的格式来描述，表示此类资源，而非单个资源。如：users、emps、books…</li>
</ul>
<h2 id="apifox"><strong>Apifox</strong></h2>
<p>因为在浏览器地中所发起的所有的请求，都是GET方式的请求。那大家就需要思考两个问题：</p>
<ul>
<li>前后端都在并行开发，后端开发完对应的接口之后，如何对接口进行请求测试呢？</li>
<li>前后端都在并行开发，前端开发过程中，如何获取到数据，测试页面的渲染展示呢？<br>
那这里我们就可以借助一些接口测试工具，比如项：Postman、Apipost、Apifox等。<br>
介绍：Apifox是一款集成了Api文档、Api调试、Api Mock、Api测试的一体化协作平台。<br>
作用：接口文档管理、接口请求测试、Mock服务。<br>
官网： https://apifox.com/</li>
</ul>
<h2 id="工程搭建"><strong>工程搭建</strong></h2>
<p>1). 创建SpringBoot工程，并引入web开发起步依赖、mybatis、mysql驱动、lombok。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250613201854.png" alt="" loading="lazy"><br>
2). 创建数据库及对应的表结构，并在application.yml中配置数据库的基本信息。</p>
<pre><code class="language-sql">CREATE TABLE dept (
  id int unsigned PRIMARY KEY AUTO_INCREMENT COMMENT 'ID, 主键',
  name varchar(10) NOT NULL UNIQUE COMMENT '部门名称',
  create_time datetime DEFAULT NULL COMMENT '创建时间',
  update_time datetime DEFAULT NULL COMMENT '修改时间'
) COMMENT '部门表';

INSERT INTO dept VALUES (1,'学工部','2023-09-25 09:47:40','2024-07-25 09:47:40'),
                      (2,'教研部','2023-09-25 09:47:40','2024-08-09 15:17:04'),
                      (3,'咨询部','2023-09-25 09:47:40','2024-07-30 21:26:24'),
                      (4,'就业部','2023-09-25 09:47:40','2024-07-25 09:47:40'),
                      (5,'人事部','2023-09-25 09:47:40','2024-07-25 09:47:40'),
                      (6,'行政部','2023-11-30 20:56:37','2024-07-30 20:56:37');```
```yaml
spring:
  application:
    name: tlias-web-management
  datasource:
    url: jdbc:mysql://localhost:3306/tlias
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: 123456
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
</code></pre>
<p>3). 准备基础包结构，并引入实体类Dept及统一的响应结果封装类Result。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250613203014.png" alt="" loading="lazy"></p>
<ul>
<li>实体类Dept</li>
</ul>
<pre><code class="language-java">package com.ys.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Dept {
    private Integer id;
    private String name;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
}
</code></pre>
<ul>
<li>统一响应结果Result</li>
</ul>
<pre><code class="language-java">package com.ys.pojo;

import lombok.Data;
import java.io.Serializable;

/**
 * 后端统一返回结果
 */
@Data
public class Result {

    private Integer code; //编码：1成功，0为失败
    private String msg; //错误信息
    private Object data; //数据

    public static Result success() {
        Result result = new Result();
        result.code = 1;
        result.msg = &quot;success&quot;;
        return result;
    }

    public static Result success(Object object) {
        Result result = new Result();
        result.data = object;
        result.code = 1;
        result.msg = &quot;success&quot;;
        return result;
    }

    public static Result error(String msg) {
        Result result = new Result();
        result.msg = msg;
        result.code = 0;
        return result;
    }

}
</code></pre>
<h1 id="查询部门"><strong>查询部门</strong></h1>
<p>查询所有的部门数据，查询出来展示在部门管理的页面中。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616142624.png" alt="" loading="lazy"></p>
<h2 id="代码实现"><strong>代码实现</strong></h2>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616151027.png" alt="" loading="lazy"><br>
1). Controller层</p>
<pre><code class="language-java">@RestController
public class DeptController {
    @Autowired
    private DeptService deptService;
    //@RequestMapping(value = &quot;/depts&quot;,method = RequestMethod.GET)//指定请求方式
    @GetMapping(&quot;/depts&quot;)
    public Result list(){
        System.out.println(&quot;查询全部部门数据&quot;);
        List&lt;Dept&gt; deptList= deptService.findALL();
        return Result.success(deptList);
    }
}
</code></pre>
<ul>
<li>GET方式：@GetMapping</li>
<li>POST方式：@PostMapping</li>
<li>PUT方式：@PutMapping</li>
<li>DELETE方式：@DeleteMapping</li>
</ul>
<p>2). Service层</p>
<pre><code class="language-java">public interface DeptService {
//    查询所有部门
    List&lt;Dept&gt; findALL();
}
</code></pre>
<pre><code class="language-java">@Service
public class DeptServiceImpl implements DeptService {
    @Autowired
    private DeptMapper deptMapper;
    @Override
    public List&lt;Dept&gt; findALL() {
        return deptMapper.findALL();
    }
}
</code></pre>
<p>3). Mapper层</p>
<pre><code class="language-java">@Mapper
public interface DeptMapper {
    @Select(&quot;select id, name, create_time, update_time from dept order by update_time desc&quot;)
    List&lt;Dept&gt; findALL();
}
</code></pre>
<p>打开Apifox进行测试：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616151927.png" alt="" loading="lazy"></p>
<h2 id="数据封装"><strong>数据封装</strong></h2>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616151810.png" alt="" loading="lazy"></figure>
<ul>
<li>实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。</li>
<li>如果实体类属性名和数据库表查询返回的字段名不一致，不能自动封装。</li>
</ul>
<h3 id="手动结果映射"><strong>手动结果映射</strong></h3>
<p>Mapper：</p>
<pre><code class="language-java">@Mapper
public interface DeptMapper {
    @Results({
            @Result(column = &quot;create_time&quot;,property = &quot;createTime&quot;),
            @Result(column = &quot;update_time&quot;,property = &quot;updateTime&quot;)
    })
    @Select(&quot;select id, name, create_time, update_time from dept order by update_time desc&quot;)
    List&lt;Dept&gt; findALL();
}
</code></pre>
<p>Results注解：</p>
<pre><code class="language-java">@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface Results {
    String id() default &quot;&quot;;

    Result[] value() default {};
}
</code></pre>
<p>Result注解：</p>
<pre><code class="language-java">@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
@Repeatable(Results.class)
public @interface Result {
    boolean id() default false;

    String column() default &quot;&quot;;

    String property() default &quot;&quot;;

    Class&lt;?&gt; javaType() default void.class;

    JdbcType jdbcType() default JdbcType.UNDEFINED;

    Class&lt;? extends TypeHandler&gt; typeHandler() default UnknownTypeHandler.class;

    One one() default @One;

    Many many() default @Many;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616153119.png" alt="" loading="lazy"></figure>
<h3 id="起别名"><strong>起别名</strong></h3>
<pre><code class="language-java">@Mapper
public interface DeptMapper {
    /*@Results({
            @Result(column = &quot;create_time&quot;,property = &quot;createTime&quot;),
            @Result(column = &quot;update_time&quot;,property = &quot;updateTime&quot;)
    })*/
    @Select(&quot;select id, name, create_time createTime, update_time updateTime from dept order by update_time desc&quot;)
    List&lt;Dept&gt; findALL();
}
</code></pre>
<h3 id="开启驼峰命名"><strong>开启驼峰命名</strong></h3>
<p>如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射。驼峰命名规则：   abc_xyz    =&gt;   abcXyz</p>
<ul>
<li>表中字段名：abc_xyz</li>
<li>类中属性名：abcXyz</li>
</ul>
<p>在application.yml中做如下配置，开启开关。</p>
<pre><code class="language-yml">spring:
  application:
    name: tlias-web-management
  datasource:
    url: jdbc:mysql://localhost:3306/tlias
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: 123456
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    # 开启驼峰命名
    map-underscore-to-camel-case: true
</code></pre>
<h2 id="前后端联合测试"><strong>前后端联合测试</strong></h2>
<p>其中Fetch/XHR过滤Ajax请求。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616155201.png" alt="" loading="lazy"><br>
前端工程请求服务器的地址为 http://localhost:90/api/depts，是如何访问到后端的tomcat服务器的？<br>
其实这里，是通过前端服务Nginx中提供的反向代理功能实现的。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616155417.png" alt="" loading="lazy"><br>
1). 浏览器发起请求，请求的是localhost:90 ，那其实请求的是nginx服务器。<br>
2). 在nginx服务器中呢，并没有对请求直接进行处理，而是将请求转发给了后端的tomcat服务器，最终由tomcat服务器来处理该请求。<br>
直接请求nginx服务器主要有以下几点原因：<br>
1). 安全：由于后端的tomcat服务器一般都会搭建集群，会有很多的服务器，把所有的tomcat暴露给前端，让前端直接请求tomcat，对于后端服务器是比较危险的。<br>
2). 灵活：基于nginx的反向代理实现，更加灵活，后端想增加、减少服务器，对于前端来说是无感知的，只需要在nginx中配置即可。<br>
3). 负载均衡：基于nginx的反向代理，可以很方便的实现后端tomcat的负载均衡操作。<br>
具体的请求访问流程如下：<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616155604.png" alt="" loading="lazy"></p>
<ol>
<li>server：配置了一台nginx代理服务器。</li>
<li>listen：监听端口90。</li>
<li>location：用于定义匹配特定uri请求的规则。</li>
<li>^~ /api/：^~用于路径前缀匹配，且优先级高于正则匹配。（Nginx 的 location 匹配规则只关注请求的 路径部分，即 URL 中从第一个 / 开始的部分。例如，对于请求 http://localhost:90/api/depts，Nginx 只会关注 /api/depts 这部分）</li>
<li>^/api/(.*)$ /<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \* at position 16: 1：(.*)中.表示任意字符，\̲*̲表示任意次，'>1：(.*)中.表示任意字符，\*表示任意次，</span>符号用于检查匹配字符是否是输入字符串的最后一个字符，()相当于分组，其路径只有一个小括号就只有一组。</li>
<li>rewrite：该指令用于重写匹配到的uri路径。</li>
<li>proxy_pass：该指令用于代理转发，它将匹配到的请求转发给位于后端的指令服务器。</li>
</ol>
<p>nginx.conf：</p>
<pre><code class="language-config">#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       90;
        server_name  localhost;
        client_max_body_size 10m;
        
        location / {
            root   html;
            index  index.html index.htm;
            try_files $uri $uri/ /index.html;
        }

        location ^~ /api/ {
			rewrite ^/api/(.*)$ /$1 break;
			proxy_pass http://localhost:8080;
        }
        
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

}
</code></pre>
<h1 id="删除部门"><strong>删除部门</strong></h1>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616163023.png" alt="" loading="lazy"></figure>
<h2 id="简单参数接收"><strong>简单参数接收</strong></h2>
<ul>
<li>方案一：通过原始的 HttpServletRequest 对象获取请求参数</li>
</ul>
<pre><code class="language-java">/**
* 根据ID删除部门 - 简单参数接收: 方式一 (HttpServletRequest)
*/
@DeleteMapping(&quot;/depts&quot;)
public Result delete(HttpServletRequest request){
    String idStr = request.getParameter(&quot;id&quot;);
    int id = Integer.parseInt(idStr);
    
    System.out.println(&quot;根据ID删除部门: &quot; + id);
    return Result.success();
}
</code></pre>
<p>这种方案实现较为繁琐，而且还需要进行手动类型转换。【项目开发很少用】</p>
<ul>
<li>方案二：通过Spring提供的 @RequestParam 注解，将请求参数绑定给方法形参</li>
</ul>
<pre><code class="language-java">@DeleteMapping(&quot;/depts&quot;)
public Result delete(@RequestParam(&quot;id&quot;) Integer deptId){
    System.out.println(&quot;根据ID删除部门: &quot; + deptId);
    return Result.success();
}
</code></pre>
<p>@RequestParam 注解的value属性，需要与前端传递的参数名保持一致 。@RequestParam注解required属性默认为true，代表该参数必须传递，如果不传递将报错。 如果参数可选，可以将属性设置为false。</p>
<pre><code class="language-java">@DeleteMapping(&quot;/depts&quot;)
    public Result delete(@RequestParam(value = &quot;id&quot;,required = false) Integer deptId){
        System.out.println(&quot;根据ID删除部门: &quot; + deptId);
        return Result.success();
    }
</code></pre>
<ul>
<li>方案三：如果请求参数名与形参变量名相同，直接定义方法形参即可接收。（省略@RequestParam）</li>
</ul>
<pre><code class="language-java">@DeleteMapping(&quot;/depts&quot;)
    public Result delete(Integer Id){
        System.out.println(&quot;根据ID删除部门: &quot; + Id);
        return Result.success();
    }
</code></pre>
<h2 id="代码实现-2"><strong>代码实现</strong></h2>
<p>1). Controller层</p>
<pre><code class="language-java">@DeleteMapping(&quot;/depts&quot;)
    public Result delete(Integer id){
        System.out.println(&quot;根据ID删除部门: &quot; + id);
        deptService.deleteById(id);
        return Result.success();
    }
</code></pre>
<p>2). Service层</p>
<pre><code class="language-java">@Override
    public void deleteById(Integer id) {
        deptMapper.deleteById(id);
    }
</code></pre>
<p>3). Mapper层</p>
<pre><code class="language-java">@Delete(&quot;delete from dept where id=#{id}&quot;)
    void deleteById(Integer id);
</code></pre>
<h1 id="新增部门"><strong>新增部门</strong></h1>
<p>请求路径：/depts<br>
请求方式：POST<br>
接口描述：该接口用于添加部门数据<br>
请求参数样例：</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;教研部&quot;
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616165756.png" alt="" loading="lazy"></figure>
<h2 id="json参数接收"><strong>json参数接收</strong></h2>
<p>我们看到，在controller中，需要接收前端传递的请求参数。 那接下来，我们就先来看看在服务器端的Controller程序中，如何获取json格式的参数。</p>
<ul>
<li>JSON格式的参数，通常会使用一个实体对象进行接收 。</li>
<li>规则：JSON数据的键名与方法形参对象的属性名相同，并需要使用@RequestBody注解标识。</li>
</ul>
<h2 id="代码实现-3"><strong>代码实现</strong></h2>
<p>1). Controller层</p>
<pre><code class="language-java">@PostMapping(&quot;/depts&quot;)
    public Result add(@RequestBody Dept dept){
        System.out.println(&quot;新增部门：&quot; + dept);
        deptService.add(dept);
        return Result.success();
    }
</code></pre>
<p>2). Service层</p>
<pre><code class="language-java">@Override
    public void add(Dept dept) {
        //1.补全基础属性
        dept.setCreateTime(LocalDateTime.now());
        dept.setUpdateTime(LocalDateTime.now());
        //2.调用Mapper接口方法插入数据
        deptMapper.insert(dept);
    }
</code></pre>
<p>3). Mapper层</p>
<pre><code class="language-java">@Insert(&quot;insert into dept(name,create_time,update_time) values (#{name},#{createTime},#{updateTime})&quot;)
    void insert(Dept dept);
</code></pre>
<h1 id="修改部门"><strong>修改部门</strong></h1>
<h2 id="查询回显"><strong>查询回显</strong></h2>
<p>请求路径：/depts/{id}<br>
请求方式：GET<br>
接口描述：该接口用于根据ID查询部门数据<br>
请求参数样例：<br>
/depts/1<br>
/depts/3<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616171714.png" alt="" loading="lazy"></p>
<h3 id="路径参数接收"><strong>路径参数接收</strong></h3>
<p>/depts/1，/depts/2 这种在url中传递的参数，我们称之为路径参数。<br>
路径参数：通过请求URL直接传递参数，使用{…}来标识该路径参数，需要使用 @PathVariable获取路径参数。如果路径参数名与controller方法形参名称一致，@PathVariable注解的value属性是可以省略的。可以传递多个路径参数，如果名称都相同都可以省略。</p>
<h3 id="代码实现-4"><strong>代码实现</strong></h3>
<p>1). Controller层</p>
<pre><code class="language-java">@GetMapping(&quot;/depts/{id}&quot;)
    public Result getInfo(@PathVariable Integer id){
        System.out.println(&quot;根据路径查询id: &quot; + id);
        Dept dept=deptService.getById(id);
        return Result.success(dept);
    }
</code></pre>
<p>2). Service层</p>
<pre><code class="language-java">@Override
    public Dept getById(Integer id) {
        return deptMapper.getById(id);
    }
</code></pre>
<p>3). Mapper层</p>
<pre><code class="language-java">@Select(&quot;select id, name, create_time , update_time from dept where id=#{id}&quot;)
    Dept getById(Integer id);
</code></pre>
<h2 id="修改数据"><strong>修改数据</strong></h2>
<p>请求路径：/depts<br>
请求方式：PUT<br>
接口描述：该接口用于修改部门数据<br>
请求参数样例：</p>
<pre><code class="language-json">{
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;教研部&quot;
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616173300.png" alt="" loading="lazy"></figure>
<h3 id="代码实现-5"><strong>代码实现</strong></h3>
<p>1). Controller层</p>
<pre><code class="language-java">@PutMapping(&quot;/depts&quot;)
    public Result update(@RequestBody Dept dept){
        System.out.println(&quot;修改部门：&quot; + dept);
        deptService.update(dept);
        return Result.success();
    }
</code></pre>
<p>2). Service层</p>
<pre><code class="language-java">@Override
    public void update(Dept dept) {
        dept.setUpdateTime(LocalDateTime.now());
        deptMapper.update(dept);
    }
</code></pre>
<p>3). Mapper层</p>
<pre><code class="language-java">@Update(&quot;update dept set name=#{name} , update_time=#{updateTime} where id=#{id}&quot;)
    void update(Dept dept);
</code></pre>
<h3 id="requestmapping"><strong>@RequestMapping</strong></h3>
<p>我们在 DeptController 中所定义的方法，所有的请求路径，都是 /depts 开头的，我们其实是可以把这个公共的路径 /depts 抽取到类上的，那在各个方法上，就可以省略了这个 /depts 路径。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616174332.png" alt="" loading="lazy"><br>
一个完整的请求路径，应该是类上的 @RequestMapping 的value属性 + 方法上的 @RequestMapping的value属性。</p>
<h1 id="日志技术"><strong>日志技术</strong></h1>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616211026.png" alt="" loading="lazy"></figure>
<ul>
<li>JUL：这是JavaSE平台提供的官方日志框架，也被称为JUL。配置相对简单，但不够灵活，性能较差。</li>
<li>Log4j：一个流行的日志框架，提供了灵活的配置选项，支持多种输出目标。</li>
<li>Logback：基于Log4j升级而来，提供了更多的功能和配置选项，性能由于Log4j。</li>
<li>Slf4j：（Simple Logging Facade for Java）简单日志门面，提供了一套日志操作的标准接口及抽象类，允许应用程序使用不同的底层日志框架。</li>
</ul>
<h2 id="logback入门"><strong>Logback入门</strong></h2>
<p>1). 准备工作：引入logback的依赖（springboot中无需引入，在springboot中已经传递了此依赖）</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
    &lt;version&gt;1.4.11&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2). 引入配置文件 logback.xml  （资料中已经提供，拷贝进来，放在 src/main/resources 目录下； 或者直接AI生成）</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
    &lt;!-- 控制台输出 --&gt;
    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度  %logger{50}: 显示日志记录器的名称，最长50个字符(超出.切割)  %msg：日志消息，%n是换行符 --&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    
    &lt;!-- 日志输出级别 --&gt;
    &lt;root level=&quot;debug&quot;&gt;
        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<p>3). 记录日志：定义日志记录对象Logger，记录日志</p>
<pre><code class="language-java">package com.ys;

import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
public class LogTest {
    private static Logger log = LoggerFactory.getLogger(LogTest.class);

    @Test
    public void testLog(){
        //System.out.println(LocalDateTime.now() + &quot; : 开始计算...&quot;);
        log.debug(&quot;开始计算...&quot;);

        int sum = 0;
        int[] nums = {1, 5, 3, 2, 1, 4, 5, 4, 6, 7, 4, 34, 2, 23};
        for (int num : nums) {
            sum += num;
        }
        
        //System.out.println(&quot;计算结果为: &quot;+sum);
        //System.out.println(LocalDateTime.now() + &quot;结束计算...&quot;);
        log.info(&quot;计算结果为: &quot;+sum);
        log.debug(&quot;结束计算...&quot;);
    }
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250616213024.png" alt="" loading="lazy"></figure>
<h2 id="logback配置文件"><strong>Logback配置文件</strong></h2>
<p>Logback日志框架的配置文件叫 logback.xml 。<br>
该配置文件是对Logback日志框架输出的日志进行控制的，可以来配置输出的格式、位置及日志开关等。<br>
常用的两种输出日志的位置：控制台、系统文件。<br>
1). 如果需要输出日志到控制台。添加如下配置：</p>
<pre><code class="language-xml">&lt;!-- 控制台输出 --&gt;
&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
    &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;
            &lt;!--格式化输出：%d 表示日期，%thread 表示线程名，%-5level表示级别从左显示5个字符宽度，%msg表示日志消息，%n表示换行符 --&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50}-%msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
&lt;/appender&gt;
</code></pre>
<p>2). 如果需要输出日志到文件。添加如下配置：</p>
<pre><code class="language-java">&lt;!-- 按照每天生成日志文件 --&gt;
&lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt;
        &lt;!-- 日志文件输出的文件名, %i表示序号（从零开始） --&gt;
        &lt;FileNamePattern&gt;D:/tlias-%d{yyyy-MM-dd}-%i.log&lt;/FileNamePattern&gt;
        &lt;!-- 最多保留的历史日志文件数量 --&gt;
        &lt;MaxHistory&gt;30&lt;/MaxHistory&gt;
        &lt;!-- 最大文件大小，超过这个大小会触发滚动到新文件，默认为 10MB --&gt;
        &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;
    &lt;/rollingPolicy&gt;

    &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;
        &lt;!--格式化输出：%d 表示日期，%thread 表示线程名，%-5level表示级别从左显示5个字符宽度，%msg表示日志消息，%n表示换行符 --&gt;
        &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50}-%msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
&lt;/appender&gt;
</code></pre>
<p>3). 日志开关配置 （开启日志（ALL），取消日志（OFF））</p>
<pre><code class="language-java">&lt;!-- 日志输出级别（不区分大小写） --&gt;
&lt;root level=&quot;ALL&quot;&gt;
    &lt;!--输出到控制台--&gt;
    &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;
    &lt;!--输出到文件--&gt;
    &lt;appender-ref ref=&quot;FILE&quot; /&gt;
&lt;/root&gt;
</code></pre>
<h2 id="logback日志级别"><strong>Logback日志级别</strong></h2>
<p>日志级别指的是日志信息的类型，日志都会分级别，常见的日志级别如下（优先级由低到高）：</p>
<table>
<thead>
<tr>
<th>日志级别</th>
<th>说明</th>
<th>记录方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>trace</td>
<td>追踪，记录程序运行轨迹 【使用很少】</td>
<td>log.trace(&quot;...&quot;)</td>
</tr>
<tr>
<td>debug</td>
<td>调试，记录程序调试过程中的信息，实际应用中一般将其视为最低级别 【使用较多】</td>
<td>log.debug(&quot;...&quot;)</td>
</tr>
<tr>
<td>info</td>
<td>记录一般信息，描述程序运行的关键事件，如：网络连接、io操作 【使用较多】</td>
<td>log.info(&quot;...&quot;)</td>
</tr>
<tr>
<td>warn</td>
<td>警告信息，记录潜在有害的情况 【使用较多】</td>
<td>log.warn(&quot;...&quot;)</td>
</tr>
<tr>
<td>error</td>
<td>错误信息 【使用较多】</td>
<td>log.error(&quot;...&quot;)</td>
</tr>
</tbody>
</table>
<p>可以在配置文件logback.xml中，灵活的控制输出那些类型的日志。（大于等于配置的日志级别的日志才会输出）</p>
<h2 id="案例日志记录"><strong>案例日志记录</strong></h2>
<pre><code class="language-java">@Slf4j
@RequestMapping(&quot;/depts&quot;)
@RestController
public class DeptController {

    //private static final Logger logger = LoggerFactory.getLogger(DeptController.class);

    @Autowired
    private DeptService deptService;
    //@RequestMapping(value = &quot;/depts&quot;,method = RequestMethod.GET)//指定请求方式
    @GetMapping
    public Result list(){
        //System.out.println(&quot;查询全部部门数据&quot;);
        log.info(&quot;查询全部部门数据&quot;);
        List&lt;Dept&gt; deptList= deptService.findALL();
        return Result.success(deptList);
    }

    @DeleteMapping
    public Result delete(Integer id){
        //System.out.println(&quot;根据ID删除部门: &quot; + id);
        log.info(&quot;根据ID删除部门: {}&quot; , id);
        deptService.deleteById(id);
        return Result.success();
    }

    @PostMapping
    public Result add(@RequestBody Dept dept){
        //System.out.println(&quot;新增部门：&quot; + dept);
        log.info(&quot;新增部门：{}&quot; , dept);
        deptService.add(dept);
        return Result.success();
    }

    @GetMapping(&quot;/{id}&quot;)
    public Result getInfo(@PathVariable Integer id){
        //System.out.println(&quot;根据路径查询id: &quot; + id);
        log.info(&quot;根据路径查询id: {}&quot;,id);
        Dept dept=deptService.getById(id);
        return Result.success(dept);
    }

    @PutMapping
    public Result update(@RequestBody Dept dept){
        //System.out.println(&quot;修改部门：&quot; + dept);
        log.info(&quot;修改部门：{}&quot; , dept);
        deptService.update(dept);
        return Result.success();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JDBC]]></title>
        <id>https://yyss1014.github.io/post/jdbc/</id>
        <link href="https://yyss1014.github.io/post/jdbc/">
        </link>
        <updated>2025-05-30T07:55:24.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#jdbc"><strong>JDBC</strong></a>
<ul>
<li><a href="#%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F"><strong>入门程序</strong></a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><strong>查询数据</strong></a></li>
<li><a href="#%E9%A2%84%E7%BC%96%E8%AF%91sql"><strong>预编译SQL</strong></a></li>
</ul>
</li>
<li><a href="#mybatis"><strong>MyBatis</strong></a>
<ul>
<li><a href="#%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F-2"><strong>入门程序</strong></a></li>
<li><a href="#%E8%BE%85%E5%8A%A9%E9%85%8D%E7%BD%AE"><strong>辅助配置</strong></a></li>
<li><a href="#jdbc-vs-mybatis"><strong>JDBC VS  Mybatis</strong></a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><strong>数据库连接池</strong></a>
<ul>
<li><a href="#hikari%E8%BF%BD%E5%85%89%E8%80%85"><strong>Hikari（追光者）</strong></a></li>
<li><a href="#druid%E5%BE%B7%E9%B2%81%E4%BC%8A"><strong>Druid（德鲁伊）</strong></a></li>
</ul>
</li>
<li><a href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C"><strong>增删改操作</strong></a>
<ul>
<li><a href="#%E5%88%A0%E9%99%A4"><strong>删除</strong></a></li>
<li><a href="#%E6%96%B0%E5%A2%9E"><strong>新增</strong></a></li>
<li><a href="#%E6%9B%B4%E6%96%B0"><strong>更新</strong></a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2"><strong>查询</strong></a></li>
</ul>
</li>
<li><a href="#xml%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE"><strong>XML映射配置</strong></a>
<ul>
<li><a href="#%E8%BE%85%E5%8A%A9%E9%85%8D%E7%BD%AE-2"><strong>辅助配置</strong></a></li>
<li><a href="#mybatisx%E7%9A%84%E4%BD%BF%E7%94%A8"><strong>MybatisX的使用</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><strong>SpringBoot配置文件</strong></a>
<ul>
<li><a href="#yml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><strong>yml配置文件</strong></a></li>
<li><a href="#%E6%A1%88%E4%BE%8B"><strong>案例</strong></a></li>
</ul>
</li>
</ul>
</p>
<h1 id="jdbc"><strong>JDBC</strong></h1>
<p>JDBC：（Java DataBase Connectivity），就是使用Java语言操作关系型数据库的一套API。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250530155716.png" alt="" loading="lazy"></p>
<h2 id="入门程序"><strong>入门程序</strong></h2>
<p>准备数据库web01：</p>
<pre><code class="language-sql">create table user(
    id int unsigned primary key auto_increment comment 'ID,主键',
    username varchar(20) comment '用户名',
    password varchar(32) comment '密码',
    name varchar(10) comment '姓名',
    age tinyint unsigned comment '年龄'
) comment '用户表';

insert into user(id, username, password, name, age) values (1, 'daqiao', '123456', '大乔', 22),
                                                           (2, 'xiaoqiao', '123456', '小乔', 18),
                                                           (3, 'diaochan', '123456', '貂蝉', 24),
                                                           (4, 'lvbu', '123456', '吕布', 28),
                                                           (5, 'zhaoyun', '12345678', '赵云', 27);
</code></pre>
<p>在 pom.xml 文件中引入依赖：</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;!-- MySQL JDBC driver --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.30&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
        &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
        &lt;version&gt;5.9.3&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>在 src/main/test/java 目录下编写测试类，定义测试方法：</p>
<pre><code class="language-java">public class JdbcTest {
    /*
     * JDBC入门程序
     */
    @Test
    public void testUpdate() throws Exception {
        //1.注册驱动
        //两次shift提示
        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        //2.获取数据库连接
        String url=&quot;jdbc:mysql://localhost:3306/web01&quot;;
        String username=&quot;root&quot;;
        String password=&quot;123456&quot;;
        Connection connection=DriverManager.getConnection(url,username,password);
        //3.获取SQL语句执行对象
        Statement statement=connection.createStatement();
        //4.执行SQL
        int i=statement.executeUpdate(&quot;update user set age=25 where id=1&quot;);//DML
        System.out.println(&quot;SQL语句执行完毕影响的记录数为：&quot;+i);
        //5.释放资源
        statement.close();
        connection.close();
    }
}
</code></pre>
<h2 id="查询数据"><strong>查询数据</strong></h2>
<p>ResultSet（结果集对象）：封装了DQL查询语句查询的结果。</p>
<ul>
<li>next()：将光标从当前位置（开始默认表头）向前移动一行，并判断当前行是否为有效行，返回值为boolean。
<ul>
<li>true：有效行，当前行有数据</li>
<li>false：无效行，当前行没有数据</li>
</ul>
</li>
<li>getXxx(…)：获取数据，可以根据列的编号获取，也可以根据列名获取（推荐）。</li>
</ul>
<pre><code class="language-java">@Test
    public void testSelect() throws Exception {
       String url=&quot;jdbc:mysql://localhost:3306/web01&quot;;
       String username=&quot;root&quot;;
       String password=&quot;123456&quot;;

       Connection conn=null;
       PreparedStatement stmt=null;
       ResultSet rs=null;


       try {
           Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
           conn =DriverManager.getConnection(url,username,password);
           String sql=&quot;select id,username,password,name,age from user where username = ? and password = ?&quot;;
           //?是占位符
           stmt= conn.prepareStatement(sql);
           stmt.setString(1,&quot;daqiao&quot;);
           stmt.setString(2,&quot;123456&quot;);
           //封装查询返回的结果
           rs=stmt.executeQuery();
           while(rs.next()) {
               User user = new User(
                       rs.getInt(&quot;id&quot;),
                       rs.getString(&quot;username&quot;),
                       rs.getString(&quot;password&quot;),
                       rs.getString(&quot;name&quot;),
                       rs.getInt(&quot;age&quot;)
               );
               System.out.println(user);//使用lombok的@Data自动生成的toString方法
           }
       } catch (Exception e) {
           e.printStackTrace();
       } finally {
           try {
               if(rs!=null) rs.close();
               if(stmt!=null) stmt.close();
               if(conn!=null) conn.close();
           } catch (SQLException e) {
               e.printStackTrace();
           }
       }
    }
</code></pre>
<h2 id="预编译sql"><strong>预编译SQL</strong></h2>
<p>SQL注入：通过控制输入来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。<br>
在cmd窗口运行jar包：</p>
<pre><code class="language-cmd">java -jar sql_Injection_demo-0.0.1-SNAPSHOT.jar
</code></pre>
<pre><code class="language-sql">SELECT * FROM user WHERE username = 'shfhsjfhja' AND password = '' or '1' = '1 '
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250530213135.png" alt="" loading="lazy"><br>
而通过预编译SQL（select * from user where username = ? and password = ?），就可以直接解决上述SQL注入的问题且性能更高。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250530213458.png" alt="" loading="lazy"></p>
<h1 id="mybatis"><strong>MyBatis</strong></h1>
<ul>
<li>MyBatis是一款优秀的 持久层 框架，用于简化JDBC的开发。</li>
<li>MyBatis本是 Apache的一个开源项目iBatis，2010年这个项目由apache迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。</li>
<li>官网：https://mybatis.net.cn/<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250530215917.png" alt="" loading="lazy"></li>
</ul>
<h2 id="入门程序-2"><strong>入门程序</strong></h2>
<ol>
<li>创建工程<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250610212114.png" alt="" loading="lazy"><br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250610212128.png" alt="" loading="lazy"></li>
<li>数据准备</li>
</ol>
<pre><code class="language-java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private Integer id;
    private String username;
    private String password;
    private String name;
    private Integer age;
}
</code></pre>
<p>数据库创建同JDBC。<br>
3. 配置属性文件<br>
在 application.properties 中配置数据库的连接信息。</p>
<pre><code class="language-xml">spring.application.name=springboot-mybatis-quickstart

# 配置数据库的连接信息（字符编码在settings中的file encoding中配置）
#数据库访问的url地址
spring.datasource.url=jdbc:mysql://localhost:3306/web01
#数据库驱动类类名
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#访问数据库-用户名
spring.datasource.username=root
#访问数据库-密码
spring.datasource.password=123456
</code></pre>
<ol start="4">
<li>创建接口</li>
</ol>
<pre><code class="language-java">@Mapper//应用程序在运行时，会自动的为该接口创建一个实现类对象（代理对象），并且会自动将该实现类存入IOC容器-bean
public interface UserMapper {
    /*查询所有用户*/
    @Select(&quot;select * from user&quot;)//自动将查询的结果封装给返回值
    public List&lt;User&gt; findAll();
}
</code></pre>
<ol start="5">
<li>单元测试<br>
在创建出来的SpringBoot工程中，在src下的test目录下，已经自动帮我们创建好了测试类(名字要与启动类相同) ，并且在测试类上已经添加了注解 @SpringBootTest，代表该测试类已经与SpringBoot整合。<br>
该测试类在运行时，会自动通过引导类加载Spring的环境（IOC容器）。我们要测试那个bean对象，就可以直接通过@Autowired注解直接将其注入进行，然后就可以测试了。</li>
</ol>
<pre><code class="language-java">@SpringBootTest//SpringBoot单元测试的注解-当前测试类中的方法运行时，会启动springboot项目-IOC容器
class SpringbootMybatisQuickstartApplicationTests {

    @Autowired
    private UserMapper userMapper;
    @Test
    public void testFindAll() {
        List&lt;User&gt; users = userMapper.findAll();
        users.forEach(System.out::println);
    }
}
</code></pre>
<h2 id="辅助配置"><strong>辅助配置</strong></h2>
<p>默认我们在UserMapper接口上加的 @Select 注解中编写SQL语句是没有提示的。 如果想让idea给我们提示对应的SQL语句，我们需要在IDEA中配置与MySQL数据库的链接。<br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250610214801.png" alt="" loading="lazy"><br>
配置完成之后，发现SQL语句中的关键字有提示了，但Idea和数据库没有建立连接，不识别表信息。需要在Idea界面右侧配置数据库连接。<br>
除此之外，在File----&gt;Setting---&gt;Languages &amp; Frameworks---&gt;SQL Dialects中，选择对应的数据库，如MySQL，之后点击保存即可。<br>
默认情况下，在Mybatis中，SQL语句执行时，我们并看不到SQL语句的执行日志。 在application.properties加入如下配置，即可查看日志：</p>
<pre><code class="language-xml">#mybatis的配置
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
</code></pre>
<h2 id="jdbc-vs-mybatis"><strong>JDBC VS  Mybatis</strong></h2>
<p>JDBC程序的缺点：</p>
<ul>
<li>url、username、password 等相关参数全部硬编码在java代码中。</li>
<li>查询结果的解析、封装比较繁琐。</li>
<li>每一次操作数据库之前，先获取连接，操作完毕之后，关闭连接。 频繁的获取连接、释放连接造成资源浪费。</li>
</ul>
<p>分析了JDBC的缺点之后，我们再来看一下在mybatis中，是如何解决这些问题的：</p>
<ul>
<li>数据库连接四要素(驱动、链接、用户名、密码)，都配置在springboot默认的配置文件 application.properties中</li>
<li>查询结果的解析及封装，由mybatis自动完成映射封装，我们无需关注</li>
<li>在mybatis中使用了数据库连接池技术（类似线程池），从而避免了频繁的创建连接、销毁连接而带来的资源浪费。</li>
</ul>
<h2 id="数据库连接池"><strong>数据库连接池</strong></h2>
<ul>
<li>数据库连接池是个容器，负责分配、管理数据库连接(Connection)。</li>
<li>程序在启动时，会在数据库连接池(容器)中，创建一定数量的Connection对象。</li>
<li>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏。- 客户端获取到Connection对象了，但是Connection对象并没有去访问数据库(处于空闲)，数据库连接池发现Connection对象的空闲时间 &gt; 连接池中预设的最大空闲时间，此时数据库连接池就会自动释放掉这个连接对象。</li>
</ul>
<p>数据库连接池的好处：</p>
<ul>
<li>资源重用</li>
<li>提升系统响应速度</li>
<li>避免数据库连接遗漏</li>
</ul>
<p>官方(sun)提供了数据库连接池标准（javax.sql.DataSource接口）。</p>
<pre><code class="language-java">public Connection getConnection() throws SQLException;
</code></pre>
<p>常见的数据库连接池：C3P0 、DBCP 、Druid 、Hikari (springboot默认)</p>
<h3 id="hikari追光者"><strong>Hikari（追光者）</strong></h3>
<p><img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250610220730.png" alt="" loading="lazy"><br>
<img src="https://cdn.jsdelivr.net/gh/yyss1014/blog_img@main/20250610221159.png" alt="" loading="lazy"></p>
<h3 id="druid德鲁伊"><strong>Druid（德鲁伊）</strong></h3>
<ul>
<li>Druid连接池是阿里巴巴开源的数据库连接池项目</li>
<li>功能强大，性能优秀，是Java语言最好的数据库连接池之一</li>
</ul>
<p>参考官方地址：https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter<br>
切换连接池：<br>
在pom.xml文件中引入依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;!-- Druid连接池依赖 --&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.2.19&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>在application.properties中引入数据库连接配置：</p>
<pre><code class="language-properties">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.druid.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.druid.url=jdbc:mysql://localhost:3306/web
spring.datasource.druid.username=root
spring.datasource.druid.password=1234
</code></pre>
<h2 id="增删改操作"><strong>增删改操作</strong></h2>
<h3 id="删除"><strong>删除</strong></h3>
<pre><code class="language-java">/**
 * 根据id删除
 */
@Delete(&quot;delete from user where id = #{id}&quot;)
public void deleteById(Integer id);
</code></pre>
<p>DML语句执行完毕，是有返回值的，我们可以为Mapper接口方法定义返回值来接收，如下：</p>
<pre><code class="language-java">/**
 * 根据id删除
 */
@Delete(&quot;delete from user where id = #{id}&quot;)
public Integer deleteById(Integer id);
</code></pre>
<p>Integer类型的返回值，表示DML语句执行完毕影响的记录数。<br>
Mybatis的提供的符号，有两个，一个是 #{...}，另一个是 ${...}，区别如下：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>#{…}</td>
<td>占位符。执行时，会将#{…}替换为?，生成预编译SQL</td>
<td>参数值传递</td>
</tr>
<tr>
<td>${…}</td>
<td>拼接符。直接将参数拼接在SQL语句中，存在SQL注入问题</td>
<td>表名、字段名动态设置时使用</td>
</tr>
</tbody>
</table>
<h3 id="新增"><strong>新增</strong></h3>
<pre><code class="language-java">@Insert(&quot;insert into user(username,password,name,age) values (#{username},#{password},#{name},#{age})&quot;)
    public void insert(User user);
</code></pre>
<p>在测试类中添加测试方法，代码如下：</p>
<pre><code class="language-java">@Test
    public void testInsert() {
        User user = new User(null,&quot;gaoyuanyuan&quot;,&quot;666888&quot;,&quot;高圆圆&quot;,18);
        userMapper.insert(user);
    }
</code></pre>
<h3 id="更新"><strong>更新</strong></h3>
<pre><code class="language-java">@Update(&quot;update user set username=#{username},password=#{password},name=#{name},age=#{age} where id=#{id}&quot;)
    public void update(User user);
</code></pre>
<pre><code class="language-java"> @Test
    public void testUpdate() {
        User user = new User(1,&quot;zhouyu&quot;,&quot;666888&quot;,&quot;周瑜&quot;,20);
        userMapper.update(user);
    }
</code></pre>
<h3 id="查询"><strong>查询</strong></h3>
<p>定义的接口方法，在java文件编译为字节码文件后，形参名称不会保留，sql语句的占位符无法识别。</p>
<pre><code class="language-java">/**
 * 根据用户名和密码查询用户信息
 */
@Select(&quot;select * from user where username = #{username} and password = #{password}&quot;)
public User findByUsernameAndPassword(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);
</code></pre>
<p>@param注解的作用是为接口的方法形参起名字的。</p>
<ul>
<li>说明：基于官方骨架创建的springboot项目中，接口编译时会保留方法形参名，@Param注解可以省略 (#{形参名})。</li>
</ul>
<pre><code class="language-xml">&lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
</code></pre>
<pre><code class="language-java">/**
 * 根据用户名和密码查询用户信息
 */
@Select(&quot;select * from user where username = #{username} and password = #{password}&quot;)
public User findByUsernameAndPassword(String username, String password);
</code></pre>
<p>究其原因，sprintboot官方骨架的父工程有个maven项目编译插件，有一个parameters为true的配置项。</p>
<pre><code class="language-xml">&lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;configuration&gt;
            &lt;parameters&gt;true&lt;/parameters&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
</code></pre>
<h2 id="xml映射配置"><strong>XML映射配置</strong></h2>
<p>使用Mybatis的注解方式，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句，也就是将SQL语句写在XML配置文件中。语法见官网。</p>
<ol>
<li>XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）（在resource文件夹下创建，路径用/分隔）</li>
<li>XML映射文件的namespace属性为Mapper接口全限定名一致</li>
<li>XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回单条记录类型一致。</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.ys.mapper.UserMapper&quot;&gt;
&lt;!--    resultType 属性的值，与查询返回的单条记录封装的类型一致--&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;com.ys.pojo.User&quot;&gt;
        select * from user
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="language-java">public List&lt;User&gt; findAll();
</code></pre>
<p>一个接口方法对应的SQL语句，要么使用注解配置，要么使用XML配置，切不可同时配置。</p>
<h3 id="辅助配置-2"><strong>辅助配置</strong></h3>
<p>java和resource编译后都会放在target的class目录下，更改xml位置为resource/mapper/UserMapper.xml后，在application.properties属性文件可以修改如下：</p>
<pre><code class="language-properties">#指定xml映射配置文件的位置
mybatis.mapper-locations=classpath:mapper/*.xml
</code></pre>
<h3 id="mybatisx的使用"><strong>MybatisX的使用</strong></h3>
<p>MybatisX是一款基于IDEA的快速开发Mybatis的插件，为效率而生，可以通过MybatisX快速定位。</p>
<h1 id="springboot配置文件"><strong>SpringBoot配置文件</strong></h1>
<p>前面我们一直使用springboot项目创建完毕后自带的application.properties进行属性的配置，而如果在项目中，我们需要配置大量的属性，采用properties配置文件这种 key=value 的配置形式，就会显得配置文件的层级结构不清晰，也比较臃肿。</p>
<ul>
<li>SpringBoot项目提供了多种属性配置方式（properties、yaml、yml）。</li>
</ul>
<h2 id="yml配置文件"><strong>yml配置文件</strong></h2>
<p>yml格式配置文件名字为：application.yaml , application.yml 这两个配置文件的后缀名虽然不一样，但是里面配置的内容形式都是一模一样的。基本语法如下：</p>
<ul>
<li>大小写敏感</li>
<li>数值前边必须有空格，作为分隔符</li>
<li>使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）</li>
<li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li>
<li>#表示注释，从这个字符一直到行尾，都会被解析器忽略</li>
</ul>
<p>yml文件中常见的数据格式：</p>
<ul>
<li>对象/Map集合</li>
</ul>
<pre><code class="language-yaml">user:
  name: zhangsan
  age: 18
  password: 123456
</code></pre>
<ul>
<li>数组/List/Set集合</li>
</ul>
<pre><code class="language-yaml">hobby: 
  - java
  - game
  - sport
</code></pre>
<p>在yml格式的配置文件中，如果配置项的值是以 0 开头的，值需要使用 '' 引起来，因为以0开头在yml中表示8进制的数据。(&quot;0123&quot;)</p>
<h2 id="案例"><strong>案例</strong></h2>
<p>我们修改下之前案例中使用的配置文件，变更为application.yml配置方式：</p>
<pre><code class="language-yaml">spring:
  application:
    name: springboot-mybatis-quickstart
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    url: jdbc:mysql://localhost:3306/web01
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: 123456
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  mapper-locations: classpath:mapper/*.xml
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL语句]]></title>
        <id>https://yyss1014.github.io/post/sql-yu-ju/</id>
        <link href="https://yyss1014.github.io/post/sql-yu-ju/">
        </link>
        <updated>2025-05-28T11:52:09.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#ddl"><strong>DDL</strong></a>
<ul>
<li><a href="#%E8%A1%A8%E6%93%8D%E4%BD%9C"><strong>表操作</strong></a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%A0%BC"><strong>创建表格</strong></a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><strong>数据类型</strong></a></li>
<li><a href="#%E8%A1%A8%E6%93%8D%E4%BD%9C-2"><strong>表操作</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#dml"><strong>DML</strong></a>
<ul>
<li><a href="#%E5%A2%9E%E5%8A%A0"><strong>增加</strong></a></li>
<li><a href="#%E6%9B%B4%E6%96%B0"><strong>更新</strong></a></li>
<li><a href="#%E5%88%A0%E9%99%A4"><strong>删除</strong></a></li>
</ul>
</li>
<li><a href="#dql"><strong>DQL</strong></a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2"><strong>基础查询</strong></a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><strong>条件查询</strong></a></li>
<li><a href="#%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2"><strong>分组聚合查询</strong></a></li>
<li><a href="#%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2"><strong>排序查询</strong></a></li>
<li><a href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><strong>分页查询</strong></a></li>
</ul>
</li>
</ul>
</p>
<h1 id="ddl"><strong>DDL</strong></h1>
<h2 id="表操作"><strong>表操作</strong></h2>
<h3 id="创建表格"><strong>创建表格</strong></h3>
<pre><code class="language-sql">create table user(
    id int comment 'ID，唯一标识',
    username varchar(50) comment '用户名',# 字符最长50
    name varchar(10) comment '姓名',
    age int comment '年龄',
    gender char(1) comment '性别'
)comment '用户信息表';
</code></pre>
<p>所谓约束就是作用在表中字段上的规则，用于限制存储在表中的数据，来保证数据库当中数据的正确性、有效性和完整性。在MySQL数据库当中，提供了以下5种约束：</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>非空约束</td>
<td>限制该字段值不能为null</td>
<td>not null</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证字段的所有数据都是唯一、不重复的</td>
<td>unique</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>primary key</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段值，则采用默认值</td>
<td>default</td>
</tr>
<tr>
<td>外键约束</td>
<td>让两张表的数据建立连接，保证数据的一致性和完整性</td>
<td>foreign key</td>
</tr>
</tbody>
</table>
<p>主键自增：auto_increment</p>
<ul>
<li>每次插入新的行记录时，数据库自动生成id字段(主键)下的值</li>
<li>具有auto_increment的数据列是一个正数序列开始增长(从1开始自增)，可以指定主键，下次增加会从指定的主键增长</li>
</ul>
<pre><code class="language-sql">create table user(
    id int primary key  auto_increment comment 'ID，唯一标识',-- 主键约束
    username varchar(50) not null unique comment '用户名', -- 非空且唯一
    name varchar(10) not null comment '姓名',-- 非空
    age int comment '年龄',
    gender char(1) default '男' comment '性别'-- 默认
)comment '用户信息表';
</code></pre>
<h3 id="数据类型"><strong>数据类型</strong></h3>
<p>MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。<br>
数值类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>有符号(SIGNED)范围</th>
<th>无符号(UNSIGNED)范围</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1byte</td>
<td>(-128，127)</td>
<td>(0，255)</td>
<td>小整数值</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2bytes</td>
<td>(-32768，32767)</td>
<td>(0，65535)</td>
<td>大整数值</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3bytes</td>
<td>(-8388608，8388607)</td>
<td>(0，16777215)</td>
<td>大整数值</td>
</tr>
<tr>
<td>INT/INTEGER</td>
<td>4bytes</td>
<td>(-2147483648，2147483647)</td>
<td>(0，4294967295)</td>
<td>大整数值</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8bytes</td>
<td>(-2<sup>63，2</sup>63-1)</td>
<td>(0，2^64-1)</td>
<td>极大整数值</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4bytes</td>
<td>(-3.402823466 E+38，3.402823466351 E+38)</td>
<td>0 和 (1.175494351 E-38，3.402823466 E+38)</td>
<td>单精度浮点数值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8bytes</td>
<td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td>
<td>0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308)</td>
<td>双精度浮点数值</td>
</tr>
<tr>
<td>DECIMAL</td>
<td></td>
<td>依赖于M(精度)和D(标度)的值</td>
<td>依赖于M(精度)和D(标度)的值</td>
<td>小数值(精确定点数)</td>
</tr>
</tbody>
</table>
<p>在满足业务需求的情况下，尽可能选择占用磁盘空间小的数据类型。</p>
<pre><code class="language-sql">-- 年龄字段 ---不会出现负数, 而且人的年龄不会太大
   age tinyint unsigned
-- 分数 ---总分100分, 4代表整个数字长度，最多出现一位小数
   score double(4,1)
</code></pre>
<p>字符串类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR</td>
<td>0-255bytes</td>
<td>定长字符串(需要指定长度)，固定占用字符空间，性能略高</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-65535 bytes</td>
<td>变长字符串(需要指定最大长度)，动态判断字符空间，节约磁盘空间</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0-255 bytes</td>
<td>不超过255个字符的二进制数据</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0-65 535 bytes</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65 535 bytes</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0-16 777 215 bytes</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0-16 777 215 bytes</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>0-4 294 967 295 bytes</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0-4 294 967 295 bytes</td>
<td>极大文本数据</td>
</tr>
</tbody>
</table>
<p>日期时间类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小(byte)</th>
<th>范围</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01 至 9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59 至 838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901 至 2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<pre><code class="language-sql">-- 基础字段：id:主键；create_time 创建时间；update_time 修改时间；
create table emp
(
    id int unsigned primary key auto_increment comment 'ID，主键',
    username varchar(20) not null unique comment '用户名',
    password varchar(32) default '123456' comment '密码',
    name varchar(10) not null comment '姓名',
    gender tinyint unsigned not null comment '性别，1：男，2：女',
    phone char(11) not null unique comment '手机号',
    job tinyint unsigned comment '职位',
    salary int unsigned comment '薪资',
    entry_date date comment '入职日期',
    image varchar(255) comment '图像路径',
    create_time datetime comment '创建时间',
    update_time datetime comment '修改时间'
)comment '员工表';
</code></pre>
<h3 id="表操作-2"><strong>表操作</strong></h3>
<pre><code class="language-sql">-- 查询当前数据库所有表
show tables ;

-- 查询表结构
desc emp;

-- 查询建表语句
show create table emp;

-- 字段：添加字段
alter table emp add qq varchar(13) comment 'qq号码';

-- 修改字段类型
alter table emp modify qq varchar(15) comment 'qq号码';

-- 修改字段名
alter table emp change qq qq_number varchar(15) comment 'qq号码';

-- 删除字段
alter table emp drop column qq_number;

-- 修改表名
alter table emp rename to employee;

-- 删除表
drop table employee;
</code></pre>
<h1 id="dml"><strong>DML</strong></h1>
<p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。</p>
<h2 id="增加"><strong>增加</strong></h2>
<pre><code class="language-sql">-- DML : 数据操作语言
-- DML : 插入数据 - insert
-- 1. 为 emp 表的 username, password, name, gender, phone 字段插入值
insert into emp(username, password, name, gender, phone) values ('songjiang','12345678','宋江',1,'13300001111');

-- 2. 为 emp 表的 所有字段插入值
-- 方式一：
insert into emp(id, username, password, name, gender, phone, job, salary, entry_date, image, create_time, update_time)
values (null,'linchong','12345678','林冲',1,'13300001112',1,6000,'2020-01-01','1.jpg',now(),now());
-- 方式二：
insert into emp values (null,'likui','12345678','李逵',1,'13300001113',1,6000,'2020-01-01','1.jpg',now(),now());
-- 3. 批量为 emp 表的 username, password, name, gender, phone  字段插入数据
insert into emp(username, password, name, gender, phone) values
            ('ruanxiaoer','12345678','阮小二',1,'13300001114'),
            ('ruanxiaowu','12345678','阮小五',1,'13300001115');
</code></pre>
<h2 id="更新"><strong>更新</strong></h2>
<pre><code class="language-sql">-- DML : 更新数据 - update
-- 1. 将 emp 表的ID为1员工 用户名更新为 'zhangsan', 姓名name字段更新为 '张三'
update emp set username='zhangsan',name='张三' where id=1;

-- 2. 将 emp 表的所有员工的入职日期更新为 '2010-01-01'
update emp set entry_date='2010-01-01';
</code></pre>
<h2 id="删除"><strong>删除</strong></h2>
<ul>
<li>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。</li>
<li>DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。</li>
</ul>
<pre><code class="language-sql">-- DML : 删除数据 - delete
-- 1. 删除 emp 表中 ID为1的员工
delete from emp where id=1;

-- 2. 删除 emp 表中的所有员工
delete from emp;
</code></pre>
<h1 id="dql"><strong>DQL</strong></h1>
<p>DQL英文全称是Data Query Language(数据查询语言)，用来查询数据库表中的记录。<br>
查询关键字：SELECT</p>
<h2 id="基础查询"><strong>基础查询</strong></h2>
<pre><code class="language-sql">--  =================== DQL: 基本查询 ======================
-- 1. 查询指定字段 name,entry_date 并返回
select name,entry_date from emp;

-- 2. 查询返回所有字段
-- 方式一：推荐
select id, username, password, name, gender, phone, job, salary, entry_date, image, create_time, update_time from emp;
-- 方式二：不推荐
select * from emp;

-- 3. 查询所有员工的 name,entry_date, 并起别名(姓名、入职日期)
-- 起了别名展示出来的就是别名，可以不加引号，但别名中间有空格需要加引号
select name as 姓名,entry_date as 入职日期 from emp;
select name 姓名,entry_date 入职日期 from emp;

-- 4. 查询已有的员工关联了哪几种职位(不要重复)- distinct
select distinct job from emp;
</code></pre>
<h2 id="条件查询"><strong>条件查询</strong></h2>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;&gt; 或 !=</td>
<td>不等于</td>
</tr>
<tr>
<td>between ... and ...</td>
<td>在某个范围之内(含最小、最大值)</td>
</tr>
<tr>
<td>in(...)</td>
<td>在in之后的列表中的值，多选一</td>
</tr>
<tr>
<td>like 占位符</td>
<td>模糊匹配(_匹配单个字符, %匹配任意个字符)</td>
</tr>
<tr>
<td>is null</td>
<td>是null</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>and 或 &amp;&amp;</td>
<td>并且 (多个条件同时成立)</td>
</tr>
<tr>
<td>or 或||</td>
<td>或者 (多个条件任意一个成立)</td>
</tr>
<tr>
<td>not 或 !</td>
<td>非 , 不是</td>
</tr>
</tbody>
</table>
<pre><code class="language-sql">--  =================== DQL: 条件查询 ======================
-- 1. 查询 姓名 为 柴进 的员工
select * from emp where name='柴进';

-- 2. 查询 薪资小于等于5000 的员工信息
select * from emp where salary&lt;=5000;

-- 3. 查询 没有分配职位 的员工信息
select * from emp where job is null ;

-- 4. 查询 有职位 的员工信息
select * from emp where job is not null ;

-- 5. 查询 密码不等于 '123456' 的员工信息
select * from emp where password!='123456';

-- 6. 查询 入职日期 在 '2000-01-01' (包含) 到 '2010-01-01'(包含) 之间的员工信息
-- between 最小值 and 最大值
select * from emp where entry_date between '2000-01-01' and '2010-01-01';

-- 7. 查询 入职时间 在 '2000-01-01' (包含) 到 '2010-01-01'(包含) 之间 且 性别为女 的员工信息
select * from emp where (entry_date between '2000-01-01' and '2010-01-01') and gender=2;

-- 8. 查询 职位是 2 (讲师), 3 (学工主管), 4 (教研主管) 的员工信息
select * from emp where job in (2,3,4);

-- 9. 查询 姓名 为两个字的员工信息
select * from emp where name like '__';

-- 10. 查询 姓李 的员工信息
select * from emp where name like '李%';

-- 11. 查询 姓名中包含二 的员工信息
select * from emp where name like '%二%';
</code></pre>
<h2 id="分组聚合查询"><strong>分组聚合查询</strong></h2>
<p>聚合函数查询就是纵向查询，它是对一列的值进行计算，然后返回一个结果值。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>统计数量</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
</tbody>
</table>
<pre><code class="language-sql">--  =================== DQL: 分组查询 ======================
-- 聚合函数（所有聚合函数不参与null值的统计)

-- 1. 统计该企业员工数量
-- count(字段)
select count(id) from emp;
-- count(*)：推荐
select count(*) from emp;
-- count(常量)
-- 有数据的行标记一个1，最后统计1的总数
select count(1) from emp;
-- 2. 统计该企业员工的平均薪资
select avg(salary) from emp;

-- 3. 统计该企业员工的最低薪资
select min(salary) from emp;

-- 4. 统计该企业员工的最高薪资
select max(salary) from emp;

-- 5. 统计该企业每月要给员工发放的薪资总额(薪资之和)
select sum(salary) from emp;
</code></pre>
<p>where和haven的区别：</p>
<ul>
<li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li>
<li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li>
</ul>
<pre><code class="language-sql">-- 分组
-- 注意：分组之后select后的字段列表不能随便写，能写的一般是分组字段+聚合函数
-- 1. 根据性别分组 , 统计男性和女性员工的数量
select gender,count(*) from emp group by gender;

-- 2. 先查询入职时间在 '2015-01-01' (包含) 以前的员工 , 并对结果根据职位分组 , 获取员工数量大于等于2的职位
select job,count(*) from emp where entry_date&lt;='2015-01-01' group by job having count(*)&gt;=2;
</code></pre>
<h2 id="排序查询"><strong>排序查询</strong></h2>
<p>排序方式：</p>
<ul>
<li>ASC ：升序（默认值）</li>
<li>DESC：降序</li>
</ul>
<pre><code class="language-sql">--  =================== 排序查询 ======================
-- 1. 根据入职时间, 对员工进行升序排序（默认升序，asc可以不写）
select * from emp order by entry_date asc;

-- 2. 根据入职时间, 对员工进行降序排序
select * from emp order by entry_date desc;

-- 3. 根据 入职时间 对公司的员工进行 升序排序 ， 入职时间相同 , 再按照 更新时间 进行降序排序
select * from emp order by entry_date ,update_time desc;
</code></pre>
<h2 id="分页查询"><strong>分页查询</strong></h2>
<ol>
<li>起始索引从0开始。           计算公式 ：起始索引 = （查询页码 - 1）* 每页显示记录数</li>
<li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT</li>
<li>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit  条数</li>
</ol>
<pre><code class="language-sql">select  字段列表  from  表名  limit  起始索引, 查询记录数 ;
</code></pre>
<pre><code class="language-sql">--  =================== 分页查询 ======================
-- 1. 从起始索引0开始查询员工数据, 每页展示5条记录
select * from emp limit 0,5;
select * from emp limit 5;

-- 2. 查询 第1页 员工数据, 每页展示5条记录
select * from emp limit 0,5;

-- 3. 查询 第2页 员工数据, 每页展示5条记录
select * from emp limit 5,5;

-- 4. 查询 第3页 员工数据, 每页展示5条记录
select * from emp limit 10,5;
</code></pre>
]]></content>
    </entry>
</feed>